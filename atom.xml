<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverpptx&#39;s Blog</title>
  
  <subtitle>黑夜给了我黑色的眼睛，我却用它寻找光明</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-04-27T03:02:00.905Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crossoverpptx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++STL：顺序容器之vector</title>
    <link href="http://yoursite.com/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
    <id>http://yoursite.com/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/</id>
    <published>2022-04-27T02:06:23.000Z</published>
    <updated>2022-04-27T03:02:00.905Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。<a id="more"></a></p><p>vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为O(1)；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶O(n)。</p><p>vector 容器以类模板 vector&lt;T&gt;（ T 表示存储元素的类型）的形式定义在 &lt;vector&gt; 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>capacity()</td><td>返回当前容量。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>reserve()</td><td>增加容器的容量。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 vector 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>vector 容器还有一个 std::swap(x , y) 非成员函数（其中 x 和 y 是存储相同类型元素的  vector 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><h3 id="创建vector容器的几种方式"><a href="#创建vector容器的几种方式" class="headerlink" title="创建vector容器的几种方式"></a>创建vector容器的几种方式</h3><p>创建 vector 容器的方式有很多，大致可分为以下几种。</p><p>1) 如下代码展示了如何创建存储 double 类型元素的一个 vector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure><p>注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。</p><p>在创建好空容器的基础上，还可以像下面这样通过调用 reserve() 成员函数来增加容器的容量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.reserve(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素。</p><blockquote><p>还需注意的是，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector&lt;T&gt; 容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。</p></blockquote><p>2) 除了创建空 vector 容器外，还可以在创建的同时指定初始值以及元素个数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br></pre></td></tr></table></figure><p>这样就创建了一个含有 8 个素数的 vector 容器。</p><p>3) 在创建 vector 容器时，也可以指定元素个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如此，values 容器开始时就有 20 个元素，它们的默认初始值都为 0。</p><blockquote><p>注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。</p></blockquote><p>如果不想用 0 作为默认值，也可以指定一个其它值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。</p><p>值得一提的是，圆括号 () 中的 2 个参数，既可以是常量，也可以用变量来表示，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br></pre></td></tr></table></figure><p>4) 通过存储元素类型相同的其它 vector 容器，也可以创建新的 vector 容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value1(<span class="number">5</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value2(value1);</span><br></pre></td></tr></table></figure><p>由此，value2 容器中也具有 5 个字符 ‘c’。在此基础上，如果不想复制其它容器中所有的元素，可以用一对指针或者迭代器来指定初始值的范围，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>); <span class="comment">// values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value2(<span class="built_in">std</span>::<span class="built_in">begin</span>(value1),<span class="built_in">std</span>::<span class="built_in">begin</span>(value1)+<span class="number">3</span>); <span class="comment">// value2保存&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><p>由此，value2 容器中就包含了 {1,2,3} 这 3 个元素。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>vector 支持迭代器的成员函数和功能如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 vector 容器。即当操作对象为 vector 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p><p>这些成员函数的具体功能如下图所示：</p><p><img src="/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/pic1.jpg" alt></p><p>从上图可以看出，这些成员函数通常是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p><blockquote><p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p></blockquote><h4 id="vector容器迭代器的基本用法"><a href="#vector容器迭代器的基本用法" class="headerlink" title="vector容器迭代器的基本用法"></a>vector容器迭代器的基本用法</h4><p>vector 容器迭代器最常用的功能就是遍历访问容器中存储的元素。</p><p>首先来看 begin() 和 end() 成员函数，它们分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 vector 容器并输出其中的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，迭代器对象是由 vector 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样上使用它们。比如代码中，在保存了元素值后，使用前缀<code>++</code>运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，比如将上面代码中第 8、9 行代码用如下代码替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.cend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*first = 10;不能修改元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序第 12 行，由于 first 是 const 类型的迭代器，因此不能用于修改容器中元素的值。</p><p>vector 模板类中还提供了 rbegin() 和 rend() 成员函数，分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。</p><blockquote><p>需要注意的是，在使用反向迭代器进行 ++ 或 – 运算时，++ 指的是迭代器向左移动一位，– 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p></blockquote><p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.rend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：5 4 3 2 1</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="vector容器迭代器的独特之处"><a href="#vector容器迭代器的独特之处" class="headerlink" title="vector容器迭代器的独特之处"></a>vector容器迭代器的独特之处</h4><p>和 array 容器不同，vector 容器可以随着存储元素的增加，自行申请更多的存储空间。因此，在创建 vector 对象时，我们可以直接创建一个空的 vector 容器，并不会影响后续使用该容器。</p><p>但这会产生一个问题，即在初始化空的 vector 容器时，不能使用迭代器。也就是说，如下初始化 vector 容器的方法是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="comment">//初始化的同时输出值</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序可以看到，什么也没有输出。这是因为，对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。</p><blockquote><p>所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。</p></blockquote><p>除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，显示如下信息并崩溃：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0096</span>DFE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">00965560</span></span><br></pre></td></tr></table></figure><p>可以看到，values 容器在增加容量之后，首个元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的。因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0164</span>DBE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">01645560</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><h4 id="访问vector容器中单个元素"><a href="#访问vector容器中单个元素" class="headerlink" title="访问vector容器中单个元素"></a>访问vector容器中单个元素</h4><p>首先，vector 容器可以向普通数组那样访问存储的元素，甚至对指定下标处的元素进行修改，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values[<span class="number">0</span>] = values[<span class="number">1</span>] + values[<span class="number">2</span>] + values[<span class="number">3</span>] + values[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><blockquote><p>显然，vector 的索引从 0 开始，这和普通数组一样。通过使用索引，总是可以访问到 vector 容器中现有的元素。</p></blockquote><p>值得一提的是，<code>容器名[n]</code>这种获取元素的方式，需要确保下标 n 的值不会超过容器的容量（可以通过 capacity() 成员函数获取），否则会发生越界访问的错误。幸运的是，和 array 容器一样，vector 容器也提供了 at() 成员函数，当传给 at() 的索引会造成越界时，会抛出<code>std::out_of_range</code>异常。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values.at(<span class="number">0</span>) = values.at(<span class="number">1</span>) + values.at(<span class="number">2</span>) + values.at(<span class="number">3</span>) + values.at(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//下面这条语句会发生 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; values.at(5) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><blockquote><p>可能有这样一个疑问，即为什么 vector 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>除此之外，vector 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改首元素</span></span><br><span class="line">    values.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改尾元素</span></span><br><span class="line">    values.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values 首元素为：<span class="number">1</span></span><br><span class="line">values 尾元素为：<span class="number">5</span></span><br><span class="line">values 新的首元素为：<span class="number">10</span></span><br><span class="line">values 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure><p>另外，vector 容器还提供了 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//输出容器中第 3 个元素的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改容器中第 2 个元素的值</span></span><br><span class="line">    *(values.data() + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="访问vector容器中多个元素"><a href="#访问vector容器中多个元素" class="headerlink" title="访问vector容器中多个元素"></a>访问vector容器中多个元素</h4><p>如果想访问 vector 容器中多个元素，可以借助 size() 成员函数，该函数可以返回 vector 容器中实际存储的元素个数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不要使用 capacity() 成员函数，因为它返回的是 vector 容器的容量，而不是实际存储元素的个数，这两者是有差别的。</p><p>或者也可以使用基于范围的循环，此方式将会逐个遍历容器中的元素。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以使用 vector 迭代器遍历 vector 容器，这里以 begin()/end() 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，这里也可以使用 rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 以及全局函数 begin()/end() ，它们都可以实现对容器中元素的访问。</p></blockquote><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中，第 8 行代码表示向 values 容器尾部添加一个元素，但由于当前 values 容器是空的，因此新添加的元素 1 无疑成为了容器中首个元素；第 9 行代码实现的功能是在现有元素 1 的后面，添加元素 2。</p><p>运行程序，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back()"></a>emplace_back()</h4><p>该函数是 C++ 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。</p><p>emplace_back() 成员函数的用法也很简单，这里直接举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.emplace_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>读者可能会发现，以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？</p><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>为了清楚的了解它们之间的区别，创建一个包含类对象的 vector 容器，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace_back(<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.push_back(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>在此基础上，读者可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure><p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p>显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议优先选用 emplace_back()。</p><blockquote><p>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</p></blockquote><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示。</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><p>emplace() 是 C++ 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p><blockquote><p>强调：emplace() 每次只能插入一个元素，而不是多个。</p></blockquote><p>该函数的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator pos, args...)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p><blockquote><p>简单的理解 args…，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是：emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), testDemo(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure><blockquote><p>注意，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</p></blockquote><p>可以看到，通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。</p><p>简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐优先使用 emplace()。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>前面提到，无论是向现有 vector 容器中访问元素、添加元素还是插入元素，都只能借助 vector 模板类提供的成员函数，但删除 vector 容器的元素例外，完成此操作除了可以借助本身提供的成员函数，还可以借助一些全局函数。</p><p>基于不同场景的需要，删除 vecotr 容器的元素，可以使用下表中所示的函数（或者函数组合）。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table><p>1) pop_back() 成员函数的用法非常简单，它不需要传入任何的参数，也没有返回值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="comment">//输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以发现，相比原 demo 容器，新的 demo 容器删除了最后一个元素 5，容器的大小减了 1，但容量没变。</p><p>2) 如果想删除 vector 容器中指定位置处的元素，可以使用 erase() 成员函数，该函数的语法格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(pos)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 为指定被删除元素位置的迭代器，同时该函数会返回一个指向删除元素所在位置下一个位置的迭代器。</p><p>下面的例子演示了 erase() 函数的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除元素 2</span></span><br><span class="line">    <span class="comment">//输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//iter迭代器指向元素 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>通过结果不能看出，erase() 函数在删除元素时，会将删除位置后续的元素陆续前移，并将容器的大小减 1。</p><p>另外，如果不在意容器中元素的排列顺序，可以结合 swap() 和 pop_back() 函数，同样可以实现删除容器中指定位置元素的目的。</p><blockquote><p>注意，swap() 函数在头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;utility&gt;</code> 中都有定义，使用时引入其中一个即可。</p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    swap(*(<span class="built_in">std</span>::<span class="built_in">begin</span>(demo)+<span class="number">1</span>),*(<span class="built_in">std</span>::<span class="built_in">end</span>(demo)<span class="number">-1</span>));<span class="comment">//等同于 swap(demo[1],demo[4])</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//交换位置后的demo容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出demo 容器中剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>当然，除了删除容器中单个元素，还可以删除容器中某个指定区域内的所有元素，同样可以使用 erase() 成员函数实现。该函数有 2 种基本格式，前面介绍了一种，这里使用另一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 是指定被删除元素区域的迭代器，同时该函数会返回指向此区域之后一个位置的迭代器。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，和删除单个元素一样，删除指定区域内的元素时，也会将该区域后续的元素前移，并缩小容器的大小。</p><p>3) 如果要删除容器中和指定元素值相同的所有元素，可以使用 remove() 函数，该函数定义在 <code>&lt;algorithm&gt;</code> 头文件中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = demo.<span class="built_in">begin</span>(); first &lt; iter;++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>注意，在对容器执行完 remove() 函数之后，由于该函数并没有改变容器原来的大小和容量，因此无法使用之前的方法遍历容器，而是需要向程序中那样，借助 remove() 返回的迭代器完成正确的遍历。</p><blockquote><p>remove() 的实现原理是，在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，直到找到一个非目标元素，即用此元素将最先做标记的位置覆盖掉，同时将此非目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。因此，如果将上面程序中 demo 容器的元素全部输出，得到的结果为 <code>1 4 5 4 3 5</code>。</p></blockquote><p>另外还可以看到，既然通过 remove() 函数删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以使用 erase() 成员函数删掉这些 “无用” 的元素。</p><p>比如，修改上面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    demo.erase(iter, demo.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用。</p></blockquote><p>4) 如果想删除容器中所有的元素，则可以使用 clear() 成员函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">0</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：顺序容器</title>
    <link href="http://yoursite.com/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-04-26T02:35:34.000Z</published>
    <updated>2022-04-26T03:44:28.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h3><p>所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。<a id="more"></a></p><p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p><ul><li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li>vector&lt;T&gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li>deque&lt;T&gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li>list&lt;T&gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li>forward_list&lt;T&gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><blockquote><p>注意，其实除此之外，stack 和 queue 本质上也属于顺序容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。</p></blockquote><p>下图说明了各种顺序容器及它们之间的区别：</p><p><img src="/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/pic1.jpg" alt></p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array 容器是 C++ 11 标准中新增的顺序容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p><p>Array 容器以类模板的形式定义在 &lt;array&gt; 头文件，并位于命名空间 std 中，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>在 array&lt;T,N&gt; 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。</p><p>Array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p><p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>使用该语句，容器中所有的元素都会被初始化为 0.0。</p><p>当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="http://c.biancheng.net/c/80/" target="_blank" rel="noopener">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>另外，在 &lt;array&gt; 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>STL 为 array 容器配备了随机访问迭代器，该类迭代器是功能最强大的迭代器。在 array 容器的模板类中，和随机访问迭代器相关的成员函数如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准新增的 begin() 和 end() 函数，当操作对象为 array 容器时，也和迭代器有关，其功能分别和上表中的 begin()、end() 成员函数相同。</p><h5 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()/end() 和 cbegin()/cend()"></a>begin()/end() 和 cbegin()/cend()</h5><p>array 容器模板类中的 begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p><p>例如，可以在循环中显式地使用迭代器来初始化 values 容器的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样上使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，因为当操作对象为 array 容器时，它们和 begin()/end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>这样，容器中的一段元素可以由迭代器指定，这让我们有了对它们使用算法的可能。</p><blockquote><p>需要注意的是，STL 标准库，不是只有 array 容器，当迭代器指向容器中的一个特定元素时，它们不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，它是指向 array 容器还是指向 vector 容器。</p></blockquote><p>除此之外，array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.cend();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于 *first 为 const 类型，不能用来修改元素</span></span><br><span class="line">    <span class="comment">//*first = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="comment">//可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rbegin-rend-和-crbegin-crend"><a href="#rbegin-rend-和-crbegin-crend" class="headerlink" title="rbegin()/rend() 和 crbegin()/crend()"></a>rbegin()/rend() 和 crbegin()/crend()</h5><p>array 模板类中还提供了 rbegin()/rend() 和 crbegin()/crend() 成员函数，它们每对都可以分别得到指向最一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。</p><blockquote><p>需要注意的是，在使用反向迭代器进行 ++ 或 – 运算时，++ 指的是迭代器向左移动一位，– 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p></blockquote><p>反向迭代器用于以逆序的方式处理元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.rend();</span><br><span class="line">    <span class="comment">//初始化 values 容器为 &#123;5,4,3,2,1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新遍历容器，并输入各个元素</span></span><br><span class="line">    first = values.rbegin();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，不仅完成了容器的初始化，还遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><blockquote><p>在反向迭代器上使用 ++ 递增运算符，会让迭代器用一种和普通正向迭代器移动方向相反的方式移动。</p></blockquote><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/crend() 组合的功能唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><h5 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h5><p>首先，可以通过容器名[]的方式直接访问和使用容器中的元素，这和 C++ 标准数组访问元素的方式相同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.at (<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2.</span>O*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p><blockquote><p>可能有这样一个疑问，即为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>除此之外，array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</n></p><p>下面代码展示了如何使用 get&lt;n&gt; 模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">string</span>, 5&gt; words&#123; <span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Output words[3]</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; // 越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的指针。通过该指针，我们可以获得容器中的各个元素，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *( words.data()+<span class="number">1</span>); <span class="comment">// 输出结果：2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h5><p>我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p><p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has no elements.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has "</span>&lt;&lt; values.<span class="built_in">size</span>()&lt;&lt;<span class="string">"elements.\n"</span>;</span><br></pre></td></tr></table></figure><p>然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p><blockquote><p>array 容器之所以提供 empty() 成员函数的原因，对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p></blockquote><p>除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;顺序容器概述&quot;&gt;&lt;a href=&quot;#顺序容器概述&quot; class=&quot;headerlink&quot; title=&quot;顺序容器概述&quot;&gt;&lt;/a&gt;顺序容器概述&lt;/h3&gt;&lt;p&gt;所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：容器与迭代器</title>
    <link href="http://yoursite.com/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-04-25T05:23:19.000Z</published>
    <updated>2022-04-25T08:46:03.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。<a id="more"></a>STL 提供有 3 类标准容器，分别是顺序容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示：</p><table><thead><tr><th align="left">容器种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">顺序容器</td><td align="center">主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td align="left">排序容器</td><td align="center">包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td></tr><tr><td align="left">哈希容器</td><td align="center">C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是顺序容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p><p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p><p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p><p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p><h4 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h4><p>STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。其中，输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。</p><ul><li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p></li><li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p></li><li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p+=i：使得 p 往后移动 i 个元素。</span><br><span class="line">p-=i：使得 p 往前移动 i 个元素。</span><br><span class="line">p+i：返回 p 后面第 i 个元素的迭代器。</span><br><span class="line">p-i：返回 p 前面第 i 个元素的迭代器。</span><br><span class="line">p[i]：返回 p 后面第 i 个元素的引用。</span><br></pre></td></tr></table></figure><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p></li></ul><p>下表所示，是 C++ 11 标准中不同容器指定使用的迭代器类型。</p><table><thead><tr><th align="left">容器</th><th align="left">对应的迭代器类型</th></tr></thead><tbody><tr><td align="left">array</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">vector</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">deque</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">list</td><td align="left">双向迭代器</td></tr><tr><td align="left">set / multiset</td><td align="left">双向迭代器</td></tr><tr><td align="left">map / multimap</td><td align="left">双向迭代器</td></tr><tr><td align="left">forward_list</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_map / unordered_multimap</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_set / unordered_multiset</td><td align="left">前向迭代器</td></tr><tr><td align="left">stack</td><td align="left">不支持迭代器</td></tr><tr><td align="left">queue</td><td align="left">不支持迭代器</td></tr></tbody></table><p>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h4><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如下表所示。</p><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator  迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator  迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator  迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator  迭代器名;</td></tr></tbody></table><p>值得一提的是，上表中的反向迭代器全称为 “反向迭代器适配器”。</p><p>通过定义以上几种迭代器，就可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</p><p>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p><h4 id="迭代器实例"><a href="#迭代器实例" class="headerlink" title="迭代器实例"></a>迭代器实例</h4><p>以上对迭代器做了很详细的介绍，下面就以 vector 容器为例，实际感受迭代器的用法和功能。通过前面的学习，vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;; <span class="comment">// v被初始化成有10个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个正向迭代器，当然，vector 也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第二种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第三种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第四种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        i += <span class="number">1</span>; <span class="comment">// 随机访问迭代器支持 "+= 整数" 的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第二种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第三种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第四种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>再举一个例子，我们知道，list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法，因为双向迭代器不支持用“&lt;”进行比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>其实在 C++ 中，数组也是容器，数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h3&gt;&lt;p&gt;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="http://yoursite.com/2022/04/25/C-STL/"/>
    <id>http://yoursite.com/2022/04/25/C-STL/</id>
    <published>2022-04-25T04:37:18.000Z</published>
    <updated>2022-04-25T05:18:04.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-STL"><a href="#什么是-STL" class="headerlink" title="什么是 STL"></a>什么是 STL</h3><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 <a id="more"></a></p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 标准库的重要组成部分。如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装。STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等。</p><h3 id="STL-的组成"><a href="#STL-的组成" class="headerlink" title="STL 的组成"></a>STL 的组成</h3><p>通常认为，STL 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的，如表 1 STL 组成结构：</p><table><thead><tr><th align="left">STL的组成</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">容器</td><td align="center">一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td></tr><tr><td align="left">算法</td><td align="center">STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 algorithm 中，少部分位于头文件 numeric 中。</td></tr><tr><td align="left">迭代器</td><td align="center">在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td></tr><tr><td align="left">函数对象</td><td align="center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td></tr><tr><td align="left">适配器</td><td align="center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td></tr><tr><td align="left">内存分配器</td><td align="center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td></tr></tbody></table><p>另外，在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++ 标准中，它们被重新组织为 13 个头文件，分别是：iterator、functional、vector、deque、list、queue、stack、set、map、algorithm、numeric、memory和utility。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是-STL&quot;&gt;&lt;a href=&quot;#什么是-STL&quot; class=&quot;headerlink&quot; title=&quot;什么是 STL&quot;&gt;&lt;/a&gt;什么是 STL&lt;/h3&gt;&lt;p&gt;STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++:引用计数</title>
    <link href="http://yoursite.com/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</id>
    <published>2022-01-11T09:43:43.000Z</published>
    <updated>2022-01-11T11:44:23.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是引用计数"><a href="#什么是引用计数" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h3><p>引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：</p><ul><li><p>简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。</p></li><li><p>节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中<strong>string</strong>类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。<a id="more"></a></p></li></ul><h3 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h3><p>使用引用计数实现智能指针的关键是，引用计数应该存在哪里。引用计数应该是某个类对象和其复制对象共享的， 而指针成员恰好有这样的特性， 故可以在类中多声明一个size_t* 的成员，用来表示引用计数。</p><ul><li>构造函数中创建类的新对象时，初始化引用计数为1；</li><li>拷贝构造函数复制指针，并使相应的引用计数增加1；</li><li>赋值操作减少左操作数所指对象的引用计数，增加右操作数所指对象的引用计数；</li><li>析构函数使引用计数减少1，并且当引用计数为1时，释放指针所指向的对象；</li></ul><p><img src="/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/1.png" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>; <span class="keyword">using</span> <span class="built_in">std</span>::ostream; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// string()：构造空的string类对象，既空字符串</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125; <span class="comment">// constructor</span></span><br><span class="line">~HasPtr(); <span class="comment">// 析构函数</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> HasPtr&amp; rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++* use; &#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;); <span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span>* ps; <span class="comment">// ps是一个指针，指向string类型</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span>* use; <span class="comment">// use是一个指针，指向size_t类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数的定义</span></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 如果引用计数为变0</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 释放string内存</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放计数器内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载的定义</span></span><br><span class="line">HasPtr&amp;</span><br><span class="line">HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">++* rhs.use;<span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 如果没有其他用户</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">&#125;</span><br><span class="line">ps = rhs.ps;<span class="comment">// 将数据从rhs拷贝到本对象</span></span><br><span class="line">i = rhs.i;</span><br><span class="line">use = rhs.use;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的定义</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">os &lt;&lt; p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.use;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HasPtr temp;</span><br><span class="line">temp = p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, p) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"temp: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, temp) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr str1(\"copy me\"), str2;\n"</span>;</span><br><span class="line">HasPtr str1("copy me"), str2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr2 = str1;\n"</span>;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nfunc(str1);\n"</span>;</span><br><span class="line">func(str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HasPtr str1(<span class="string">"copy me"</span>), str2;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">1</span></span><br><span class="line">str2: <span class="number">011654E8</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">str2 = str1;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line"></span><br><span class="line">func(str1);</span><br><span class="line">p: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line">temp: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line"></span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是引用计数&quot;&gt;&lt;a href=&quot;#什么是引用计数&quot; class=&quot;headerlink&quot; title=&quot;什么是引用计数&quot;&gt;&lt;/a&gt;什么是引用计数&lt;/h3&gt;&lt;p&gt;引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中&lt;strong&gt;string&lt;/strong&gt;类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>python+selenium实现自动刷新网页</title>
    <link href="http://yoursite.com/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/</id>
    <published>2022-01-06T09:03:52.000Z</published>
    <updated>2022-04-08T04:59:21.671Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。</strong></p><a id="more"></a><hr><p>一、安装 selenium</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>二、下载并导入浏览器驱动</p><p>1、查看Chrome浏览器版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://version</span><br></pre></td></tr></table></figure><p>2、根据版本下载对应浏览器驱动</p><p>下载网址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>3、将下载的驱动放入python安装目录Scripts文件夹下。</p><p>三、示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    driver.refresh()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>《信》-东野圭吾</title>
    <link href="http://yoursite.com/2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    <id>http://yoursite.com/2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/</id>
    <published>2022-01-04T02:07:59.000Z</published>
    <updated>2022-04-08T03:54:08.580Z</updated>
    
    <content type="html"><![CDATA[<p>看完了东野圭吾的《信》，这不是一部推理题材的小说，只是讲述了一个关于人性的故事。故事围绕“犯罪者的家属该不该受到歧视”展开，主人公的哥哥犯下了盗窃杀人罪，留下他独自一人，没有钱上大学只能去打工，却在被老板知道自己的哥哥是罪犯后遭遇辞退，一次次想隐瞒却又终究暴露，连自己的女朋友也因此分手，好不容易结婚生了孩子，竟连孩子也要饱受歧视。于是，他的心理也在这一件件事中发生改变，甚至扭曲，终于无法忍受，写信告诉自己的哥哥要断绝关系，不再相见……<a id="more"></a></p><p>以前，我只觉得犯罪者的家属因犯罪者而受到歧视似乎有失公允，至少不能一概而论，但大家的做法也无可厚非，因为没有人愿意跟犯罪扯上关系。现在看来，这里面还有一层含义，那就是这些家属所受的歧视其实也是犯罪成本的一部分，以此来警告那些试图犯罪者，犯罪的结果不只牵涉本人，也会给亲人带来麻烦。可是，我又有了一个疑问。犯罪者在犯罪时可能会想到这么多吗？即使像这篇小说中，主人公的哥哥是为了替他凑够上大学的学费才去盗窃，也不是一开始就计划杀人，他也没能想到由此可能带给弟弟的痛苦，更不必说那些穷凶极恶之徒了。所以，这种警告跟欲犯罪者自身素养和对犯罪后果的了解有很大关系，但总的来说，这并不是一件可以讨论谁对谁错的事。</p><p>至于主人公，让我想起了一部电视剧《琅琊榜：风起长林》中的反派人物萧元启。他作为犯罪者的儿子，遭遇了人间冷暖，世态炎凉，本来是一个可怜之人，却最终一步步跌入仇恨的深渊。在他完全黑化前，与长林老王爷的一段对话让我记忆犹新，这也是曾经可能挽救他的良药。</p><blockquote><p>萧元启：境遇冷暖，自然会影响人的性情。性情若是变了，本心会变吗？</p><p>老王爷：如果你觉得这世态炎凉，那是因为你还没有经历过真正的地狱，一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p></blockquote><p>但萧元启终究没能找回他的赤子之心。现实中也是如此，一个人无疑是容易被周遭环境所影响的，特别是在如今的社会，复杂的人际关系，各种各样的诱惑，我们也许在不知不觉中就已经走在背离本心的路上，或是在某些情况下，我们不得不做出违背初心的行为，所以，我们应该时常问问自己是否还坚持着初心，这也许很难，但应该坚守。若是真的做出了违背初心的事，是否就一定会堕入深渊呢？也许会，也许不会。人世间的很多事很难得出对与错的结论，毕竟我们中的大多数都是普通人，我们常常站在道德的制高点趾高气昂，评头论足，却没有深入探究事件本身的勇气与能力。那么，我们究竟应该怎么做呢？还是那句话：一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看完了东野圭吾的《信》，这不是一部推理题材的小说，只是讲述了一个关于人性的故事。故事围绕“犯罪者的家属该不该受到歧视”展开，主人公的哥哥犯下了盗窃杀人罪，留下他独自一人，没有钱上大学只能去打工，却在被老板知道自己的哥哥是罪犯后遭遇辞退，一次次想隐瞒却又终究暴露，连自己的女朋友也因此分手，好不容易结婚生了孩子，竟连孩子也要饱受歧视。于是，他的心理也在这一件件事中发生改变，甚至扭曲，终于无法忍受，写信告诉自己的哥哥要断绝关系，不再相见……&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>文件重定向</title>
    <link href="http://yoursite.com/2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2021-12-26T10:09:20.000Z</published>
    <updated>2021-12-26T10:25:27.922Z</updated>
    
    <content type="html"><![CDATA[<p>当测试程序时，反复从键盘敲入测试数据作为程序的输入，是非常乏味且低效的。<a id="more"></a>大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与文件命名关联起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure><p>假定$是操作系统提示符，程序已经编译为名为addItems.exe的可执行文件（在UNIX操作系统中是addItems），则上述命令会从一个名为infile的文件读取数据，并将结果写入到一个名为outfile的文件中，两个文件都处于当前目录中。</p><p>以在Windows下为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\C++Primer\Debug&gt;<span class="string">"C++Primer.exe"</span> &lt;infile.txt&gt;outfile.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当测试程序时，反复从键盘敲入测试数据作为程序的输入，是非常乏味且低效的。&lt;/p&gt;</summary>
    
    
    
    <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>我的研究生之旅</title>
    <link href="http://yoursite.com/2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/</id>
    <published>2021-12-19T03:33:22.000Z</published>
    <updated>2022-04-08T02:56:40.776Z</updated>
    
    <content type="html"><![CDATA[<p>应该是三月吧，时间记不清了，初试成绩出来的那一刻我觉得应该进不了复试了。<a id="more"></a>又逢家中的一些变故，那时只想离开家，所以我骗家人不想调剂，决定出去找工作，其实我的内心是想调剂的。</p><p>离开家，回到曾经工作的地方一直准备调剂，却又感觉希望渺茫，心想实在调剂不上就继续工作吧。调剂系统出来的第一天，由于没有调剂经验，很快填完了3个名额，填的学校都是比较好的学校，导致填完就没有了下文，最多就是被查看，一直没有复试通知。错过了前期的黄金调剂期，后面调剂越来越难，幸运的是，在最后时刻终于被录取了，虽然是一所很一般的学校。心是有不甘，但这已经是比较好的结局。</p><p>九月入学，第一次来到东北，有些陌生，有些新鲜。很快适应了大学生活，就像我只是放假后又重新回到学校，不过还是有了很多不一样的感受。再一次在秋天凉爽的夜晚漫步在学校的马路操场上，看着熙熙攘攘的学生，踩着滑板，唱着歌，一幅幅青春的模样，一年前的我怎么也不会想到今天的自己又回到了校园，以一个学生的身份。没错，我又回到了校园，没有生活的琐碎，工作的烦恼，只有无忧无虑的学习、生活和娱乐，可以有大量的时间做自己想做的事，我感到无比幸运，因为就连这样的散步都是工作后奢侈的享受。我又走进了图书馆，去阶梯教室上课，去食堂吃饭，睡四人寝……每一件事都是熟悉的样子，恍如昨日，这些曾经离开校园后最美好的回忆，我正在体验着，也更加珍惜，果然人总是在失去后才会懂得拥有的珍贵。</p><p>一学期的学习生活很快结束，考试周的考试也结束了，又松了口气，可以继续做自己想做的事，看自己喜欢的书，马上就可以放假飞到想去的城市见见许久未见的老友。生活很平淡，有时甚至很艰难，可是总有什么是我们期待的，总有什么是值得我们期待的，不知不觉中，我们都在朝着更好的方向努力，明天的生活不知道会怎样，可是我们要珍惜现在的我们和现在的时光。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;应该是三月吧，时间记不清了，初试成绩出来的那一刻我觉得应该进不了复试了。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>追赶法求解线性方程组</title>
    <link href="http://yoursite.com/2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2021-10-12T12:58:49.000Z</published>
    <updated>2022-04-08T04:35:17.308Z</updated>
    
    <content type="html"><![CDATA[<p><strong>利用追赶法求解线性方程组，基于C语言实现。</strong></p><p><strong>追赶法是LU分解法的一种特例，其系数矩阵是一种稀疏矩阵，除主对角线及相邻的两条对角线为非零元素，其余元素值均为0，称为三对角矩阵。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> c[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> d[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>, i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]/b[i<span class="number">-1</span>];</span><br><span class="line">        b[i]=b[i]-c[i<span class="number">-1</span>]*a[i];</span><br><span class="line">        d[i]=d[i]-a[i]*d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    d[n]=d[n]/b[n];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=(d[i]-c[i]*d[i+<span class="number">1</span>])/b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.100000</span></span><br><span class="line"><span class="number">2.200000</span></span><br><span class="line"><span class="number">2.300000</span></span><br><span class="line"><span class="number">2.400000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;利用追赶法求解线性方程组，基于C语言实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;追赶法是LU分解法的一种特例，其系数矩阵是一种稀疏矩阵，除主对角线及相邻的两条对角线为非零元素，其余元素值均为0，称为三对角矩阵。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数值分析" scheme="http://yoursite.com/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="数值分析" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>LU分解法求解线性方程组</title>
    <link href="http://yoursite.com/2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2021-10-11T07:27:13.000Z</published>
    <updated>2022-04-08T04:33:39.223Z</updated>
    
    <content type="html"><![CDATA[<p><strong>利用LU分解法求解线性方程组，基于C++语言实现。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵的ALU分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALU</span><span class="params">(<span class="keyword">double</span> a[n][n], <span class="keyword">double</span> b[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> u[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行U的第一行的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[<span class="number">0</span>][i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行L的第一列的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i][<span class="number">0</span>] = a[i][<span class="number">0</span>] / u[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算U的剩下的行数和L的剩下的列数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 计算U的行</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum1 += l[i][k] * u[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            u[i][j] = a[i][j] - sum1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算L的列</span></span><br><span class="line">        <span class="keyword">if</span>(i!=n)</span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2 += l[j][k] * u[k][i];</span><br><span class="line">&#125;</span><br><span class="line">l[j][i] = (a[j][i] - sum2) / u[i][i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出L和U</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵L为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵U为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求y</span></span><br><span class="line">    <span class="keyword">double</span> y[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    y[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            sum3 += l[i][j] * y[j];</span><br><span class="line">        y[i] = b[i] - sum3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求x</span></span><br><span class="line">    <span class="keyword">double</span> x[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    x[n - <span class="number">1</span>] = y[n - <span class="number">1</span>] / u[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            sum4 += u[i][j] * x[j];</span><br><span class="line">        x[i] = (y[i] - sum4) / u[i][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"该线性方程组的解为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x["</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"]="</span> &lt;&lt; x[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[<span class="number">3</span>] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    ALU(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">矩阵L为：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">-0.333333</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0.333333</span> <span class="number">-0.357143</span> <span class="number">0</span></span><br><span class="line">矩阵U为：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">4.66667</span> <span class="number">4.66667</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">x[<span class="number">1</span>]=<span class="number">0.5</span></span><br><span class="line">x[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">x[<span class="number">3</span>]=<span class="number">0.5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;利用LU分解法求解线性方程组，基于C++语言实现。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数值分析" scheme="http://yoursite.com/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="数值分析" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>高斯消去法求解线性方程组</title>
    <link href="http://yoursite.com/2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://yoursite.com/2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2021-09-28T12:18:11.000Z</published>
    <updated>2022-04-08T04:34:34.809Z</updated>
    
    <content type="html"><![CDATA[<p><strong>利用高斯消去法求解线性方程组，基于C语言实现。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A[MAX][MAX];</span><br><span class="line"><span class="keyword">double</span> b[MAX];</span><br><span class="line"><span class="keyword">double</span> X[MAX];</span><br><span class="line"><span class="keyword">int</span> NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的阶数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;NUM);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的第%d行元素:"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=NUM; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;A[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入右端项b:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的系数矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">float</span> mik;<span class="comment">//消元过程所用变量</span></span><br><span class="line">    <span class="keyword">float</span> S;<span class="comment">//回代过程所用变量</span></span><br><span class="line"></span><br><span class="line">    inputMatrix();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消元</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;NUM<span class="number">-1</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!A[k][k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">1</span>; i&lt;NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mik=A[i][k]/A[k][k];</span><br><span class="line">b[i]=b[i]-mik*b[k];</span><br><span class="line">            <span class="keyword">for</span>(j=k; j&lt;NUM; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j]=A[i][j]-mik*A[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回代</span></span><br><span class="line">    X[NUM<span class="number">-1</span>]=b[NUM<span class="number">-1</span>]/A[NUM<span class="number">-1</span>][NUM<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(k=NUM<span class="number">-2</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        S=b[k];</span><br><span class="line">        <span class="keyword">for</span>(j=k+<span class="number">1</span>; j&lt;NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            S=S-A[k][j]*X[j];</span><br><span class="line">        &#125;</span><br><span class="line">        X[k]=S/A[k][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该线性方程组的解为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"X%d=%lf\n"</span>,i+<span class="number">1</span>,X[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入系数矩阵A的阶数:<span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">1</span>行元素:<span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">输入系数矩阵A的第<span class="number">2</span>行元素:<span class="number">12</span> <span class="number">-3</span> <span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">3</span>行元素:<span class="number">-18</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line">输入右端项b:<span class="number">6</span> <span class="number">15</span> <span class="number">-15</span></span><br><span class="line"></span><br><span class="line">输入的系数矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">12.000000</span> <span class="number">-3.000000</span> <span class="number">3.000000</span></span><br><span class="line"><span class="number">-18.000000</span> <span class="number">3.000000</span> <span class="number">-1.000000</span></span><br><span class="line">输入的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">15.000000</span></span><br><span class="line"><span class="number">-15.000000</span></span><br><span class="line"></span><br><span class="line">消元后的矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">-15.000000</span> <span class="number">-9.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">4.400000</span></span><br><span class="line">消元后的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">-57.000000</span></span><br><span class="line"><span class="number">13.200001</span></span><br><span class="line"></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">X1=<span class="number">1.000000</span></span><br><span class="line">X2=<span class="number">2.000000</span></span><br><span class="line">X3=<span class="number">3.000000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;利用高斯消去法求解线性方程组，基于C语言实现。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数值分析" scheme="http://yoursite.com/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="数值分析" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>void*的用法</title>
    <link href="http://yoursite.com/2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-08-22T09:27:08.000Z</published>
    <updated>2022-04-08T02:40:54.869Z</updated>
    
    <content type="html"><![CDATA[<p><strong>void*是一种特殊的指针类型，可用于存放任意对象的地址。</strong></p><a id="more"></a><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, * pd = &amp;obj;</span><br><span class="line"><span class="keyword">void</span>* pv = pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*pd 的值为："</span> &lt;&lt; *pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "*pv 的值为：" &lt;&lt; *pv &lt;&lt; endl; // 错误，不能直接操作 void* 所指的对象，因为我们并不知道这个对象到底是什么类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pd 的值为：<span class="number">3.14</span></span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;void*是一种特殊的指针类型，可用于存放任意对象的地址。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>海街日记</title>
    <link href="http://yoursite.com/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/</id>
    <published>2021-03-20T04:17:47.000Z</published>
    <updated>2022-04-08T02:30:57.114Z</updated>
    
    <content type="html"><![CDATA[<p>“虽然知道自己马上就要死了，但是依然能感受到美丽的东西是美的，很开心。”</p><p>电影开头铃的父亲和电影结尾二宫女士的去世，告诉我们无尽温柔的人也无法抵挡死亡；海上的烟花会和盛开的樱花，在绽放后转瞬消逝……这些无一不蕴含对美好易逝的感叹。</p><p>但这部电影的主题却不是宣扬悲观，而是在告诉人们，死亡和失去并不可怕，重要的是珍惜身边的人，珍惜现在，好好生活。</p><p><img src="/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“虽然知道自己马上就要死了，但是依然能感受到美丽的东西是美的，很开心。”&lt;/p&gt;
&lt;p&gt;电影开头铃的父亲和电影结尾二宫女士的去世，告诉我们无尽温柔的人也无法抵挡死亡；海上的烟花会和盛开的樱花，在绽放后转瞬消逝……这些无一不蕴含对美好易逝的感叹。&lt;/p&gt;
&lt;p&gt;但这部电影的主</summary>
      
    
    
    
    <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现及应用-改进1</title>
    <link href="http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/"/>
    <id>http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/</id>
    <published>2021-02-23T06:39:32.000Z</published>
    <updated>2021-12-30T05:48:01.624Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <a href="https://crossoverpptx.github.io/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener"><strong>二叉树的实现及应用</strong></a> 的改进，源程序被拆分为四个子程序：Status.h（状态码头文件）、BiTree.h（二叉树数据结构及函数声明头文件）、BiTree.c（函数定义）、BiTree-main.c（主程序）。</p><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Status.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STATUS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OVERFLOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW    -2  <span class="comment">//堆栈上溢</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BITREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树元素类型定义，这里假设其元素类型为char */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树结点定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    TElemType data;             <span class="comment">// 结点元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>;</span>     <span class="comment">// 左孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">rchild</span>;</span>     <span class="comment">// 右孩子指针</span></span><br><span class="line">&#125; BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向二叉树结点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BiTNode* BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************声明部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span>;<span class="comment">//初始化，构造空二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span>;<span class="comment">//若二叉树T为空，则返回TRUE，否则FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span>;<span class="comment">//返回二叉树T的深度</span></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span>;<span class="comment">//返回T的根</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span>;<span class="comment">//按先序输入二叉树中结点的值（一个字符），‘#’字符表示空树</span></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span>;<span class="comment">//对数据元素操作的应用函数</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//先序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//中序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//后序递归遍历二叉树T的递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************函数部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        L = BiTreeDepth(T-&gt;lchild);</span><br><span class="line">        R = BiTreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span>(L &gt; R ? L:R)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span>(!(*T))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\t"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">            <span class="keyword">if</span>(PreOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(PreOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(InOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                <span class="keyword">if</span>(InOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PostOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(PostOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree-main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InitBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始化空二叉树 T。\n"</span>);</span><br><span class="line">        InitBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"CreateBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"按先序序列创建二叉树 T："</span>);</span><br><span class="line">        CreateBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PreOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树 T："</span>);</span><br><span class="line">        PreOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nInOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树 T："</span>);</span><br><span class="line">        InOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nPostOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树 T："</span>);</span><br><span class="line">        PostOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitBiTree</span><br><span class="line">初始化空二叉树 T。</span><br><span class="line">CreateBiTree</span><br><span class="line">按先序序列创建二叉树 T：ABD<span class="comment">###C#F##</span></span><br><span class="line">PreOrderTraverse</span><br><span class="line">前序遍历二叉树 T：A     B       D       C       F</span><br><span class="line">InOrderTraverse</span><br><span class="line">中序遍历二叉树 T：D     B       A       C       F</span><br><span class="line">PostOrderTraverse</span><br><span class="line">后序遍历二叉树 T：D     B       F       C       A</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对 &lt;a href=&quot;https://crossoverpptx.github.io/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;二叉树的实现及应用&lt;/strong&gt;&lt;/a&gt; 的改进，源程序被拆分为四个子程序：Status.h（状态码头文件）、BiTree.h（二叉树数据结构及函数声明头文件）、BiTree.c（函数定义）、BiTree-main.c（主程序）。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现及应用</title>
    <link href="http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-23T05:45:32.000Z</published>
    <updated>2021-02-24T03:49:50.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录二叉树的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>)&#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraversal (T-&gt;lchild);</span><br><span class="line">        PreOrderTraversal (T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InOrderTraversal( T-&gt;lchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        InOrderTraversal( T-&gt;rchild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        PostOrderTraversal( T-&gt;lchild );</span><br><span class="line">        PostOrderTraversal( T-&gt;rchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create  Binary Tree:"</span>);</span><br><span class="line">CreatBiTree(&amp;T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PreOrder:"</span>);</span><br><span class="line">PreOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InOrder:"</span>);</span><br><span class="line">InOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PostOrder:"</span>);</span><br><span class="line">PostOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Create  Binary Tree:ABD<span class="comment">###C#F##</span></span><br><span class="line"></span><br><span class="line">PreOrder:ABDCF</span><br><span class="line"></span><br><span class="line">InOrder:DBACF</span><br><span class="line"></span><br><span class="line">PostOrder:DBFCA</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录二叉树的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>顺序串的实现及应用</title>
    <link href="http://yoursite.com/2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-18T10:42:14.000Z</published>
    <updated>2021-02-24T04:17:58.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录顺序串的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SString.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 10                                 <span class="comment">// 顺序串的最大串长</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串的顺序存储类型定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN + <span class="number">1</span>];         <span class="comment">// 0号单元存放串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span></span>;       <span class="comment">//构造一个值为chars的串T</span></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span></span>;  <span class="comment">//用T返回由S1和S2联结而成的新串。若未截断，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span></span>;                      <span class="comment">// 测试函数，打印字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, len;</span><br><span class="line">    </span><br><span class="line">    len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(chars);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// chars过长</span></span><br><span class="line">    <span class="keyword">if</span>(len &gt; MAXSTRLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T[<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        T[i] = chars[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> uncut;  <span class="comment">// 新串是否完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完全不需要裁剪</span></span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>] + S2[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制S2到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>] + S2[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 未裁剪，完整</span></span><br><span class="line">        uncut = TRUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要裁剪S2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(S1[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将S2的一部分复制到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只需要复制S1的一部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连同长度信息一起复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> uncut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"████████ Concat \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        SString Tmp1, Tmp2, Tmp3, Tmp4, S1, S2, S3, S4, S5, S6, S7, S8;</span><br><span class="line">        </span><br><span class="line">        StrAssign(S1, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S2, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S1和S2形成 Tmp1 ...\n"</span>);</span><br><span class="line">        Concat(Tmp1, S1, S2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp1 = "</span>);</span><br><span class="line">        PrintElem(Tmp1);</span><br><span class="line"></span><br><span class="line">StrAssign(S3, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S4, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S3和S4形成 Tmp2 ...\n"</span>);</span><br><span class="line">        Concat(Tmp2, S3, S4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp2 = "</span>);</span><br><span class="line">        PrintElem(Tmp2);</span><br><span class="line"></span><br><span class="line">StrAssign(S5, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S6, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S5和S6形成 Tmp3 ...\n"</span>);</span><br><span class="line">        Concat(Tmp3, S5, S6);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp3 = "</span>);</span><br><span class="line">        PrintElem(Tmp3);</span><br><span class="line"></span><br><span class="line">StrAssign(S7, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S8, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S7和S8形成 Tmp4 ...\n"</span>);</span><br><span class="line">        Concat(Tmp4, S7, S8);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp4 = "</span>);</span><br><span class="line">        PrintElem(Tmp4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">████████ Concat</span><br><span class="line">█ 联接S1和S2形成 Tmp1 ...</span><br><span class="line">█ Tmp1 = +++++-----</span><br><span class="line">█ 联接S3和S4形成 Tmp2 ...</span><br><span class="line">█ Tmp2 = +++++++---</span><br><span class="line">█ 联接S5和S6形成 Tmp3 ...</span><br><span class="line">█ Tmp3 = +++++-----</span><br><span class="line">█ 联接S7和S8形成 Tmp4 ...</span><br><span class="line">█ Tmp4 = +++++++---</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录顺序串的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈的实现及应用</title>
    <link href="http://yoursite.com/2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-10T09:32:28.000Z</published>
    <updated>2021-02-24T04:18:29.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录顺序栈的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">SElemType *base;</span><br><span class="line">SElemType *top;</span><br><span class="line"><span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空栈S</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">S.top=S.base;</span><br><span class="line">S.stacksize=STACK_INIT_SIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈S，栈S不再存在</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(S.base);</span><br><span class="line">S.base=<span class="literal">NULL</span>;</span><br><span class="line">S.top=<span class="literal">NULL</span>;</span><br><span class="line">S.stacksize=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈S置为空栈</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.top=S.base;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈S为空栈，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈S的元素个数，即栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S.top-S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈不空，则用e返回S的栈顶元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top&gt;S.base)</span><br><span class="line">&#123;</span><br><span class="line">e=*(S.top<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈：插入元素e作为新的栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)</span><br><span class="line">&#123;</span><br><span class="line">S.base=(SElemType *)<span class="built_in">realloc</span>(S.base,</span><br><span class="line">(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">S.top=S.base+S.stacksize;</span><br><span class="line">S.stacksize+=STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++=e;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈：若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">e=*--S.top;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.1：10进制转化为8进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conversion_3_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack s;</span><br><span class="line"><span class="keyword">unsigned</span> n;</span><br><span class="line">SElemType e;</span><br><span class="line"></span><br><span class="line">InitStack(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入一个非负10进制整数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">Push(s,n%<span class="number">8</span>);</span><br><span class="line">n/=<span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"与其等值的8进制数为："</span>);</span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(s))</span><br><span class="line">&#123;</span><br><span class="line">Pop(s,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.2：括号匹配</span></span><br><span class="line"><span class="function">Status <span class="title">Conversion_3_2</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack s;</span><br><span class="line">SElemType e;</span><br><span class="line"></span><br><span class="line">InitStack(s);</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p=str;*p;++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">'('</span> || *p==<span class="string">'['</span> || *p==<span class="string">'&#123;'</span>)</span><br><span class="line">Push(s,*p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">')'</span> || *p==<span class="string">']'</span> || *p==<span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(s))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Pop(s,e);</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">')'</span> &amp;&amp; e!=<span class="string">'('</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">']'</span> &amp;&amp; e!=<span class="string">'['</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">'&#125;'</span> &amp;&amp; e!=<span class="string">'&#123;'</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!StackEmpty(s))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"算法3.1：\n"</span>);</span><br><span class="line">Conversion_3_1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"算法3.2：\n"</span>);</span><br><span class="line"><span class="keyword">char</span> str[]=<span class="string">"(((1+b)-(a+3)))&#123;12[&#125;[]*4@]"</span>;</span><br><span class="line"><span class="keyword">if</span>(Conversion_3_2(str))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"括号匹配！\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"括号不匹配！\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法<span class="number">3.1</span>：</span><br><span class="line">输入一个非负<span class="number">10</span>进制整数：<span class="number">1348</span></span><br><span class="line">与其等值的<span class="number">8</span>进制数为：<span class="number">2504</span></span><br><span class="line">算法<span class="number">3.2</span>：</span><br><span class="line">括号不匹配！</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录顺序栈的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现，其中应用了少数C++特性，比如引用等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链队列的实现及应用</title>
    <link href="http://yoursite.com/2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-10T03:59:41.000Z</published>
    <updated>2021-02-24T04:09:46.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录单链队列（队列的链式存储结构）的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q.front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Q.front)</span><br><span class="line">&#123;</span><br><span class="line">Q.rear=Q.front-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(Q.front);</span><br><span class="line">Q.front=Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Q清为空队列</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">q=p;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列Q为空队列，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Q的元素个数，即队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line"><span class="keyword">while</span>(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则用e返回Q的队头元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e作为新的队尾元素</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next=p;</span><br><span class="line">Q.rear=p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">Q.rear=Q.front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit失败，则操作失败</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q,<span class="keyword">void</span> (*visit)(QElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(QElemType i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">QElemType d;</span><br><span class="line">LinkQueue q;</span><br><span class="line">i=InitQueue(q);</span><br><span class="line"><span class="keyword">if</span>(i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"成功地构造了一个空队列！\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"初始化队列后，队列空否？%d(1：空 0：否)，"</span>,QueueEmpty(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line">EnQueue(q,<span class="number">-5</span>);</span><br><span class="line">EnQueue(q,<span class="number">5</span>);</span><br><span class="line">EnQueue(q,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入3个元素（-5,5,10）后，队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在队列空否？%d(1：空 0：否)\n"</span>,QueueEmpty(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在队列中的元素为："</span>);</span><br><span class="line">QueueTraverse(q,visit);</span><br><span class="line">i=GetHead(q,d);</span><br><span class="line"><span class="keyword">if</span>(i==OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队头元素为：%d\n"</span>,d);</span><br><span class="line">DeQueue(q,d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除了队头元素：%d\n"</span>,d);</span><br><span class="line">i=GetHead(q,d);</span><br><span class="line"><span class="keyword">if</span>(i==OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"新的队头元素为：%d\n"</span>,d);</span><br><span class="line">ClearQueue(q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"清空队列后，q.front=%u q.rear=%u q.front-&gt;next=%u\n"</span>,q.front,q.rear,q.front-&gt;next);</span><br><span class="line">DestroyQueue(q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"销毁队列后，q.front=%u q.rear=%u\n"</span>,q.front,q.rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">成功地构造了一个空队列！</span><br><span class="line">初始化队列后，队列空否？<span class="number">1</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)，队列长度为：<span class="number">0</span></span><br><span class="line">插入<span class="number">3</span>个元素（<span class="number">-5</span>,<span class="number">5</span>,<span class="number">10</span>）后，队列长度为：<span class="number">3</span></span><br><span class="line">现在队列空否？<span class="number">0</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)</span><br><span class="line">现在队列中的元素为：<span class="number">-5</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line">队头元素为：<span class="number">-5</span></span><br><span class="line">删除了队头元素：<span class="number">-5</span></span><br><span class="line">新的队头元素为：<span class="number">5</span></span><br><span class="line">清空队列后，q.front=10555928 q.rear=10555928 q.front-&gt;next=0</span><br><span class="line">销毁队列后，q.front=<span class="number">0</span> q.rear=<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录单链队列（队列的链式存储结构）的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现，其中应用了少数C++特性，比如引用等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>论持久战</title>
    <link href="http://yoursite.com/2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/"/>
    <id>http://yoursite.com/2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/</id>
    <published>2021-01-16T04:41:35.000Z</published>
    <updated>2021-02-24T04:21:46.913Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193805b.htm" target="_blank" rel="noopener"><strong>在线阅读网址一</strong></a><br><a href="http://chinatide.net/xiachao/3-2.html" target="_blank" rel="noopener"><strong>在线阅读网址二</strong></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193805b.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;在线阅读网址一&lt;/</summary>
      
    
    
    
    <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
