<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverpptx&#39;s Blog</title>
  
  <subtitle>黑夜给了我黑色的眼睛，我却用它寻找光明</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-09-16T03:58:10.667Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crossoverpptx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11：智能指针</title>
    <link href="http://yoursite.com/2022/09/16/C-11%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/09/16/C-11%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-09-16T02:25:22.000Z</published>
    <updated>2022-09-16T03:58:10.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是智能指针"><a href="#一、什么是智能指针" class="headerlink" title="一、什么是智能指针"></a>一、什么是智能指针</h1><p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<a id="more"></a>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。随着C++的发展，有三个解决方案，一个方案对应着一种智能指针。</p><ul><li>将指针的管理权转移给另外一个对象。对应C++98的auto_ptr。</li><li>防止拷贝。对应C++11的unique_ptr。</li><li>引用计数。对应C++11的shared_ptr。</li></ul><p>其实，C++一共提供了四种智能指针：auto_ptr， unique_ptr，shared_ptr，weak_ptr。其中后三个是C++11新增的，第一个由C++98提出，已经被C++11弃用。智能指针都包含在memory库中，要使用智能指针必须包含这个库。</p><h1 id="二、auto-ptr"><a href="#二、auto-ptr" class="headerlink" title="二、auto_ptr"></a>二、auto_ptr</h1><p>  auto_ptr的原理是：将资源的管理权由一个对象转移给另外一个对象。但auto_ptr存在下面一些问题：</p><h2 id="1、auto-ptr不能共享所有权"><a href="#1、auto-ptr不能共享所有权" class="headerlink" title="1、auto_ptr不能共享所有权"></a>1、auto_ptr不能共享所有权</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p3;</span><br><span class="line">p3 = p1; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><p>这样会导致p1，p2，p3同时指向p1内部的原始指针，由于每一个auto_ptr在被销毁的时候都会删除其所指向的对象，原始指针就会被重复删除3次，为了解决这个问题，要么禁用拷贝与赋值运算符，要么设计当auto_ptr拷贝或者赋值的时候对原始指针的所有权转移到新对象去。</p><h2 id="2、auto-ptr不能指向数组"><a href="#2、auto-ptr不能指向数组" class="headerlink" title="2、auto_ptr不能指向数组"></a>2、auto_ptr不能指向数组</h2><h2 id="3、auto-ptr不能作为容器成员"><a href="#3、auto-ptr不能作为容器成员" class="headerlink" title="3、auto_ptr不能作为容器成员"></a>3、auto_ptr不能作为容器成员</h2><h2 id="4、auto-ptr不能通过赋值操作来初始化"><a href="#4、auto-ptr不能通过赋值操作来初始化" class="headerlink" title="4、auto_ptr不能通过赋值操作来初始化"></a>4、auto_ptr不能通过赋值操作来初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>) <span class="comment">// 错</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)) <span class="comment">// 对</span></span><br></pre></td></tr></table></figure><h1 id="三、unique-ptr"><a href="#三、unique-ptr" class="headerlink" title="三、unique_ptr"></a>三、unique_ptr</h1><p>unique_ptr可以看成是auto_ptr的替代品，用法如下：</p><h2 id="1、不支持拷贝构造和赋值运算函数"><a href="#1、不支持拷贝构造和赋值运算函数" class="headerlink" title="1、不支持拷贝构造和赋值运算函数"></a>1、不支持拷贝构造和赋值运算函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> Obj)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span> <span class="title">one</span><span class="params">(ap)</span></span>; <span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">unique_ptr</span> two= one; <span class="comment">// 会出错</span></span><br></pre></td></tr></table></figure><h2 id="2、可以移动构造和移动赋值操作"><a href="#2、可以移动构造和移动赋值操作" class="headerlink" title="2、可以移动构造和移动赋值操作"></a>2、可以移动构造和移动赋值操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">Getobj</span><span class="params">()</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Obj)</span></span>;</span><br><span class="line">     <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">unique&lt;Obj&gt; ptr = Getobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Obj())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(ptr1))</span></span>;</span><br></pre></td></tr></table></figure><h1 id="四、shared-ptr"><a href="#四、shared-ptr" class="headerlink" title="四、shared_ptr"></a>四、shared_ptr</h1><p>如果程序要使用多个指向同一个对象的指针，那么可以使用shared_ptr。基本使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> &lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">5</span>));</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pint = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr&lt;int&gt;p3 = pint; //error</span></span><br><span class="line"><span class="comment">//p3 = pint; //error</span></span><br><span class="line"></span><br><span class="line">use_count() <span class="comment">//计数数量</span></span><br><span class="line"></span><br><span class="line">unique() <span class="comment">//是否只被一个使用</span></span><br></pre></td></tr></table></figure><h1 id="五、weak-ptr"><a href="#五、weak-ptr" class="headerlink" title="五、weak_ptr"></a>五、weak_ptr</h1><p>shared_ptr是一种强引用关系，智能指针直接引用对象，代码会引起循环引用，从而造成内存泄漏。</p><p>weak_ptr用于配合shared_ptr使用并不影响对象的生命周期，即存在与否并不影响对象的引用计数器，weak_ptr并没有重载operator-&gt; 和operator* 操作符，因此不可直接通过weak_ptr使用对象。提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象shared_ptr智能指针（对象销毁时，返回空shared_ptr）。</p><p>weak_ptr被设计为shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源观测权，但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>使用weak_ptr的use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价use_count()==0但更快，表示被观测资源（也就是shared_ptr管理的资源）已经不复存在。</p><p>weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源，但当expired==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi2</span><span class="params">(spi1)</span></span>;</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp1 = spi1; <span class="comment">//观察spi1，不增加引用计数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp1.use_count()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//观察，不能使用 *、-&gt;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp1.expired() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//观察，不能使用 *、-&gt;</span></span><br><span class="line"><span class="keyword">auto</span> spi1 = wp1.lock();</span><br><span class="line"><span class="keyword">if</span>(spi) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*spi&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、什么是智能指针&quot;&gt;&lt;a href=&quot;#一、什么是智能指针&quot; class=&quot;headerlink&quot; title=&quot;一、什么是智能指针&quot;&gt;&lt;/a&gt;一、什么是智能指针&lt;/h1&gt;&lt;p&gt;在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换</title>
    <link href="http://yoursite.com/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</id>
    <published>2022-08-16T06:29:31.000Z</published>
    <updated>2022-08-16T08:52:52.892Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机视觉中，有一个经典的变换被广泛使用——傅里叶变换。傅里叶变换是将时间域上的信号转变为频率域上的信号，进而进行图像去噪、图像增强等处理。</p><a id="more"></a><h1 id="时域与频域"><a href="#时域与频域" class="headerlink" title="时域与频域"></a>时域与频域</h1><p>什么是时域（Time domain）？从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。</p><p>什么是频域（Frequency domain）？频域是描述信号在频率方面特性时用到的一种坐标系。用线性代数的语言就是装着正弦函数的空间。频域最重要的性质是：它不是真实的，而是一个数学构造。频域是一个遵循特定规则的数学范畴。正弦波是频域中唯一存在的波形，这是频域中最重要的规则，即正弦波是对频域的描述，因为时域中的任何波形都可用正弦波合成。</p><p>对于一个信号来说，信号强度随时间的变化规律就是时域特性，信号是由哪些单一频率的信号合成的就是频域特性。</p><p>时域分析与频域分析是对信号的两个观察面。时域分析是以时间轴为坐标表示动态信号的关系；频域分析是把信号变为以频率轴为坐标表示出来。一般来说，时域的表示较为形象与直观，频域分析则更为简练，剖析问题更为深刻和方便。目前，信号分析的趋势是从时域向频域发展。然而，它们是互相联系，缺一不可，相辅相成的。贯穿时域与频域的方法之一，就是传说中的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)。</p><h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><p>傅里叶级数是一种对周期信号进行分解的方式。</p><p>如下图所示，左上角为正弦方波，余下为通过不同的正弦谐波数可以去拟合这个方波结果。</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A201.jpg" alt></p><p>可以看到，叠加的谐波信号越多时，越接近于方波信号。</p><p>傅里叶级数由法国数学家傅里叶提出，即满足条件（狄利克雷条件）的任何周期函数可以由一系列不同频率的正弦（余弦）函数叠加而成。这种相加形式又称为级数，所以也称为傅里叶级数。</p><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><p>那么对信号的不同频率进行分解有什么好处呢？</p><p>如下图所示，从时域上看，最下方叠加得到的信号是很难分析出里面蕴含的频率信息的。</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A202.jpg" alt></p><p>而通过傅里叶分解后，如下图右图所示，可以很容易地观察到频率的有无和幅度的大小（相位也有对应的相位谱，这里没有列出）。</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A203.jpg" alt></p><p>因此，通过傅里叶变换将某一信号分解为不同频率的信号，可以很容易地对信号中的某一段频段进行观察和操作。</p><h2 id="傅里叶变换分类"><a href="#傅里叶变换分类" class="headerlink" title="傅里叶变换分类"></a>傅里叶变换分类</h2><p>根据原信号的不同类型，我们可以把傅立叶变换分为四种类别：</p><ul><li>非周期性连续信号（傅立叶变换（Fourier Transform））</li><li>周期性连续信号（傅立叶级数(Fourier Series)）</li><li>非周期性离散信号（离散时域傅立叶变换（Discrete Time Fourier Transform））</li><li>周期性离散信号（离散傅立叶变换(Discrete Fourier Transform)）</li></ul><p>这四种傅立叶变换都是针对正无穷大和负无穷大的信号，即信号的的长度是无穷大的，我们知道这对于计算机处理来说是不可能的，那么有没有针对长度有限的傅立叶变换呢？没有。因为正余弦波被定义成从负无穷小到正无穷大，我们无法把一个长度无限的信号组合成长度有限的信号。</p><p>面对这种困难，方法是把长度有限的信号表示成长度无限的信号，可以把信号无限地从左右进行延伸，延伸的部分用零来表示，这样，这个信号就可以被看成是非周期性离散信号，我们就可以用到离散时域傅立叶变换的方法。还有，也可以把信号用复制的方法进行延伸，这样信号就变成了周期性离散信号，这时我们就可以用离散傅立叶变换方法进行变换。</p><p>但是对于非周期性的信号，我们需要用无穷多不同频率的正弦曲线来表示，这对于计算机来说是不可能实现的，因为在计算机中只有离散的和有限长度的数据才能被处理。所以对于离散信号的变换只有离散傅立叶变换（DFT）才能被适用，对于其它的变换类型只有在数学演算中才能用到，在计算机中我们只能用DFT方法。</p><h2 id="一维傅里叶公式"><a href="#一维傅里叶公式" class="headerlink" title="一维傅里叶公式"></a>一维傅里叶公式</h2><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A204.jpg" alt></p><p>其中，ω 表示频率, t 表示时间, 它将频率域的函数表示为时间域函数 f(t) 的积分。</p><h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>我们知道，灰度图像是由二维的离散的点构成的。二维离散傅里叶变换（Two-Dimensional Discrete Fourier Transform）常用于图像处理中，对图像进行傅里叶变换后得到其频谱图。频谱图中频率高低表征图像中灰度变化的剧烈程度。图像中边缘和噪声往往是高频信号，而图像背景往往是低频信号。我们在频率域内可以很方便地对图像的高频或低频信息进行操作，完成图像去噪，图像增强，图像边缘提取等操作。</p><p>对二维图像进行傅里叶变换公式如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A205.jpg" alt></p><p>其中，图像长 M，高 N。F(u,v)表示频域图像，f(x,y)表示时域图像。u 的范围为[0,M-1]，v 的范围为[0,N-1]。</p><p> 对二维图像进行傅里叶逆变换公式如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A206.jpg" alt></p><p>其中，图像长 M，高 N。f(x,y)表示时域图像，F(u,v)表示频域图像。x 的范围为[0,M-1]，y 的范围为[0,N-1]。</p><h1 id="OpenCV中傅里叶变换的应用"><a href="#OpenCV中傅里叶变换的应用" class="headerlink" title="OpenCV中傅里叶变换的应用"></a>OpenCV中傅里叶变换的应用</h1><h2 id="傅里叶变换-1"><a href="#傅里叶变换-1" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将频谱低频从左上角移动至中心位置</span></span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 频谱图像双通道复数转换为0-255区间</span></span><br><span class="line">result = <span class="number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Original Image'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(result, cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Magnitude Spectrum'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A207.jpg" alt></p><h2 id="傅里叶逆变换"><a href="#傅里叶逆变换" class="headerlink" title="傅里叶逆变换"></a>傅里叶逆变换</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dftshift = np.fft.fftshift(dft)</span><br><span class="line">res1= <span class="number">20</span>*np.log(cv2.magnitude(dftshift[:,:,<span class="number">0</span>], dftshift[:,:,<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶逆变换</span></span><br><span class="line">ishift = np.fft.ifftshift(dftshift)</span><br><span class="line">iimg = cv2.idft(ishift)</span><br><span class="line">res2 = cv2.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">131</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'Original Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>), plt.imshow(res1, <span class="string">'gray'</span>), plt.title(<span class="string">'Fourier Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>), plt.imshow(res2, <span class="string">'gray'</span>), plt.title(<span class="string">'Inverse Fourier Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A208.jpg" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机视觉中，有一个经典的变换被广泛使用——傅里叶变换。傅里叶变换是将时间域上的信号转变为频率域上的信号，进而进行图像去噪、图像增强等处理。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>C++11：右值引用</title>
    <link href="http://yoursite.com/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2022-06-23T10:40:22.000Z</published>
    <updated>2022-06-23T11:06:02.264Z</updated>
    
    <content type="html"><![CDATA[<p>右值引用是一种新的 C++ 语法，基于右值引用引申出了 2 种 C++ 编程技巧，分别为移动语义和完美转发。本文主要介绍什么是右值引用以及它的基本用法。</p><a id="more"></a><h3 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h3><p>右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p><blockquote><p>左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p></blockquote><p>通常情况下，判断某个表达式是左值还是右值，有以下 2 种方法：</p><p>1) 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">// 错误，5 不能为左值</span></span><br></pre></td></tr></table></figure><p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。C++ 中的左值也可以当做右值使用，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure><p>2) 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p><p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p><blockquote><p>注意，以上 2 种判定方法只适用于大部分场景。</p></blockquote><h3 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h3><p>前面提到，其实 C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p><p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p><p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  // 右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// a = 100</span></span><br></pre></td></tr></table></figure><p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; a = <span class="number">10</span>; <span class="comment">// 编译器不会报错</span></span><br></pre></td></tr></table></figure><p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p><p>下图给出 C++ 左值引用和右值引用的可以引用的值类型和使用场景：</p><p><img src="/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8.jpg" alt></p><p>表中，Y 表示支持，N 表示不支持。</p><blockquote><p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值，而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。当然对于纯右值和将亡值，都属于右值。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;右值引用是一种新的 C++ 语法，基于右值引用引申出了 2 种 C++ 编程技巧，分别为移动语义和完美转发。本文主要介绍什么是右值引用以及它的基本用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：使用using定义别名</title>
    <link href="http://yoursite.com/2022/06/06/C-11%EF%BC%9A%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D/"/>
    <id>http://yoursite.com/2022/06/06/C-11%EF%BC%9A%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D/</id>
    <published>2022-06-06T01:45:14.000Z</published>
    <updated>2022-06-06T02:06:15.615Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++11 中使用 using 定义别名的用法。<a id="more"></a></p><h3 id="using简介"><a href="#using简介" class="headerlink" title="using简介"></a>using简介</h3><p>大家都知道，在 C++ 中可以通过 typedef 重定义一个类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure><p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">uint_t</span>)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure><p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。想象下面这个场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="keyword">map_str_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p><p>因此，在 C++98/03 中往往不得不这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="keyword">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p><p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">str_map_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">str_map_t</span>&lt;<span class="keyword">int</span>&gt; map1;</span><br></pre></td></tr></table></figure><p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p><h3 id="using应用"><a href="#using应用" class="headerlink" title="using应用"></a>using应用</h3><h4 id="重定义普通类型"><a href="#重定义普通类型" class="headerlink" title="重定义普通类型"></a>重定义普通类型</h4><p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">map_int_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;;</span><br></pre></td></tr></table></figure><p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p><h4 id="重定义函数指针"><a href="#重定义函数指针" class="headerlink" title="重定义函数指针"></a>重定义函数指针</h4><p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p><h4 id="重定义模板"><a href="#重定义模板" class="headerlink" title="重定义模板"></a>重定义模板</h4><p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt;::type xx_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="keyword">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure><p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。</p><p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t&lt;int&gt; 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</p><p>因此，下面这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span> (*func_call)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; func_call)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure><p>同样是无法实现重载的，func_t&lt;int&gt; 只是 void(*)(int, int) 类型的等价物。</p><p>可以发现，using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p><p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">type_t</span> = T;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">type_t</span>&lt;<span class="keyword">int</span>&gt; i;</span><br></pre></td></tr></table></figure><p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t&lt;int&gt; 将等价于 int。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++11 中使用 using 定义别名的用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：decltype类型推导</title>
    <link href="http://yoursite.com/2022/05/25/C-11%EF%BC%9Adecltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <id>http://yoursite.com/2022/05/25/C-11%EF%BC%9Adecltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</id>
    <published>2022-05-25T14:26:28.000Z</published>
    <updated>2022-05-25T14:41:22.807Z</updated>
    
    <content type="html"><![CDATA[<p>decltype 是 C++ 11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。<a id="more"></a></p><p>decltype 是 “declare type” 的缩写，译为“声明类型”。既然已经有了 auto 关键字，为什么还需要 decltype 关键字呢？这是因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p><p>auto 和 decltype 关键字虽然都可以自动推导出变量的类型，但它们的用法是有区别的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">exp</span>) varname = value;</span><br></pre></td></tr></table></figure><p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。auto 根据<code>=</code>右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</p><p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。因此 decltype 可以写成下面的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">exp</span>) varname;</span><br></pre></td></tr></table></figure><h3 id="exp-注意事项"><a href="#exp-注意事项" class="headerlink" title="exp 注意事项"></a>exp 注意事项</h3><p>原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</p><p>C++ decltype 用法举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">// b 被推导成了 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">// x 被推导成了 double</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">// y 被推导成了 double</span></span><br></pre></td></tr></table></figure><p>可以看到，decltype 能够根据变量、字面量、带有运算符的表达式推导出变量的类型。</p><h3 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h3><p>上面的例子让我们初步感受了一下 decltype 的用法，但不要认为 decltype 就这么简单，它的玩法实际上可以非常复杂。当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</p><ul><li>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li><li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li><li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li></ul><p>为了更好地理解 decltype 的推导规则，我们来看几个实际的例子。</p><p>【实例1】exp 是一个普通表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">// n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">// r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">// total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">"https://www.baidu.com"</span>;  <span class="comment">// total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，按照推导规则 1，对于一般的表达式，decltype 的推导结果就和这个表达式的类型一致。</p><p>【实例2】exp 为函数调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;  <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">(<span class="keyword">double</span>)</span></span>;  <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">// decltype类型推导</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(func_int_r(<span class="number">100</span>, <span class="string">'A'</span>)) a = n;  <span class="comment">// a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(func_int_rr()) b = <span class="number">0</span>;  <span class="comment">// b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(func_int(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">// c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(fun_cint_r(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">// x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(func_cint_rr()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。</p><p>【实例3】exp 是左值，或者被<code>( )</code>包围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Base obj;</span><br><span class="line">    <span class="comment">// 带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">// obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">// obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;</span></span><br><span class="line">    <span class="comment">// 加法表达式</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">// n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">// n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要重点说一下左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</p><h3 id="decltype-实际应用"><a href="#decltype-实际应用" class="headerlink" title="decltype 实际应用"></a>decltype 实际应用</h3><p>我们知道，auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">// 注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.func(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p><p>要想解决这个问题，在之前的 C++98/03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(T().<span class="built_in">begin</span>()) m_it;  <span class="comment">// 注意这里</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来是不是很清爽？但是需要注意，有些低版本的编译器不支持<code>T().begin()</code>这种写法，以上代码在 VS2019 下测试通过，在 VS2015 下测试失败。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;decltype 是 C++ 11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：auto类型推导</title>
    <link href="http://yoursite.com/2022/05/21/C-11%EF%BC%9Aauto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <id>http://yoursite.com/2022/05/21/C-11%EF%BC%9Aauto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</id>
    <published>2022-05-21T13:20:52.000Z</published>
    <updated>2022-05-21T13:52:27.017Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++11 之前的版本（C++98 和 C++ 03）中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 C#、JavaScript、PHP、Python 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便。C++11 为了顺应这种趋势也开始支持该语法，使用 auto 关键字来支持自动类型推导。<a id="more"></a></p><h3 id="语法和规则"><a href="#语法和规则" class="headerlink" title="语法和规则"></a>语法和规则</h3><p>在之前的 C++ 版本中，auto 关键字用来指明变量的存储类型，它和 static 关键字是相对的。auto 表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，一般我们也不写，这使得 auto 关键字的存在变得非常鸡肋。C++11 赋予 auto 关键字新的含义，使用它来做自动类型推导。也就是说，使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，这样我们就不用手动指明变量的数据类型了。</p><p>auto 关键字基本的使用语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = value;<span class="comment">// name 是变量的名字，value 是变量的初始值。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p></blockquote><p>auto 类型推导的简单例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="number">12.8</span>;</span><br><span class="line"><span class="keyword">auto</span> p = &amp;n;</span><br><span class="line"><span class="keyword">auto</span> url = <span class="string">"http://c.biancheng.net/cplus/"</span>;</span><br></pre></td></tr></table></figure><p>下面我们来解释一下：</p><ul><li>第 1 行中，10 是一个整数，默认是 int 类型，所以推导出变量 n 的类型是 int。</li><li>第 2 行中，12.8 是一个小数，默认是 double 类型，所以推导出变量 f 的类型是 double。</li><li>第 3 行中，&amp;n 的结果是一个 int* 类型的指针，所以推导出变量 p 的类型是 int*。</li><li>第 4 行中，由双引号<code>&quot;&quot;</code>包围起来的字符串是 const char* 类型，所以推导出变量 url 的类型是 const char*，也即一个常量指针。</li></ul><p>我们也可以连续定义多个变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> *p = &amp;n, m = <span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>先看前面的第一个子表达式，&amp;n 的类型是 int*，编译器会根据 auto *p 推导出 auto 为 int；后面的 m 变量自然也为 int 类型，所以把 99 赋值给它也是正确的。</p><p>这里我们要注意，推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作<code>m=12.5</code>就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。</p><p>还有一个值得注意的地方是：使用 auto 类型推导的变量必须马上初始化，这个很容易理解，因为 auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明。</p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>1) auto 除了可以独立使用，还可以和某些具体类型混合使用，这样 auto 表示的就是“半个”类型，而不是完整的类型。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">// p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span>  p2 = &amp;x;   <span class="comment">// p2 为 int*，auto 推导为 int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1  = x;   <span class="comment">// r1 为 int&amp;，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;    <span class="comment">// r2 为 int，auto 推导为 int</span></span><br></pre></td></tr></table></figure><p>下面我们来解释一下：</p><ul><li>第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。</li><li>第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</li><li>第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</li><li>第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当<code>=</code>右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</li></ul><p>2) 接下来，我们再来看一下 auto 和 const 的结合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n = x;  <span class="comment">// n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;        <span class="comment">// f 为 const int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">// r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;     <span class="comment">// r1 为 const int&amp; 类型，auto 被推导为 const int 类型</span></span><br></pre></td></tr></table></figure><p>下面我们来解释一下：</p><ul><li>第 2 行代码中，n 为 const int，auto 被推导为 int。</li><li>第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当<code>=</code>右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。</li><li>第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</li><li>第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。</li></ul><p>最后我们来简单总结一下 auto 与 const 结合的用法：</p><ul><li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li><li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li></ul><h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h3><p>前面介绍推导规则的时候我们说过，使用 auto 的时候必须对变量进行初始化，这是 auto 的限制之一。那么，除此以外，auto 还有哪些其它的限制呢？</p><p>1) auto 不能在函数的参数中使用。</p><p>这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。</p><p>2) auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。</p><p>3) auto 关键字不能定义数组，比如下面的例子就是错误的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> url[] = <span class="string">"www.baidu.com"</span>;</span><br><span class="line"><span class="keyword">auto</span> str[] = url; <span class="comment">// str 为数组，所以不能使用 auto</span></span><br></pre></td></tr></table></figure><p>4) auto 不能作用于模板参数，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="auto-的应用"><a href="#auto-的应用" class="headerlink" title="auto 的应用"></a>auto 的应用</h3><h4 id="使用-auto-定义迭代器"><a href="#使用-auto-定义迭代器" class="headerlink" title="使用 auto 定义迭代器"></a>使用 auto 定义迭代器</h4><p>auto 的一个典型应用场景是用来定义 STL 的迭代器。</p><p>我们在使用 STL 容器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，书写起来很麻烦，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。</p><p>修改上面的代码，使之变得非常简洁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto 可以根据表达式 v.begin() 的类型（begin() 函数的返回值类型）来推导出变量 i 的类型。</p><h4 id="auto-用于泛型编程"><a href="#auto-用于泛型编程" class="headerlink" title="auto 用于泛型编程"></a>auto 用于泛型编程</h4><p>auto 的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"www.baidu.com"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    func&lt;A&gt;();</span><br><span class="line">    func&lt;B&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure><p>本例中的模板函数 func() 会调用所有类的静态函数 get()，并对它的返回值做统一处理，但是 get() 的返回值类型并不一样，而且不能自动转换。这种要求在以前的 C++ 版本中实现起来非常的麻烦，需要额外增加一个模板参数，并在调用时手动给该模板参数赋值，用以指明变量 val 的类型。</p><p>但是有了 auto 类型自动推导，编译器就可以根据 get() 的返回值自己推导出 val 变量的类型，不用再增加一个模板参数了。</p><p>下面的代码演示了不使用 auto 的解决办法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://c.biancheng.net/cplus/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">// 需要额外增加一个模板参数 T2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    T2 val = T1::<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用时也要手动给模板参数赋值</span></span><br><span class="line">    func&lt;A, <span class="keyword">int</span>&gt;();</span><br><span class="line">    func&lt;B, <span class="keyword">const</span> <span class="keyword">char</span>*&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++11 之前的版本（C++98 和 C++ 03）中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 C#、JavaScript、PHP、Python 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便。C++11 为了顺应这种趋势也开始支持该语法，使用 auto 关键字来支持自动类型推导。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：无序关联容器</title>
    <link href="http://yoursite.com/2022/05/09/C-STL%EF%BC%9A%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2022/05/09/C-STL%EF%BC%9A%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2022-05-09T09:46:20.000Z</published>
    <updated>2022-05-21T10:58:27.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>继 map、multimap、set、multiset 关联容器之后，本节介绍一类“特殊”的关联容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。<a id="more"></a></p><blockquote><p>注意，无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p></blockquote><p>和关联容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><blockquote><p>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。</p></blockquote><p>基于底层实现采用了不同的数据结构，因此和关联容器相比，无序容器具有以下 2 个特点：</p><ol><li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li><li>和关联容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联容器。</li></ol><h3 id="无序容器种类"><a href="#无序容器种类" class="headerlink" title="无序容器种类"></a>无序容器种类</h3><p>和关联容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p><p>下表对这 4 种无序容器的功能做了详细的介绍：</p><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td><td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td></tr></tbody></table><p>以上 4 种无序容器的名称，仅是在前面所学的 4 种关联容器名称的基础上，添加了 “unordered_”，其实它们仅有一个区别，即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。</p><blockquote><p>也就是说，C++ 11 标准的 STL 中，在已提供有 4 种关联式容器的基础上，又新增了各自的“unordered”版本（无序版本、哈希版本），提高了查找指定元素的效率。既然无序容器和之前所学的关联容器类似，那么在实际使用中应该选哪种容器呢？总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p></blockquote><p>这里以 unordered_map 容器为例，举个例子（不必深究该容器的具体用法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_uMap&#123;</span><br><span class="line">        &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 查找指定键对应的值，效率比关联式容器高</span></span><br><span class="line">    <span class="built_in">string</span> str = my_uMap.at(<span class="string">"C语言教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"str = "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = my_uMap.<span class="built_in">begin</span>(); iter != my_uMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pair 类型键值对分为 2 部分</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = http://c.biancheng.net/c/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><hr><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p><blockquote><p>可以将 unordered_map 容器等价为无序的 map 容器。</p></blockquote><p>具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p><p>unordered_map 容器在<code>&lt;unordered_map&gt;</code>头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，但如果不用，则后续程序中在使用此容器时，需手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>unordered_map 容器模板的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                        // 键值对中键的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,                          // 键值对中值的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,           // 容器内部存储键值对所用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,       // 判断各个键值对键相同的规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt; pair&lt;const Key,T&gt; &gt;  // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure><p>以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如下表所示：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>&lt;key,T&gt;</td><td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td></tr><tr><td>Hash = hash&lt;Key&gt;</td><td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash&lt;key&gt; 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</td></tr><tr><td>Pred = equal_to&lt;Key&gt;</td><td>要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to&lt;key&gt; 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</td></tr></tbody></table><blockquote><p>总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p></blockquote><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>unordered_map 既可以看做是关联容器，更属于自成一脉的无序容器。因此在该容器模板类中，既包含一些在学习关联容器时常见的成员方法，还有一些属于无序容器特有的成员方法。下表列出了 unordered_map 类模板提供的所有常用的成员方法以及各自的功能：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>operator[key]</td><td>该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</td></tr><tr><td>at(key)</td><td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找以 key 键的键值对的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新键值对。</td></tr><tr><td>erase()</td><td>删除指定键值对。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储键值对的数量。</td></tr><tr><td>bucket(key)</td><td>返回以 key 为键的键值对所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_map 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><blockquote><p>注意，对于实现互换 2 个相同类型 unordered_map 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p></blockquote><h4 id="创建C-unordered-map容器的方法"><a href="#创建C-unordered-map容器的方法" class="headerlink" title="创建C++ unordered_map容器的方法"></a>创建C++ unordered_map容器的方法</h4><p>常见的创建 unordered_map 容器的方法有以下几种。</p><p>1) 通过调用 unordered_map 模板类的默认构造函数，可以创建空的 unordered_map 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; umap;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个可存储 &lt;string,string&gt; 类型键值对的 unordered_map 容器。</p><p>2) 当然，在创建 unordered_map 容器的同时，可以完成初始化操作。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>通过此方法创建的 umap 容器中，就包含有 3 个键值对元素。</p><p>3) 另外，还可以调用 unordered_map 模板中提供的复制（拷贝）构造函数，将现有 unordered_map 容器中存储的键值对，复制给新建 unordered_map 容器。</p><p>例如，在第二种方式创建好 umap 容器的基础上，再创建并初始化一个 umap2 容器：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap2(umap);</span><br></pre></td></tr></table></figure><p>由此，umap2 容器中就包含有 umap 容器中所有的键值对。</p><p>除此之外，C++ 11 标准中还向 unordered_map 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_map 容器中存储的所有键值对，全部复制给新建容器。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_map 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt; retUmap()&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;tempUmap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempUmap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用移动构造函数，创建 umap2 容器</span></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap2(retUmap());</span><br></pre></td></tr></table></figure><blockquote><p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p></blockquote><p>4) 当然，如果不想全部拷贝，可以使用 unordered_map 类模板提供的迭代器，在现有 unordered_map 容器中选择部分区域内的键值对，为新建 unordered_map 容器初始化。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap2(++umap.begin(),umap.end());</span><br></pre></td></tr></table></figure><p>通过此方式创建的 umap2 容器，其内部就包含 umap 容器中除第 1 个键值对外的所有其它键值对。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>C++ STL 标准库中，unordered_map 容器迭代器的类型为前向迭代器（又称正向迭代器）。这意味着，假设 p 是一个前向迭代器，则其只能进行 <code>*p、p++、++p</code> 操作，且 2 个前向迭代器之间只能用 <code>==</code> 和 <code>!=</code> 运算符做比较。</p><p>在 unordered_map 容器模板中，提供了下表所示的成员方法，可用来获取指向指定位置的前向迭代器。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr></tbody></table><blockquote><p>值得一提的是，equal_range(key) 很少用于 unordered_map 容器，因为该容器中存储的都是键不相等的键值对，即便调用该成员方法，得到的 2 个迭代器所表示的范围中，最多只包含 1 个键值对。事实上，该成员方法更适用于 unordered_multimap 容器。</p></blockquote><p>下面的程序演示了上表中部分成员方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"umap 存储的键值对包括："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 遍历输出 umap 容器中所有的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取指向指定键值对的前向迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"umap.find(\"Java教程\") = "</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">umap 存储的键值对包括：</span><br><span class="line">&lt;Python教程, http://c.biancheng.net/python/&gt;</span><br><span class="line">&lt;Linux教程, http://c.biancheng.net/linux/&gt;</span><br><span class="line">&lt;Java教程, http://c.biancheng.net/java/&gt;</span><br><span class="line">umap.find(<span class="string">"Java教程"</span>) = &lt;Java教程, http://c.biancheng.net/java/&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。</p><blockquote><p>所谓迭代器失效，针对的是那些用于表示容器内某个范围的迭代器，由于重哈希会重新调整每个键值对的存储位置，所以容器重哈希之后，之前表示特定范围的迭代器很可能无法再正确表示该范围。但是，重哈希并不会影响那些指向单个键值对元素的迭代器。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 向 umap 容器添加 50 个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        umap.emplace(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取键为 49 的键值对所在的范围</span></span><br><span class="line">    <span class="keyword">auto</span> pair = umap.equal_range(<span class="number">49</span>);</span><br><span class="line">    <span class="comment">// 输出 pair 范围内的每个键值对的键的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 手动调整最大负载因子数</span></span><br><span class="line">    umap.max_load_factor(<span class="number">3.0</span>);</span><br><span class="line">    <span class="comment">// 手动调用 rehash() 函数重哈希</span></span><br><span class="line">    umap.rehash(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 重哈希之后，pair 的范围可能会发生变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">49</span> <span class="number">17</span></span><br></pre></td></tr></table></figure><p>观察输出结果不难发现，之前用于表示键为 49 的键值对所在范围的 2 个迭代器，重哈希之后表示的范围发生了改变。</p><blockquote><p>经测试，用于遍历整个容器的 begin()/end() 和 cbegin()/cend() 迭代器对，重哈希只会影响遍历容器内键值对的顺序，整个遍历的操作仍然可以顺利完成。</p></blockquote><h4 id="C-STL-unordered-map获取元素的几种方法"><a href="#C-STL-unordered-map获取元素的几种方法" class="headerlink" title="C++ STL unordered_map获取元素的几种方法"></a>C++ STL unordered_map获取元素的几种方法</h4><p>为了方便用户快速地从该类型容器提取出目标元素（也就是某个键值对的值），unordered_map 容器类模板中提供了以下几种方法。</p><p>1) unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 获取 "Java教程" 对应的值</span></span><br><span class="line">    <span class="built_in">string</span> str = umap[<span class="string">"Java教程"</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><p>需要注意的是，如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// [] 运算符在 = 右侧</span></span><br><span class="line">    <span class="built_in">string</span> str = umap[<span class="string">"STL教程"</span>];</span><br><span class="line">    <span class="comment">// [] 运算符在 = 左侧</span></span><br><span class="line">    umap[<span class="string">"C教程"</span>] = <span class="string">"http://c.biancheng.net/c/"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程</span><br></pre></td></tr></table></figure><p>可以看到，当使用 [ ] 运算符向 unordered_map 容器中添加键值对时，分为 2 种情况：</p><ol><li>当 [ ] 运算符位于赋值号（=）右侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为键值对要求的值类型的默认值（string 类型默认值为空字符串）；</li><li>当 [ ] 运算符位于赋值号（=）左侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为赋值号右侧的元素。</li></ol><p>2) unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出<code>out_of_range</code>异常。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 获取指定键对应的值</span></span><br><span class="line">    <span class="built_in">string</span> str = umap.at(<span class="string">"Python教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 执行此语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; umap.at("GO教程");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure><p>此程序中，第 14 行代码用于获取 umap 容器中键为“Python教程”对应的值，由于 umap 容器确实有符合条件的键值对，因此可以成功执行；而第 17 行代码，由于当前 umap 容器没有存储以“Go教程”为键的键值对，因此执行此语句会抛出 out_of_range 异常。</p><p>3) [ ] 运算符和 at() 成员方法基本能满足大多数场景的需要。除此之外，还可以借助 unordered_map 模板中提供的 find() 成员方法。</p><p>和前面方法不同的是，通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p><ol><li>当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；</li><li>当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</li></ol><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 查找成功</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">"Python教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter2 = umap.<span class="built_in">find</span>(<span class="string">"GO教程"</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter2 == umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"当前容器中没有以\"GO教程\"为键的键值对"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">当前容器中没有以<span class="string">"GO教程"</span>为键的键值对</span><br></pre></td></tr></table></figure><p>4) 除了 find() 成员方法之外，甚至可以借助 begin()/end() 或者 cbegin()/cend()，通过遍历整个容器中的键值对来找到目标键值对。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unordered_map&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建 umap 容器</span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    // 遍历整个容器中存储的键值对</span><br><span class="line">    <span class="keyword">for</span> (auto iter = umap.begin(); iter != umap.end(); ++iter) &#123;</span><br><span class="line">        //判断当前的键值对是否就是要找的</span><br><span class="line">        if (!iter-&gt;first.compare("Java教程")) &#123;</span><br><span class="line">            cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><blockquote><p>以上 4 种方法中，前 2 种方法基本能满足多数场景的需要，建议初学者首选 at() 成员方法！</p></blockquote><h4 id="C-unordered-map-insert-方法"><a href="#C-unordered-map-insert-方法" class="headerlink" title="C++ unordered_map insert()方法"></a>C++ unordered_map insert()方法</h4><p>为了方便向已建 unordered_map 容器中添加新的键值对，该容器模板中提供了 insert() 方法，unordered_map 模板类中，提供了多种语法格式的 insert() 方法，根据功能的不同，可划分为以下几种用法。</p><p>1) insert() 方法可以将 pair 类型的键值对元素添加到 unordered_map 容器中，其语法格式有 2 种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以普通方式传递参数</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</span><br><span class="line"><span class="comment">// 以右值引用的方式传递参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> ( <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure><p>以上 2 种格式中，参数 val 表示要添加到容器中的目标键值对元素；该方法的返回值为 pair类型值，内部包含一个 iterator 迭代器和 bool 变量：</p><ul><li>当 insert() 将 val 成功添加到容器中时，返回的迭代器指向新添加的键值对，bool 值为 True；</li><li>当 insert() 添加键值对失败时，意味着当前容器中本就存储有和要添加键值对的键相等的键值对，这种情况下，返回的迭代器将指向这个导致插入操作失败的迭代器，bool 值为 False。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 构建要添加的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mypair(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 创建接收 insert() 方法返回值的pair类型变量</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    <span class="comment">// 调用 insert() 方法的第一种语法格式</span></span><br><span class="line">    ret = umap.insert(mypair);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; ret.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; ret.first-&gt;first &lt;&lt;<span class="string">" "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用 insert() 方法的第二种语法格式</span></span><br><span class="line">    ret = umap.insert(<span class="built_in">std</span>::make_pair(<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; ret.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool = <span class="number">1</span></span><br><span class="line">iter -&gt; STL教程 http://c.biancheng.net/stl/</span><br><span class="line">bool = <span class="number">1</span></span><br><span class="line">iter -&gt; Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure><p>从输出结果很容易看出，两次添加键值对的操作，insert() 方法返回值中的 bool 变量都为 1，表示添加成功，此时返回的迭代器指向的是添加成功的键值对。</p><p>2) 除此之外，insert() 方法还可以指定新键值对要添加到容器中的位置，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以普通方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, <span class="keyword">const</span> value_type&amp; val )</span></span>;</span><br><span class="line"><span class="comment">// 以右值引用方法传递 val 参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">iterator</span> <span class="title">insert</span> ( <span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure><p>以上 2 种语法格式中，hint 参数为迭代器，用于指定新键值对要添加到容器中的位置；val 参数指的是要添加容器中的键值对；方法的返回值为迭代器：</p><ul><li>如果 insert() 方法成功添加键值对，该迭代器指向新添加的键值对；</li><li>如果 insert() 方法添加键值对失败，则表示容器中本就包含有相同键的键值对，该方法返回的迭代器就指向容器中键相同的键值对；</li></ul><blockquote><p>注意，以上 2 种语法格式中，虽然通过 hint 参数指定了新键值对添加到容器中的位置，但该键值对真正存储的位置，并不是 hint 参数说了算，最终的存储位置仍取决于该键值对的键的值。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 构建要添加的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mypair(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 创建接收 insert() 方法返回值的迭代器类型变量</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">// 调用第一种语法格式</span></span><br><span class="line">    iter = umap.insert(umap.<span class="built_in">begin</span>(), mypair);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用第二种语法格式</span></span><br><span class="line">    iter = umap.insert(umap.<span class="built_in">begin</span>(),<span class="built_in">std</span>::make_pair(<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter -&gt; STL教程 http://c.biancheng.net/stl/</span><br><span class="line">iter -&gt; Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure><p>3) insert() 方法还支持将某一个 unordered_map 容器中指定区域内的所有键值对，复制到另一个 unordered_map 容器中，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span> ( <span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span> );</span></span><br></pre></td></tr></table></figure><p>其中 first 和 last 都为迭代器，<code>[first, last)</code>表示复制其它 unordered_map 容器中键值对的区域。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 创建一个空的 unordered_map 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; otherumap;</span><br><span class="line">    <span class="comment">// 指定要拷贝 umap 容器中键值对的范围</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++umap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = umap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 将指定 umap 容器中 [first,last) 区域内的键值对复制给 otherumap 容器</span></span><br><span class="line">    otherumap.insert(first, last);</span><br><span class="line">    <span class="comment">// 遍历 otherumap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherumap.<span class="built_in">begin</span>(); iter != otherumap.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python教程 http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">Java教程 http:<span class="comment">//c.biancheng.net/java/</span></span><br></pre></td></tr></table></figure><p>4) 除了以上 3 种方式，insert() 方法还支持一次向 unordered_map 容器添加多个键值对，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br></pre></td></tr></table></figure><p>其中，il 参数指的是可以用初始化列表的形式指定多个键值对元素。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空的 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 向 umap 容器同时添加多个键值对</span></span><br><span class="line">    umap.insert(&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;);</span><br><span class="line">    <span class="comment">// 遍历输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><p>总的来说，unordered_map 模板类提供的 insert() 方法有以上 4 种，我们可以根据实际场景的需要自行选择使用哪一种。</p><h4 id="C-unordered-map-emplace-和emplace-hint-方法"><a href="#C-unordered-map-emplace-和emplace-hint-方法" class="headerlink" title="C++ unordered_map emplace()和emplace_hint()方法"></a>C++ unordered_map emplace()和emplace_hint()方法</h4><p>和前面学的 map、set 等容器一样，C++ 11 标准也为 unordered_map 容器新增了 emplace() 和 emplace_hint() 成员方法。我们知道，实现向已有 unordered_map 容器中添加新键值对，可以通过调用 insert() 方法，但其实还有更好的方法，即使用 emplace() 或者 emplace_hint() 方法，它们完成“向容器中添加新键值对”的效率，要比 insert() 方法高。</p><h5 id="unordered-map-emplace-方法"><a href="#unordered-map-emplace-方法" class="headerlink" title="unordered_map emplace()方法"></a>unordered_map emplace()方法</h5><p>emplace() 方法的用法很简单，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">emplace</span> ( <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br></pre></td></tr></table></figure><p>其中，参数 args 表示可直接向该方法传递创建新键值对所需要的 2 个元素的值，其中第一个元素将作为键值对的键，另一个作为键值对的值。也就是说，该方法无需我们手动创建键值对，其内部会自行完成此工作。</p><p>另外需要注意的是，该方法的返回值为 pair 类型值，其包含一个迭代器和一个 bool 类型值：</p><ul><li>当 emplace() 成功添加新键值对时，返回的迭代器指向新添加的键值对，bool 值为 True；</li><li>当 emplace() 添加新键值对失败时，说明容器中本就包含一个键相等的键值对，此时返回的迭代器指向的就是容器中键相同的这个键值对，bool 值为 False。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 定义一个接受 emplace() 方法的 pair 类型变量</span></span><br><span class="line">    pair&lt;<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    <span class="comment">// 调用 emplace() 方法</span></span><br><span class="line">    ret = umap.emplace(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 输出 ret 中包含的 2 个元素的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool ="</span> &lt;&lt; ret.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool =<span class="number">1</span></span><br><span class="line">iter -&gt;STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>通过执行结果中 bool 变量的值为 1 可以得知，emplace() 方法成功将新键值对添加到了 umap 容器中。</p><h5 id="unordered-map-emplace-hint-方法"><a href="#unordered-map-emplace-hint-方法" class="headerlink" title="unordered_map emplace_hint()方法"></a>unordered_map emplace_hint()方法</h5><p>emplace_hint() 方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">iterator</span> <span class="title">emplace_hint</span> ( <span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br></pre></td></tr></table></figure><p>和 emplace() 方法相同，emplace_hint() 方法内部会自行构造新键值对，因此我们只需向其传递构建该键值对所需的 2 个元素（第一个作为键，另一个作为值）即可。不同之处在于：</p><ul><li>emplace_hint() 方法的返回值仅是一个迭代器，而不再是 pair 类型变量。当该方法将新键值对成功添加到容器中时，返回的迭代器指向新添加的键值对；反之，如果添加失败，该迭代器指向的是容器中和要添加键值对键相同的那个键值对。</li><li>emplace_hint() 方法还需要传递一个迭代器作为第一个参数，该迭代器表明将新键值对添加到容器中的位置。需要注意的是，新键值对添加到容器中的位置，并不是此迭代器说了算，最终仍取决于该键值对的键的值。</li></ul><blockquote><p>可以这样理解，emplace_hint() 方法中传入的迭代器，仅是给 unordered_map 容器提供一个建议，并不一定会被容器采纳。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 定义一个接受 emplace_hint() 方法的迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">// 调用 empalce_hint() 方法</span></span><br><span class="line">    iter = umap.emplace_hint(umap.<span class="built_in">begin</span>(),<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 输出 emplace_hint() 返回迭代器 iter 指向的键值对的内容</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt;"</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter -&gt;STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><h4 id="C-STL-unordered-map删除元素：erase-和clear"><a href="#C-STL-unordered-map删除元素：erase-和clear" class="headerlink" title="C++ STL unordered_map删除元素：erase()和clear()"></a>C++ STL unordered_map删除元素：erase()和clear()</h4><p>C++ STL 标准库为了方便用户可以随时删除 unordered_map 容器中存储的键值对，unordered_map 容器类模板中提供了以下 2 个成员方法：</p><ul><li>erase()：删除 unordered_map 容器中指定的键值对；</li><li>clear()：删除 unordered_map 容器中所有的键值对，即清空容器。</li></ul><h5 id="unordered-map-erase-方法"><a href="#unordered-map-erase-方法" class="headerlink" title="unordered_map erase()方法"></a>unordered_map erase()方法</h5><p>为了满足不同场景删除 unordered_map 容器中键值对的需要，此容器的类模板中提供了 3 种语法格式的 erase() 方法。</p><p>1) erase() 方法可以接受一个正向迭代器，并删除该迭代器指向的键值对。该方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">( const_iterator <span class="built_in">position</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>其中 position 为指向容器中某个键值对的迭代器，该方法会返回一个指向被删除键值对之后位置的迭代器。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"erase:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 定义一个接收 erase() 方法的迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator ret;</span><br><span class="line">    <span class="comment">// 删除容器中第一个键值对</span></span><br><span class="line">    ret = umap.erase(umap.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; ret-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; ret-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">erase:</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">ret = Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure><p>可以看到，通过给 erase() 方法传入指向容器中第一个键值对的迭代器，该方法可以将容器中第一个键值对删除，同时返回一个指向被删除键值对之后位置的迭代器。</p><blockquote><p>注意，如果erase()方法删除的是容器存储的最后一个键值对，则该方法返回的迭代器，将指向容器中最后一个键值对之后的位置（等同于 end() 方法返回的迭代器）。</p></blockquote><p>2) 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。erase() 方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br></pre></td></tr></table></figure><p>其中，k 表示目标键值对的键的值；该方法会返回一个整数，其表示成功删除的键值对的数量。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;; </span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> delNum = umap.erase(<span class="string">"Python教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"delNum = "</span> &lt;&lt; delNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 再次输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">delNum = <span class="number">1</span></span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><p>通过输出结果可以看到，通过将 “Python教程” 传给 erase() 方法，就成功删除了 umap 容器中键为 “Python教程” 的键值对。</p><p>3) 除了支持删除 unordered_map 容器中指定的某个键值对，erase() 方法还支持一次删除指定范围内的所有键值对，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是正向迭代器，[first, last) 范围内的所有键值对都会被 erase() 方法删除；同时，该方法会返回一个指向被删除的最后一个键值对之后一个位置的迭代器。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// first 指向第一个键值对</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = umap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// last 指向最后一个键值对</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = umap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 删除[fist,last)范围内的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> ret = umap.erase(first, last);</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序会发现，没有输出任何数据，因为 erase() 方法删除了 umap 容器中 [begin(), end()) 范围内所有的元素。</p><h5 id="unordered-map-clear-方法"><a href="#unordered-map-clear-方法" class="headerlink" title="unordered_map clear()方法"></a>unordered_map clear()方法</h5><p>在个别场景中，可能需要一次性删除 unordered_map 容器中存储的所有键值对，可以使用 clear() 方法，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除容器内所有键值对</span></span><br><span class="line">    umap.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"umap size = "</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">umap size = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>显然，通过调用 clear() 方法，原本包含 3 个键值对的 umap 容器，变成了空容器。</p><blockquote><p>注意，虽然使用 erase() 方法的第 3 种语法格式，可能实现删除 unordered_map 容器内所有的键值对，但更推荐使用 clear() 方法。</p></blockquote><hr><h2 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>C++ STL 标准库中，除了提供有 unordered_map 无序关联容器，还提供有和 unordered_map 容器非常相似的 unordered_multimap 无序关联容器。</p><p>和 unordered_map 容器一样，unordered_multimap 容器也以键值对的形式存储数据，且底层也采用哈希表结构存储各个键值对。两者唯一的不同之处在于，unordered_multimap 容器可以存储多个键相等的键值对，而 unordered_map 容器不行。</p><blockquote><p>无序容器中存储的各个键值对，都会哈希存到各个桶（本质为链表）中。而对于 unordered_multimap 容器来说，其存储的所有键值对中，键相等的键值对会被哈希到同一个桶中存储。</p></blockquote><p>另外值得一提得是，STL 标准库中实现 unordered_multimap 容器的模板类并没有定义在以自己名称命名的头文件中，而是和 unordered_map 容器一样，定义在<code>&lt;unordered_map&gt;</code>头文件，且位于 std 命名空间中。因此，在使用 unordered_multimap 容器之前，程序中应包含如下 2 行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，但如果不用，则后续程序中在使用此容器时，需手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>unordered_multimap 容器模板的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,      // 键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,        // 值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,  // 底层存储键值对时采用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,  // 判断各个键值对的键相等的规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt; pair&lt;const Key,T&gt; &gt; // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_multimap</span>;</span></span><br></pre></td></tr></table></figure><p>以上 5 个参数中，必须显式给前 2 个参数传值，且除极个别的情况外，最多只使用前 4 个参数，它们各自的含义和功能如下表所示。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>&lt;key,T&gt;</td><td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td></tr><tr><td>Hash = hash&lt;Key&gt;</td><td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash&lt;key&gt; 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</td></tr><tr><td>Pred = equal_to&lt;Key&gt;</td><td>unordered_multimap 容器可以存储多个键相等的键值对，而判断是否相等的规则，由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to&lt;key&gt; 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</td></tr></tbody></table><p>注意，当 unordered_multimap 容器中存储键值对的键为自定义类型时，默认的哈希函数 hash&lt;key&gt; 以及比较函数 equal_to&lt;key&gt; 将不再适用，这种情况下，需要我们自定义适用的哈希函数和比较函数，并分别显式传递给 Hash 参数和 Pred 参数。</p><h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><p>和 unordered_map 容器相比，unordered_multimap 容器的类模板中没有重载 [ ] 运算符，也没有提供 at() 成员方法，除此之外它们完全一致。</p><blockquote><p>没有提供 [ ] 运算符和 at() 成员方法，意味着 unordered_multimap 容器无法通过指定键获取该键对应的值，因为该容器允许存储多个键相等的键值对，每个指定的键可能对应多个不同的值。</p></blockquote><p>unordered_multimap 类模板提供的成员方法如下表所示：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找以 key 键的键值对的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新键值对。</td></tr><tr><td>erase()</td><td>删除指定键值对。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储键值对的数量。</td></tr><tr><td>bucket(key)</td><td>返回以 key 为键的键值对所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_multimap 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><blockquote><p>注意，对于实现互换 2 个相同类型 unordered_multimap 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p></blockquote><h3 id="创建C-unordered-multimap容器"><a href="#创建C-unordered-multimap容器" class="headerlink" title="创建C++ unordered_multimap容器"></a>创建C++ unordered_multimap容器</h3><p>常见的创建 unordered_map 容器的方法有以下几种。</p><p>1) 利用 unordered_multimap 容器类模板中的默认构造函数，可以创建空的 unordered_multimap 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; myummap;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个可存储 &lt;string, string&gt; 类型键值对的 unordered_multimap 容器，只不过当前容器是空的，即没有存储任何键值对。</p><p>2) 当然，在创建空 unordered_multimap 容器的基础上，可以完成初始化操作。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; myummap&#123;</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>通过此方法创建的 myummap 容器中，就包含有 3 个键值对。</p><p>3) 另外，unordered_multimap 模板中还提供有复制（拷贝）构造函数，可以实现在创建 unordered_multimap 容器的基础上，用另一 unordered_multimap 容器中的键值对为其初始化。</p><p>例如，在第二种方式创建好 myummap 容器的基础上，再创建并初始化一个 myummap2 容器：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_multimap&lt;string, string&gt; myummap2(myummap);</span><br></pre></td></tr></table></figure><p>由此，刚刚创建好的 myummap2 容器中，就包含有 myummap 容器中所有的键值对。</p><p>除此之外，C++ 11 标准中还向 unordered_multimap 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_multimap 容器中存储的所有键值对，全部复制给新建容器。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_multimap 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multimap</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt; retUmmap() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;tempummap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempummap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并初始化 myummap 容器</span></span><br><span class="line">std::unordered_multimap&lt;std::string, std::string&gt; myummap(retummap());</span><br></pre></td></tr></table></figure><p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p><p>4) 当然，如果不想全部拷贝，可以使用 unordered_multimap 类模板提供的迭代器，在现有 unordered_multimap 容器中选择部分区域内的键值对，为新建 unordered_multimap 容器初始化。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line">std::unordered_multimap&lt;std::string, std::string&gt; myummap2(++myummap.begin(), myummap.end());</span><br></pre></td></tr></table></figure><p>通过此方式创建的 myummap2 容器，其内部就包含 myummap 容器中除第 1 个键值对外的所有其它键值对。</p><hr><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p><p>总的来说，unordered_set 容器具有以下几个特性：</p><ol><li>不再以键值对的形式存储数据，而是直接存储数据的值；</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li><li>不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关）。</li></ol><blockquote><p>对于 unordered_set 容器不以键值对的形式存储数据，也可以这样认为，即 unordered_set 存储的都是键和值相等的键值对，为了节省存储空间，该类容器在实际存储时选择只存储每个键值对的值。</p></blockquote><p>另外，实现 unordered_set 容器的模板类定义在<code>&lt;unordered_set&gt;</code>头文件，并位于 std 命名空间中。这意味着，如果程序中需要使用该类型容器，则首先应该包含如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，但如果不用，则程序中只要用到该容器时，必须手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>unordered_set 容器的类模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,            // 容器中存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,    // 确定元素存储位置所用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,   // 判断各个元素是否相等所用的函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;Key&gt;   // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_set</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，以上 4 个参数中，只有第一个参数没有默认值，这意味着如果我们想创建一个 unordered_set 容器，至少需要手动传递 1 个参数。事实上，在 99% 的实际场景中最多只需要使用前 3 个参数（各自含义如下表所示），最后一个参数保持默认值即可。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Key</td><td>确定容器存储元素的类型，如果读者将 unordered_set 看做是存储键和值相同的键值对的容器，则此参数则用于确定各个键值对的键和值的类型，因为它们是完全相同的，因此一定是同一数据类型的数据。</td></tr><tr><td>Hash = hash&lt;Key&gt;</td><td>指定 unordered_set 容器底层存储各个元素时，所使用的哈希函数。需要注意的是，默认哈希函数 hash&lt;Key&gt; 只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</td></tr><tr><td>Pred = equal_to&lt;Key&gt;</td><td>unordered_set 容器内部不能存储相等的元素，而衡量 2 个元素是否相等的标准，取决于该参数指定的函数。 默认情况下，使用 STL 标准库中提供的 equal_to&lt;key&gt; 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</td></tr></tbody></table><blockquote><p>注意，如果 unordered_set 容器中存储的元素为自定义的数据类型，则默认的哈希函数 hash&lt;key&gt; 以及比较函数 equal_to&lt;key&gt; 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p></blockquote><h3 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h3><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器。</td></tr><tr><td>end();</td><td>返回指向容器中最后一个元素之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找值为 key 的元素的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新元素。</td></tr><tr><td>erase()</td><td>删除指定元素。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有元素。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_map 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储元素的数量。</td></tr><tr><td>bucket(key)</td><td>返回值为 key 的元素所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_map 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><p>注意，此容器模板类中没有重载 [ ] 运算符，也没有提供 at() 成员方法。不仅如此，由于 unordered_set 容器内部存储的元素值不能被修改，因此无论使用那个迭代器方法获得的迭代器，都不能用于修改容器中元素的值。</p><p>另外，对于实现互换 2 个相同类型 unordered_set 容器的所有元素，除了调用上表中的 swap() 成员方法外，还可以使用 STL 标准库提供的 swap() 非成员函数，它们具有相同的名称，用法也相同（都只需要传入 2 个参数即可），仅是调用方式上有差别。</p><h3 id="创建C-unordered-set容器"><a href="#创建C-unordered-set容器" class="headerlink" title="创建C++ unordered_set容器"></a>创建C++ unordered_set容器</h3><p>前面介绍了如何创建 unordered_map 和 unordered_multimap 容器，值得一提的是，创建它们的所有方式完全适用于 unordereded_set 容器。</p><p>1) 通过调用 unordered_set 模板类的默认构造函数，可以创建空的 unordered_set 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uset;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个可存储 string 类型值的 unordered_set 容器，该容器底层采用默认的哈希函数 hash&lt;Key&gt; 和比较函数 equal_to&lt;Key&gt;。</p><p>2) 当然，在创建 unordered_set 容器的同时，可以完成初始化操作。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                      <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                      <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br></pre></td></tr></table></figure><p>通过此方法创建的 uset 容器中，就包含有 3 个 string 类型元素。</p><p>3) 还可以调用 unordered_set 模板中提供的复制（拷贝）构造函数，将现有 unordered_set 容器中存储的元素全部用于为新建 unordered_set 容器初始化。</p><p>例如，在第二种方式创建好 uset 容器的基础上，再创建并初始化一个 uset2 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uset2</span><span class="params">(uset)</span></span>;</span><br></pre></td></tr></table></figure><p>由此，umap2 容器中就包含有 umap 容器中所有的元素。</p><p>除此之外，C++ 11 标准中还向 unordered_set 模板类增加了移动构造函数，即以右值引用的方式，利用临时 unordered_set 容器中存储的所有元素，给新建容器初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_set 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; retuset() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempuset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                              <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                              <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempuset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用移动构造函数，创建 uset 容器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uset</span><span class="params">(retuset())</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p></blockquote><p>4) 当然，如果不想全部拷贝，可以使用 unordered_set 类模板提供的迭代器，在现有 unordered_set 容器中选择部分区域内的元素，为新建 unordered_set 容器初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uset2</span><span class="params">(++uset.<span class="built_in">begin</span>(),uset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure><p>通过此方式创建的 uset2 容器，其内部就包含 uset 容器中除第 1 个元素外的所有其它元素。</p><hr><h2 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>前面章节介绍了 unordered_set 容器的特定和用法，在此基础上，本节再介绍一个类似的 C++ STL 无序容器，即 unordered_multiset 容器。</p><p>所谓“类似”，指的是 unordered_multiset 容器大部分的特性都和 unordered_set 容器相同，包括：</p><ol><li>unordered_multiset 不以键值对的形式存储数据，而是直接存储数据的值；</li><li>该类型容器底层采用的也是哈希表存储结构，它不会对内部存储的数据进行排序；</li><li>unordered_multiset 容器内部存储的元素，其值不能被修改。</li></ol><p>和 unordered_set 容器不同的是，unordered_multiset 容器可以同时存储多个值相同的元素，且这些元素会存储到哈希表中同一个桶（本质就是链表）上。</p><blockquote><p>可以这样认为，unordered_multiset 除了能存储相同值的元素外，它和 unordered_set 容器完全相同。</p></blockquote><p>另外值得一提的是，实现 unordered_multiset 容器的模板类并没有定义在以该容器名命名的文件中，而是和 unordered_set 容器共用同一个<code>&lt;unordered_set&gt;</code>头文件，并且也位于 std 命名空间。因此，如果程序中需要使用该类型容器，应包含如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，但如果不用，则程序中只要用到该容器时，必须手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>unordered_multiset 容器类模板的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,            // 容器中存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,    // 确定元素存储位置所用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,   // 判断各个元素是否相等所用的函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;Key&gt;   // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_multiset</span>;</span></span><br></pre></td></tr></table></figure><p>需要说明的是，在 99% 的实际场景中，最多只需要使用前 3 个参数（各自含义如下表所示），最后一个参数保持默认值即可。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Key</td><td>确定容器存储元素的类型，如果读者将 unordered_multiset 看做是存储键和值相同的键值对的容器，则此参数则用于确定各个键值对的键和值的类型，因为它们是完全相同的，因此一定是同一数据类型的数据。</td></tr><tr><td>Hash = hash&lt;Key&gt;</td><td>指定 unordered_multiset 容器底层存储各个元素时所使用的哈希函数。需要注意的是，默认哈希函数 hash&lt;Key&gt; 只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</td></tr><tr><td>Pred = equal_to&lt;Key&gt;</td><td>用于指定 unordered_multiset 容器判断元素值相等的规则。默认情况下，使用 STL 标准库中提供的 equal_to&lt;key&gt; 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</td></tr></tbody></table><blockquote><p>总之，如果 unordered_multiset 容器中存储的元素为自定义的数据类型，则默认的哈希函数 hash&lt;key&gt; 以及比较函数 equal_to&lt;key&gt; 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p></blockquote><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>unordered_multiset 模板类中提供的成员方法，无论是种类还是数量，都和 unordered_set 类模板一样，如下表所示：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器。</td></tr><tr><td>end();</td><td>返回指向容器中最后一个元素之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找值为 key 的元素的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新元素。</td></tr><tr><td>erase()</td><td>删除指定元素。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有元素。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_multimap 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储元素的数量。</td></tr><tr><td>bucket(key)</td><td>返回值为 key 的元素所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回容器当前的负载因子。所谓负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_map 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><p>注意，和 unordered_set 容器一样，unordered_multiset 模板类也没有重载 [ ] 运算符，没有提供 at() 成员方法。不仅如此，无论是由哪个成员方法返回的迭代器，都不能用于修改容器中元素的值。</p><p>另外，对于互换 2 个相同类型 unordered_multiset 容器存储的所有元素，除了调用上表中的 swap() 成员方法外，STL 标准库也提供了 swap() 非成员函数。</p><h3 id="创建C-unordered-multiset容器"><a href="#创建C-unordered-multiset容器" class="headerlink" title="创建C++ unordered_multiset容器"></a>创建C++ unordered_multiset容器</h3><p>考虑到不同场景的需要，unordered_multiset 容器模板类共提供了以下 4 种创建 unordered_multiset 容器的方式。</p><p>1) 调用 unordered_multiset 模板类的默认构造函数，可以创建空的 unordered_multiset 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; umset;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个可存储 string 类型值的 unordered_multiset 容器，该容器底层采用默认的哈希函数 hash&lt;Key&gt; 和比较函数 equal_to&lt;Key&gt;。</p><p>2) 当然，在创建 unordered_multiset 容器的同时，可以进行初始化操作。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; umset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                            <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                            <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br></pre></td></tr></table></figure><p>通过此方法创建的 umset 容器中，内部存有 3 个 string 类型元素。</p><p>3) 还可以调用 unordered_multiset 模板中提供的复制（拷贝）构造函数，将现有 unordered_multiset 容器中存储的元素全部用于为新建 unordered_multiset 容器初始化。</p><p>例如，在第二种方式创建好 umset 容器的基础上，再创建并初始化一个 umset2 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">umset2</span><span class="params">(umset)</span></span>;</span><br></pre></td></tr></table></figure><p>由此，umap2 容器中就包含有 umap 容器中所有的元素。</p><p>除此之外，C++ 11 标准中还向 unordered_multiset 模板类增加了移动构造函数，即以右值引用的方式，利用临时 unordered_multiset 容器中存储的所有元素，给新建容器初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_multiset 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; retumset() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempumset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                                    <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                                    <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempumset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用移动构造函数，创建 umset 容器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">umset</span><span class="params">(retumset())</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p></blockquote><p>4) 当然，如果不想全部拷贝，可以使用 unordered_multiset 类模板提供的迭代器，在现有 unordered_multiset 容器中选择部分区域内的元素，为新建的 unordered_multiset 容器初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">umset2</span><span class="params">(++umset.<span class="built_in">begin</span>(), umset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure><p>通过此方式创建的 umset2 容器，其内部就包含 umset 容器中除第 1 个元素外的所有其它元素。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;无序关联容器&quot;&gt;&lt;a href=&quot;#无序关联容器&quot; class=&quot;headerlink&quot; title=&quot;无序关联容器&quot;&gt;&lt;/a&gt;无序关联容器&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;继 map、multimap、set、multiset 关联容器之后，本节介绍一类“特殊”的关联容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：关联容器之set和multiset</title>
    <link href="http://yoursite.com/2022/05/07/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bset%E5%92%8Cmultiset/"/>
    <id>http://yoursite.com/2022/05/07/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bset%E5%92%8Cmultiset/</id>
    <published>2022-05-07T09:43:03.000Z</published>
    <updated>2022-05-21T10:20:56.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前面介绍了 map 容器和 multimap 容器，类似地，C++ STL 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联容器。<a id="more"></a></p><p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。举个例子，如下有 2 组键值对数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;<span class="string">'a'</span>, <span class="number">1</span>&gt;, &lt;<span class="string">'b'</span>, <span class="number">2</span>&gt;, &lt;<span class="string">'c'</span>, <span class="number">3</span>&gt;&#125;</span><br><span class="line">&#123;&lt;<span class="string">'a'</span>, <span class="string">'a'</span>&gt;, &lt;<span class="string">'b'</span>, <span class="string">'b'</span>&gt;, &lt;<span class="string">'c'</span>, <span class="string">'c'</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p><p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。</p><p>通过前面的学习我们知道，map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。</p><p>另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。</p><blockquote><p>对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</p></blockquote><p>set 容器定义于&lt;set&gt;头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 set 容器时，需手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>set 容器的类模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt;,        // 指定 <span class="title">set</span> 容器内部的排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt;      // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。</p></blockquote><p>对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>下表列出了 set 容器提供的常用成员方法以及各自的功能：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 set 容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>insert()</td><td>向 set 容器中插入元素。</td></tr><tr><td>erase()</td><td>删除 set 容器中存储的元素。</td></tr><tr><td>swap()</td><td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(val)</td><td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table><h3 id="创建C-set容器的几种方法"><a href="#创建C-set容器的几种方法" class="headerlink" title="创建C++ set容器的几种方法"></a>创建C++ set容器的几种方法</h3><p>常见的创建 set 容器的方法，大致有以下 5 种。</p><p>1) 调用默认构造函数，创建空的 set 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br></pre></td></tr></table></figure><p>由此就创建好了一个 set 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</p><p>2) 除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123;<span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/python/"</span>&#125;;</span><br></pre></td></tr></table></figure><p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 <code>std::less&lt;T&gt;</code> 规则，因此其内部存储 string 元素的顺序如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure><p>3) set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。</p><p>例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure><p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p><p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> myset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure><p>注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。</p><blockquote><p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p></blockquote><p>4) 在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                    <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                    <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copyset</span><span class="params">(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure><p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure><p>5) 以上几种方式创建的 set 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt; &gt; myset&#123;</span><br><span class="line">    <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/python/"</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过选用 std::greater&lt;string&gt; 降序规则，myset 容器中元素的存储顺序为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>和 map 容器不同，C++ STL 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</p><p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 <code>++p、p++、--p、p--、*p</code> 操作，并且 2 个双向迭代器之间做比较，也只能使用 <code>==</code> 或者 <code>!=</code> 运算符。</p><p>在 set 容器类模板提供的所有成员函数中，返回迭代器的成员函数如下表所示：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr></tbody></table><blockquote><p>注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p></blockquote><p>1) 下面程序以 begin()/end() 为例，演示了如何使用相关迭代器遍历 set 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><blockquote><p>再次强调，正如程序第 15 行代码所示的那样，因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。</p></blockquote><p>2) 除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p><p>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = myset.<span class="built_in">find</span>(<span class="string">"http://c.biancheng.net/python/"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;iter != myset.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</p></blockquote><h3 id="set-insert-方法详解"><a href="#set-insert-方法详解" class="headerlink" title="set insert()方法详解"></a>set insert()方法详解</h3><p>如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。为满足不同场景的需要，C++ 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p><p>1) 只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">// 右值引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</span><br></pre></td></tr></table></figure><p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。</p><blockquote><p>以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式。</p></blockquote><p>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">// 准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">// 采用普通引用传值方式</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    retpair = myset.insert(str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; retpair.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.insert(<span class="string">"http://c.biancheng.net/python/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; retpair.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter-&gt;http://c.biancheng.net/stl/ bool = 1</span><br><span class="line">iter-&gt;http://c.biancheng.net/python/ bool = 1</span><br></pre></td></tr></table></figure><p>通过观察输出结果不难看出，程序中两次借助 insert() 方法向 set 容器中添加元素，都成功了。</p><p>2) insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator <span class="built_in">position</span>, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</li><li>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">// 准备接受 insert() 的返回值</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">// 采用普通引用传值方式</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    iter = myset.insert(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size ="</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 采用右值引用传值方式</span></span><br><span class="line">    iter = myset.insert(myset.<span class="built_in">end</span>(),<span class="string">"http://c.biancheng.net/python/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size ="</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size =<span class="number">1</span></span><br><span class="line">myset size =<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</p></blockquote><p>3) insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。insert() 方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">insert</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                <span class="string">"http://c.biancheng.net/python/"</span>,</span><br><span class="line">                                <span class="string">"http://c.biancheng.net/java/"</span> &#125;;</span><br><span class="line">    <span class="comment">// 创建一个同类型的空 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; otherset;</span><br><span class="line">    <span class="comment">// 利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.insert(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p><p>4) 采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( &#123;E1, E2,...,En&#125; )</span></span>;</span><br></pre></td></tr></table></figure><p>其中，Ei 表示新添加的元素。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">// 向 myset 中添加多个元素</span></span><br><span class="line">    myset.insert(&#123; <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">        <span class="string">"http://c.biancheng.net/python/"</span>,</span><br><span class="line">        <span class="string">"http://c.biancheng.net/java/"</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>以上即为 set 类模板中 insert() 成员方法的全部用法。另外，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。</p><h3 id="set-emplace-和emplace-hint-方法详解"><a href="#set-emplace-和emplace-hint-方法详解" class="headerlink" title="set emplace()和emplace_hint()方法详解"></a>set emplace()和emplace_hint()方法详解</h3><p>set 类模板提供的所有成员方法中，能实现向指定 set 容器中添加新元素的，只有 3 个成员方法，分别为 insert()、emplace() 和 emplace_hint()。其中 insert() 成员方法的用法已在上节做了详细的介绍，本节重点介绍剩下的这 2 个成员方法。</p><p>emplace() 和 emplace_hint() 是 C++ 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。</p><p>1) emplace() 方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">emplace</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>其中，参数 (Args&amp;&amp;… args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。</p><p>另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：</p><ul><li>当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；</li><li>当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。</li></ul><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;myset;</span><br><span class="line">    <span class="comment">// 向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = myset.emplace(<span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;"</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size = <span class="number">1</span></span><br><span class="line">ret.iter = &lt;http://c.biancheng.net/stl/, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p><p>2) emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">iterator</span> <span class="title">emplace_hint</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>和 emplace() 方法相比，有以下 2 点不同：</p><ul><li>该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（新元素会添加到该迭代器指向元素的前面）；</li><li>返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。</li></ul><p>下面程序演示 emplace_hint() 方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;myset;</span><br><span class="line">    <span class="comment">// 在 set 容器的指定位置添加键值对</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = myset.emplace_hint(myset.<span class="built_in">begin</span>(), <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myset size = <span class="number">1</span></span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。</p><blockquote><p>以上内容介绍了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的。</p></blockquote><h3 id="set删除数据：erase-和clear-方法"><a href="#set删除数据：erase-和clear-方法" class="headerlink" title="set删除数据：erase()和clear()方法"></a>set删除数据：erase()和clear()方法</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p><p>1) set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="comment">// 删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。</p><blockquote><p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p></blockquote><p>下面程序演示了以上 3 种 erase() 方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="keyword">int</span> num = myset.erase(<span class="number">2</span>); <span class="comment">// 删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = myset.erase(myset.<span class="built_in">begin</span>()); <span class="comment">// 删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset.erase(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>()); <span class="comment">// 删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter2-&gt;"</span> &lt;&lt; *iter2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myset size = <span class="number">5</span></span><br><span class="line"><span class="number">1</span>、myset size = <span class="number">4</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">iter-&gt;3</span><br><span class="line"><span class="number">3</span>、myset size = <span class="number">1</span></span><br><span class="line">iter2-&gt;5</span><br></pre></td></tr></table></figure><p>2) 如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>显然，该方法不需要传入任何参数，也没有任何返回值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 清空 myset 容器</span></span><br><span class="line">    myset.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、myset size = <span class="number">5</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>前面对 set 容器做了详细的介绍。回忆一下，set 容器具有以下几个特性：</p><ul><li>不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；</li><li>set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；</li><li>存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；</li><li>set 容器存储的元素必须互不相等。</li></ul><p>在此基础上，C++ STL 标准库中还提供有一个和 set 容器相似的关联式容器，即 multiset 容器。所谓“相似”，是指 multiset 容器遵循 set 容器的前 3 个特性，仅在第 4 条特性上有差异。和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。</p><blockquote><p>也就是说，multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。</p></blockquote><p>和 set 类模板一样，multiset 类模板也定义在&lt;set&gt;头文件，并位于 std 命名空间中。这意味着，如果想在程序中使用 multiset 容器，该程序代码应包含如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 multiset容器时，需手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>multiset 容器类模板的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt;,        // 指定容器内部的排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt;    // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">multiset</span>;</span></span><br></pre></td></tr></table></figure><p>显然，multiset 类模板有 3 个参数，其中后 2 个参数自带有默认值。值得一提的是，在实际使用中，我们最多只需要使用前 2 个参数即可，第 3 个参数不会用到。</p><h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><p>multiset 容器提供的成员方法，和 set 容器提供的完全一样，如下表所示：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>find(val)</td><td>在 multiset 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 multiset 容器中第一个大于或等于 val 的元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 multiset 容器中第一个大于 val 的元素的迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含所有值为 val 的元素。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 multiset 容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回 multiset 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>insert()</td><td>向 multiset 容器中插入元素。</td></tr><tr><td>erase()</td><td>删除 multiset 容器中存储的指定元素。</td></tr><tr><td>swap()</td><td>交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>本质上和 emplace() 在 multiset 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(val)</td><td>在当前 multiset 容器中，查找值为 val 的元素的个数，并返回。</td></tr></tbody></table><blockquote><p>注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。</p></blockquote><h3 id="创建C-multiset容器的方法"><a href="#创建C-multiset容器的方法" class="headerlink" title="创建C++ multiset容器的方法"></a>创建C++ multiset容器的方法</h3><p>创建 multiset 容器，无疑需要调用 multiset 类模板中的构造函数。值得一提的是，multiset 类模板提供的构造函数，和 set 类模板中提供创建 set 容器的构造函数，是完全相同的。这意味着，创建 set 容器的方式，也同样适用于创建 multiset 容器。</p><p>multiset 类模板中提供了 5 种构造函数，也就代表有 5 种创建 multiset 容器的方式，分别如下。</p><p>1) 调用默认构造函数，创建空的 multiset 容器。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultiset;</span><br></pre></td></tr></table></figure><p>由此就创建好了一个 mymultiset 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。</p><blockquote><p>注意，由于 multiset 容器支持随时向内部添加新的元素，因此创建空 multiset 容器的方法比较常用。</p></blockquote><p>2)除此之外，multiset 类模板还支持在创建 multiset 容器的同时，对其进行初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultiset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br></pre></td></tr></table></figure><p>由此即创建好了包含 3 个 string 元素的 mymultiset 容器。由于其采用默认的<code>std::less&lt;T&gt;</code>规则，因此其内部存储 string 元素的顺序如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure><p>3) multiset 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 multiset 容器的同时，将已有 multiset 容器中存储的所有元素全部复制到新 multiset 容器中。</p><p>例如，在第 2 种方式创建的 mymultiset 容器的基础上，执行如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copymultiset</span><span class="params">(mymultiset)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//std::multiset&lt;std::string&gt; copymultiset = mymultiset;</span></span><br></pre></td></tr></table></figure><p>该行代码在创建 copymultiset 容器的基础上，还会将 mymultiset 容器中存储的所有元素，全部复制给 copymultiset 容器一份。</p><p>另外，C++ 11 标准还为 multiset 类模板新增了移动构造函数，其功能是实现创建新 multiset 容器的同时，利用临时的 multiset 容器为其初始化。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; <span class="title">retMultiset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempmultiset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultiset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copymultiset</span><span class="params">(retMultiset())</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//std::multiset&lt;std::string&gt; copymultiset = retMultiset();</span></span><br></pre></td></tr></table></figure><p>注意，由于 retMultiset() 函数的返回值是一个临时 multiset 容器，因此在初始化 copymultiset 容器时，其内部调用的是 multiset 类模板中的移动构造函数，而非拷贝构造函数。</p><blockquote><p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p></blockquote><p>4) 在第 3 种方式的基础上，multiset 类模板还支持取已有 multiset 容器中的部分元素，来初始化新 multiset 容器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultiset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copymultiset</span><span class="params">(++mymultiset.<span class="built_in">begin</span>(), mymultiset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure><p>以上初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure><p>5) 以上几种方式创建的 multiset 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 multiset 类模板定义中的第 2 个参数，我们完全可以手动修改 multiset 容器中的排序规则。</p><p>下面样例中，使用了 STL 标准库提供的 std::greater&lt;T&gt; 排序方法，作为 multiset 容器内部的排序规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt; &gt; mymultiset&#123;</span><br><span class="line">    <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br></pre></td></tr></table></figure><p>通过选用<code>std::greater&lt;string&gt;</code>降序规则，mymultiset 容器中元素的存储顺序为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; class=&quot;headerlink&quot; title=&quot;set&quot;&gt;&lt;/a&gt;set&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;前面介绍了 map 容器和 multimap 容器，类似地，C++ STL 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联容器。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：关联容器之map和multimap</title>
    <link href="http://yoursite.com/2022/05/05/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bmap%E5%92%8Cmultimap/"/>
    <id>http://yoursite.com/2022/05/05/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bmap%E5%92%8Cmultimap/</id>
    <published>2022-05-05T00:39:42.000Z</published>
    <updated>2022-05-21T10:12:13.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、结构体或类自定义的类型。<a id="more"></a></p><blockquote><p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。</p></blockquote><p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p><p>另外需要注意的是，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p><blockquote><p>前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair&lt;const K, T&gt; 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p></blockquote><p>map 容器定义在 &lt;map&gt; 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 map 容器时，需手动注明 std 命名空间（建议初学者使用）。</p></blockquote><p>map 容器的模板定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                     // 指定排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;    // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>下表出了 map 容器提供的常用成员方法以及各自的功能：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 map 容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>operator[]</td><td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td></tr><tr><td>at(key)</td><td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td></tr><tr><td>insert()</td><td>向 map 容器中插入键值对。</td></tr><tr><td>erase()</td><td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td></tr><tr><td>swap()</td><td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(key)</td><td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table><h3 id="创建C-map容器的几种方法"><a href="#创建C-map容器的几种方法" class="headerlink" title="创建C++ map容器的几种方法"></a>创建C++ map容器的几种方法</h3><p>map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面介绍几种常用的创建 map 容器的方法。</p><p>1) 通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap;</span><br></pre></td></tr></table></figure><p>通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此创建空 map 容器是比较常用的。</p><p>2) 当然在创建 map 容器的同时，也可以进行初始化，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>由此，myMap 容器在初始状态下，就包含有 2 个键值对。</p><p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123;<span class="built_in">std</span>::make_pair(<span class="string">"C语言教程"</span>,<span class="number">10</span>),<span class="built_in">std</span>::make_pair(<span class="string">"STL教程"</span>,<span class="number">20</span>)&#125;;</span><br></pre></td></tr></table></figure><p>3) 除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, int&gt; newMap(myMap);</span><br></pre></td></tr></table></figure><p>由此，通过调用 map 容器的拷贝（复制）构造函数，即可成功创建一个和 myMap 完全一样的 newMap 容器。</p><p>C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。举个例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个会返回临时 map 对象的函数</span></span><br><span class="line">std::map&lt;std::string,int&gt; disMap() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;tempMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, int&gt; newMap(disMap());</span><br></pre></td></tr></table></figure><blockquote><p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p></blockquote><p>4) map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, int&gt; newMap(++myMap.begin(), myMap.end());</span><br></pre></td></tr></table></figure><p>这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {“STL教程”,20} 键值对的容器。</p><p>5) 当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less&lt;T&gt; 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。因此，如下 2 行创建 map 容器的方式，其实是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>以上 2 中创建方式生成的 myMap 容器，其内部键值对排列的顺序为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">"C语言教程"</span>, <span class="number">10</span>&gt;</span><br><span class="line">&lt;<span class="string">"STL教程"</span>, <span class="number">20</span>&gt;</span><br></pre></td></tr></table></figure><p>下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>此时，myMap 容器内部键值对排列的顺序为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">"STL教程"</span>, <span class="number">20</span>&gt;</span><br><span class="line">&lt;<span class="string">"C语言教程"</span>, <span class="number">10</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在某些特定场景中，我们还需要为 map 容器自定义排序规则。</p></blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是前面学习的顺序容器，还是关联容器，要想实现遍历操作，就必须要用到该类型容器的迭代器。当然，map 容器也不例外。</p><p>C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 <code>++p、p++、--p、p--、*p</code> 操作，并且迭代器之间只能使用 <code>==</code> 或者 <code>!=</code> 运算符进行比较。</p><p>值得一提的是，相比顺序容器，map 容器提供了更多的成员方法（如下表所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td></tr></tbody></table><p>上表中多数的成员方法，诸如 begin()、end() 等，在学习顺序容器时已经多次使用过，它们的功能如下图所示：</p><p><img src="/2022/05/05/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bmap%E5%92%8Cmultimap/map-%E8%BF%AD%E4%BB%A3%E5%99%A8.jpg" alt></p><blockquote><p>注意，图中 Ei 表示的是 pair 类对象，即键值对。对于 map 容器来说，每个键值对的键的值都必须保证是唯一的。</p></blockquote><p>1) 下面程序以 begin()/end() 组合为例，演示如何遍历 map 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,&#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 调用 begin()/end() 组合，遍历 map 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myMap.<span class="built_in">begin</span>(); iter != myMap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>2) 除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向迭代器；反之，其功能和 end() 方法相同。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 查找键为 "Java教程" 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">find</span>(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="comment">// 从 iter 开始，遍历 map 容器</span></span><br><span class="line">    <span class="keyword">for</span> (; iter != myMap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>此程序中，创建并初始化的 myMap 容器，默认会根据各键值对中键的值，对各键值对做升序排序，其排序的结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&gt;</span><br></pre></td></tr></table></figure><p>在此基础上，通过调用 find() 方法，我们可以得到一个指向键为 “Java教程” 的键值对的迭代器，由此当使用 for 循环从该迭代器出开始遍历时，就只会遍历到最后 2 个键值对。</p><p>3) 同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p><ul><li>lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；</li><li>upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；</li></ul><p>下面程序演示了它们的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 找到第一个键的值不小于 "Java教程" 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.lower_bound(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lower："</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 找到第一个键的值大于 "Java教程" 的键值对</span></span><br><span class="line">    iter = myMap.upper_bound(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"upper："</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower：Java教程 http://c.biancheng.net/java/</span><br><span class="line">upper：STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><blockquote><p>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</p></blockquote><p>4) equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p><p>显然，equal_range(key) 成员方法表示的是一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator&gt; myPair = myMap.equal_range(<span class="string">"C语言教程"</span>);</span><br><span class="line">    <span class="comment">// 通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure><blockquote><p>和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，其返回的范围内最多也只有 1 个键值对。</p></blockquote><h3 id="map获取键对应值的几种方法"><a href="#map获取键对应值的几种方法" class="headerlink" title="map获取键对应值的几种方法"></a>map获取键对应值的几种方法</h3><p>我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p><blockquote><p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p></blockquote><p>庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。</p><p>1) map 类模板中对<code>[]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">string</span> cValue = myMap[<span class="string">"C语言教程"</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cValue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure><p>可以看到，在第 11 行代码中，通过指定键的值为 “C语言教程”，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。</p><p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;myMap;</span><br><span class="line">    <span class="keyword">int</span> cValue = myMap[<span class="string">"C语言教程"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">" "</span>&lt;&lt; i-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言教程 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>显然，对于空的 myMap 容器来说，其内部没有以 “C语言教程” 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个<code>&lt;&quot;C语言教程&quot;,0&gt;</code>键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）。</p><p>实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;myMap;</span><br><span class="line">    myMap[<span class="string">"STL教程"</span>]=<span class="string">"http://c.biancheng.net/java/"</span>;</span><br><span class="line">    myMap[<span class="string">"Python教程"</span>] = <span class="string">"http://c.biancheng.net/python/"</span>;</span><br><span class="line">    myMap[<span class="string">"STL教程"</span>] = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>注意，程序中第 9 行代码已经为 map 容器添加了一个以 “STL教程” 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。</p><p>2) 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMap.at(<span class="string">"C语言教程"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面一行代码会引发 out_of_range 异常</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; myMap.at("Python教程") &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure><p>程序第 11 行代码处，通过 myMap 容器调用 at() 成员方法，可以成功找到键为 “C语言教程” 的键值对，并返回该键对应的值；而第 13 行代码，由于当前 myMap 容器中没有以 “Python教程” 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。</p><p>3) 除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">map</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt;::iterator myIter = myMap.<span class="built_in">find</span>(<span class="string">"C语言教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myIter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; myIter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure><blockquote><p>注意，此程序中如果 find() 查找失败，会导致第 12 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。</p></blockquote><p>4) 如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myMap.<span class="built_in">begin</span>(); iter != myMap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="comment">// 调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (!iter-&gt;first.compare(<span class="string">"C语言教程"</span>)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure><blockquote><p>本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，更推荐使用 at() 成员方法，因为该方法既简单又安全。</p></blockquote><h3 id="map-insert-插入数据的4种方式"><a href="#map-insert-插入数据的4种方式" class="headerlink" title="map insert()插入数据的4种方式"></a>map insert()插入数据的4种方式</h3><p>前面讲过，C++ STL map 类模板中对<code>[]</code>运算符进行了重载，即根据使用场景的不同，借助<code>[]</code>运算符可以实现不同的操作。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 获取已存储键值对中，指定键对应的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymap[<span class="string">"STL教程"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 向 map 容器添加新键值对</span></span><br><span class="line">    mymap[<span class="string">"Python教程"</span>] = <span class="string">"http://c.biancheng.net/python/"</span>;</span><br><span class="line">    <span class="comment">// 修改 map 容器已存储键值对中，指定键对应的值</span></span><br><span class="line">    mymap[<span class="string">"STL教程"</span>] = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>可以看到，当操作对象为 map 容器中已存储的键值对时，则借助 [ ] 运算符，既可以获取指定键对应的值，还能对指定键对应的值进行修改；反之，若 map 容器内部没有存储以 [ ] 运算符内指定数据为键的键值对，则使用 [ ] 运算符会向当前 map 容器中添加一个新的键值对。</p><p>实际上，除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p><p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</p><p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p><p>1) 无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、引用传递一个键值对</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">// 2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> (<span class="title">P</span>&amp;&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure><p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li></ul><blockquote><p>以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.insert(STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入失败样例</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">1</span>&gt;</span><br><span class="line">ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, <span class="number">1</span>&gt;</span><br><span class="line">ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><p>从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：</p><ul><li>对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量。</li><li>对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 “STL教程” 的键值对和值为 0 的 bool 变量。</li></ul><p>另外，在程序中的第 22 行代码，还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 pair 类模板的构造函数</span></span><br><span class="line">ret = mymap.insert(pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123; <span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span> &#125;);</span><br><span class="line"><span class="comment">// 调用 make_pair() 函数</span></span><br><span class="line">ret = mymap.insert(make_pair(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>));</span><br></pre></td></tr></table></figure><p>2) 除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">iterator</span> <span class="title">insert</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">P</span>&amp;&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure><p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p><ul><li>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</li><li>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span> &#125;;</span><br><span class="line">    <span class="comment">// 指定要插入的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.insert(it, STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter1-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.insert(it, <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter2-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.insert(it, <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter3-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</p><p>3) insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">insert</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合<code>&lt;first,last&gt;</code>可以表示某 map 容器中的指定区域。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;copymap;</span><br><span class="line">    <span class="comment">// 指定插入区域</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.insert(first, last);</span><br><span class="line">    <span class="comment">// 遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java教程 http://c.biancheng.net/java/p</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>此程序中，&lt;first,last&gt; 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。</p><p>4) 除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，vali 都表示的是键值对变量。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空的 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap;</span><br><span class="line">    <span class="comment">// 向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    mymap.insert(&#123; &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                   &#123; <span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span> &#125;,</span><br><span class="line">                   &#123; <span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span> &#125; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><h3 id="map-emplace-和emplace-hint-方法"><a href="#map-emplace-和emplace-hint-方法" class="headerlink" title="map emplace()和emplace_hint()方法"></a>map emplace()和emplace_hint()方法</h3><p>学习 map insert() 方法时提到，C++ STL map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。</p><blockquote><p>值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高。</p></blockquote><p>1) 和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">emplace</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li><li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li></ul><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymap;</span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.emplace(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    ret = mymap.emplace(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 失败插入的样例</span></span><br><span class="line">    ret = mymap.emplace(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">1</span>&gt;</span><br><span class="line"><span class="number">2</span>、ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, <span class="number">1</span>&gt;</span><br><span class="line"><span class="number">3</span>、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p><p>2) emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">iterator</span> <span class="title">emplace_hint</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p><ol><li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li><li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li></ol><p>下面程序演示 emplace_hint() 方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymap;</span><br><span class="line">    <span class="comment">// 指定在 map 容器插入键值对</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter = mymap.emplace_hint(mymap.<span class="built_in">begin</span>(),<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    iter = mymap.emplace_hint(mymap.<span class="built_in">begin</span>(), <span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 插入失败样例</span></span><br><span class="line">    iter = mymap.emplace_hint(mymap.<span class="built_in">begin</span>(), <span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p><hr><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在掌握 C++ STL map 容器的基础上，本节介绍一个和 map 相似的关联容器，即 multimap 容器。</p><p>所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。</p><p>和 map 容器一样，实现 multimap 容器的类模板也定义在&lt;map&gt;头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>multimap 容器类模板的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                   // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,                                     // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                   // 指定排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;  // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">multimap</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，multimap 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p><h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 multimap 容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>insert()</td><td>向 multimap 容器中插入键值对。</td></tr><tr><td>erase()</td><td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(key)</td><td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。</td></tr></tbody></table><p>和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p><blockquote><p>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此上表中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。</p></blockquote><h3 id="创建C-multimap容器的方法"><a href="#创建C-multimap容器的方法" class="headerlink" title="创建C++ multimap容器的方法"></a>创建C++ multimap容器的方法</h3><p>multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。</p><p>1) 通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultimap;</span><br></pre></td></tr></table></figure><p>2) 当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化 multimap 容器</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>注意，使用此方式初始化 multimap 容器时，其底层会先将每一个<code>{key, value}</code>创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</p><p>实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 pair 类模板的构造函数来生成各个pair类型的键值对</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymultimap&#123;</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123; <span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123; <span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用 make_pair() 函数，生成键值对元素</span></span><br><span class="line"><span class="comment">// 创建并初始化 multimap 容器</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymultimap&#123;</span><br><span class="line">    make_pair(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>),</span><br><span class="line">    make_pair(<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>),</span><br><span class="line">    make_pair(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3) 除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; newmultimap(mymultimap);</span><br></pre></td></tr></table></figure><p>由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。</p><p>在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个会返回临时 multimap 对象的函数</span></span><br><span class="line">multimap&lt;string, string&gt; dismultimap() &#123;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;tempmultimap&#123; &#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,&#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 调用 multimap 类模板的移动构造函数创建 newMultimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt; newmultimap(dismultimap());</span><br></pre></td></tr></table></figure><p>上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。</p><blockquote><p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p></blockquote><p>4) multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化 multimap 容器</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(++mymultimap.<span class="built_in">begin</span>(), mymultimap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器。</p><p>5) 前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为<code>std::less&lt;T&gt;</code>，这意味着以下 2 种创建 multimap 容器的方式是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mymultimap&#123; &#123;<span class="string">'a'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'b'</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">char</span>&gt;&gt; mymultimap&#123; &#123;<span class="string">'a'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'b'</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>mymultimap 容器中键值对的存储顺序为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a,<span class="number">1</span>&gt;</span><br><span class="line">&lt;b,<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p>下面程序利用了 STL 模板库提供的<code>std::greater&lt;T&gt;</code>排序函数，实现令 multimap 容器对存储的键值对做降序排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">char</span>&gt;&gt; mymultimap&#123; &#123;<span class="string">'a'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'b'</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>其内部键值对的存储顺序为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;b,<span class="number">2</span>&gt;</span><br><span class="line">&lt;a,<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在某些特定场景中，我们还可以为 multimap 容器自定义排序规则。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map&quot;&gt;&lt;/a&gt;map&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、结构体或类自定义的类型。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：关联容器</title>
    <link href="http://yoursite.com/2022/05/04/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2022/05/04/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2022-05-04T02:09:12.000Z</published>
    <updated>2022-05-21T07:19:01.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h3><p>顺序容器存储的都是 C++ 基本数据类型，而关联容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。<a id="more"></a></p><blockquote><p>弃用顺序容器，转而选用关联容器存储元素，往往就是看中了关联容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p></blockquote><p>也就是说，使用关联容器存储的元素，都是一个一个的“键值对”（ &lt;key,value&gt; ），这是和顺序容器最大的不同。除此之外，顺序容器中存储的元素默认都是未经过排序的，而使用关联容器存储的元素，默认会根据各元素的键值的大小做升序排序。</p><p>关联容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种数据结构来组织和存储各个键值对。</p><h4 id="关联容器种类"><a href="#关联容器种类" class="headerlink" title="关联容器种类"></a>关联容器种类</h4><p>C++ STL 标准库提供了 4 种关联容器，分别为 map、set、multimap、multiset，其各自的特点如下表所示：</p><table><thead><tr><th>关联式容器名称</th><th>特点</th></tr></thead><tbody><tr><td>map</td><td>定义在 &lt;map&gt; 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less&lt;T&gt;）。</td></tr><tr><td>set</td><td>定义在 &lt;set&gt; 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less&lt;T&gt;）。</td></tr><tr><td>multimap</td><td>定义在 &lt;map&gt; 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</td></tr><tr><td>multiset</td><td>定义在 &lt;set&gt; 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</td></tr></tbody></table><blockquote><p>除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但哈希容器底层采用的是哈希表，而不是红黑树。</p></blockquote><h3 id="pair-用法详解"><a href="#pair-用法详解" class="headerlink" title="pair 用法详解"></a>pair 用法详解</h3><p>我们知道，关联容器存储的是“键值对”形式的数据，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&gt;</span><br></pre></td></tr></table></figure><p>如上所示，每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）。</p><blockquote><p>注意，基于各个关联容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联容器存储，否则就要选用 map 或者 multimap 关联容器。</p></blockquote><p>考虑到“键值对”并不是普通类型数据，C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素&lt;first, second&gt;。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p><p>注意，pair 类模板定义在&lt;utility&gt;头文件中，所以在使用该类模板之前，需引入此头文件。</p><p>1) 在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 默认构造函数，即创建空的 pair 对象</span></span><br><span class="line">pair();</span><br><span class="line"><span class="comment">// 2) 直接使用 2 个元素初始化成 pair 对象</span></span><br><span class="line">pair (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line"><span class="comment">// 3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span></span><br><span class="line">template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</span><br></pre></td></tr></table></figure><p>在 C++ 11 标准中，在引入右值引用的基础上，pair 类模板中又增添了如下 2 个构造函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4) 移动构造函数</span></span><br><span class="line">template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</span><br><span class="line"><span class="comment">// 5) 使用右值引用参数，创建 pair 对象</span></span><br><span class="line">template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</span><br></pre></td></tr></table></figure><p>除此之外，C++ 11 标准中 pair 类模板还新增加了如下一种构造函数：<code>pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);</code>，但该构造 pair 类模板的方式很少用到。</p><p>下面程序演示了以上几种创建 pair 对象的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair2(<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair3(pair2);</span><br><span class="line">    <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4(make_pair(<span class="string">"C++教程"</span>, <span class="string">"http://c.biancheng.net/cplus/"</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair5(<span class="built_in">string</span>(<span class="string">"Python教程"</span>), <span class="built_in">string</span>(<span class="string">"http://c.biancheng.net/python/"</span>));  </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair3: "</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair4: "</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair5: "</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair1: <span class="number">0</span></span><br><span class="line">pair2: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair3: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair4: C++教程 http://c.biancheng.net/cplus/</span><br><span class="line">pair5: Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure><p>上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 &lt;utility&gt; 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（是一个临时对象）作为参数传递给 pair() 构造函数时，其调用的是移动构造函数，而不是拷贝构造函数。</p><p>在上面程序的基础上，C++ 11 还允许我们手动为 pair1 对象赋值，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair1.first = <span class="string">"Java教程"</span>;</span><br><span class="line">pair1.second = <span class="string">"http://c.biancheng.net/java/"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"new pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new pair1: Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure><p>同时，上面程序中 pair4 对象的创建过程，还可以写成如下形式，它们是完全等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4 = make_pair(<span class="string">"C++教程"</span>, <span class="string">"http://c.biancheng.net/cplus/"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pair4: "</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>2) <code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 <code>&lt;、&lt;=、&gt;、&gt;=、==、!=</code> 这 6 个运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。</p><blockquote><p>注意，对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性，同时编译器提示没有相匹配的运算符，即找不到合适的重载运算符。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">"STL教程"</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">"C++教程"</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3(<span class="string">"C++教程"</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair != pair2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2 != pair3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair != pair2</span><br><span class="line">pair2 != pair3</span><br></pre></td></tr></table></figure><p>3) 最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">"pair"</span>, <span class="number">10</span>);                   </span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">"pair2"</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.swap(pair2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair1: pair2 <span class="number">20</span></span><br><span class="line">pair2: pair <span class="number">10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;关联容器概述&quot;&gt;&lt;a href=&quot;#关联容器概述&quot; class=&quot;headerlink&quot; title=&quot;关联容器概述&quot;&gt;&lt;/a&gt;关联容器概述&lt;/h3&gt;&lt;p&gt;顺序容器存储的都是 C++ 基本数据类型，而关联容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>《小王子》语录</title>
    <link href="http://yoursite.com/2022/05/03/%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E8%AF%AD%E5%BD%95/"/>
    <id>http://yoursite.com/2022/05/03/%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E8%AF%AD%E5%BD%95/</id>
    <published>2022-05-03T03:43:56.000Z</published>
    <updated>2022-05-04T01:36:34.453Z</updated>
    
    <content type="html"><![CDATA[<ol><li>也许世界上也有五千朵和你一模一样的花，但只有你是我独一无二的玫瑰。</li><li>当你真的喜欢一个人的时候，就会想很多，会很容易办蠢事，说傻话。</li><li>我始终认为一个人可以很天真简单的活下去，必是身边无数人，用更大的代价守护而来的。</li><li>If you want to  make a bond, you are to  take the risk of tearing.（如果你想要与别人制造羁绊，就要承担流泪的风险。）</li><li>爱就是，我想到你的时候，你是你，风吹麦浪是你，忽远忽近的脚步声是你，星星上的话也是你。</li><li>有一天，我看了四十四次日落。你知道的，人在难过的时候就会爱上看日落。</li><li>你在你的玫瑰花上耗费的时间，使得你的玫瑰花变得如此重要。</li><li>如果不去遍历世界，我们就不知道什么是我们精神和情感的寄托。但我们一旦遍历了世界，却发现我们再也无法回到那美好的地方去了。当我们开始寻求，我们就已经失去。而我们不开始寻求，我们根本无法知道这一切是如此可贵。</li><li>爱是能力，被爱亦是能力。</li><li>我和你的相遇，怎么说呢，就像是一颗耀眼的星星通亮了一片荒芜的小宇宙。</li><li>只有用心灵才能看得清事物本质，真正重要的东西是肉眼无法看见的。</li><li>星星发亮是为了让每一个人有一天都能找到属于自己的星星。</li><li>因为是心甘情愿地沉溺，即使死亡也无须被拯救。</li><li>所有的大人都曾经是小孩，虽然，只有少数人记得。</li><li>忘记朋友是一件令人伤心的事情，并不是人人都有朋友的。</li><li>你必须永远对自己所驯服的东西负责。</li><li>如果你驯养了我，我们就会彼此需要。对我来说，你就是我的世界里独一无二的了；我对你来说，也是你的世界里的唯一了。</li></ol><p><img src="/2022/05/03/%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E8%AF%AD%E5%BD%95/%E5%B0%8F%E7%8E%8B%E5%AD%90.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;也许世界上也有五千朵和你一模一样的花，但只有你是我独一无二的玫瑰。&lt;/li&gt;
&lt;li&gt;当你真的喜欢一个人的时候，就会想很多，会很容易办蠢事，说傻话。&lt;/li&gt;
&lt;li&gt;我始终认为一个人可以很天真简单的活下去，必是身边无数人，用更大的代价守护而来的。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：顺序容器之forward_list</title>
    <link href="http://yoursite.com/2022/05/03/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bforward-list/"/>
    <id>http://yoursite.com/2022/05/03/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bforward-list/</id>
    <published>2022-05-03T03:31:04.000Z</published>
    <updated>2022-05-20T09:30:17.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>forward_list 是 C++ 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表。<a id="more"></a>如下图所示：</p><p><img src="/2022/05/03/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bforward-list/1-1.gif" alt></p><p>上图中，H 表示链表的表头。a) 表示单链表，b) 表示双向链表。不难看出，使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过指针来维持。因此，forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。</p><p>另外，由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p><p>那么，既然 forward_list 容器具有和 list 容器相同的特性，list 容器还可以提供更多的功能函数，forward_list 容器有什么存在的必要呢？当然有，forward_list 容器底层使用单链表，也不是一无是处。比如，存储相同个数的同类型元素，单链表耗用的内存空间更少，空间利用率更高，并且对于实现某些操作单链表的执行效率也更高。</p><blockquote><p>效率高是选用 forward_list 而弃用 list 容器最主要的原因，换句话说，只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。</p></blockquote><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>before_begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td></tr><tr><td>begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td></tr><tr><td>end()</td><td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td></tr><tr><td>cbefore_begin()</td><td>和 before_begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，比如 2^32-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td></tr><tr><td>insert_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>erase_after()</td><td>删除容器中某个指定位置或区域内的所有元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice_after()</td><td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>forward_list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><p>下面的样例演示了部分成员函数的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.emplace_front(<span class="number">4</span>); <span class="comment">// &#123;4,1,2,3&#125;</span></span><br><span class="line">    values.emplace_after(values.before_begin(), <span class="number">5</span>); <span class="comment">// &#123;5,4,1,2,3&#125;</span></span><br><span class="line">    values.reverse(); <span class="comment">// &#123;3,2,1,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="和使用forward-list容器相关的函数"><a href="#和使用forward-list容器相关的函数" class="headerlink" title="和使用forward_list容器相关的函数"></a>和使用forward_list容器相关的函数</h4><p>我们知道，forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 &lt;iterator&gt; 中的 distance() 函数。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="built_in">std</span>::distance(<span class="built_in">std</span>::<span class="built_in">begin</span>(my_words), <span class="built_in">std</span>::<span class="built_in">end</span>(my_words));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>并且，forward_list 容器迭代器的移动除了使用 <code>++</code> 运算符单步移动，还能使用 advance() 函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.<span class="built_in">begin</span>();</span><br><span class="line">    advance(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="forward-list-容器的创建"><a href="#forward-list-容器的创建" class="headerlink" title="forward_list 容器的创建"></a>forward_list 容器的创建</h3><p>由于 forward_list 容器以模板类 forward_list&lt;T&gt;（T 为存储元素的类型）的形式被包含在 <forward_list> 头文件中，并定义在 std 命名空间中。因此，在使用该容器之前，代码中需包含下面两行代码：</forward_list></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>std 命名空间也可以在使用 forward_list 容器时额外注明，两种方式都可以。</p></blockquote><p>创建 forward_list 容器的方式，大致分为以下 5 种。</p><p>1) 创建一个没有任何元素的空 forward_list 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values;</span><br></pre></td></tr></table></figure><p>由于 forward_list 容器在创建后也可以添加元素，因此这种创建方式很常见。</p><p>2) 创建一个包含 n 个元素的 forward_list 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。</p><p>3) 创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如此就创建了一个包含 10 个元素并且值都为 5 的 values 容器。</p><p>4) 在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p><p>5) 通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 forward_list 容器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建forward_list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 拷贝其它类型的容器，创建forward_list容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(arr.<span class="built_in">begin</span>()+<span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;forward_list 是 C++ 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：顺序容器之list</title>
    <link href="http://yoursite.com/2022/05/02/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/"/>
    <id>http://yoursite.com/2022/05/02/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/</id>
    <published>2022-05-02T01:38:26.000Z</published>
    <updated>2022-05-21T01:59:53.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>STL list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。<a id="more"></a>下图展示了 list 双向链表容器是如何存储元素的：</p><p><img src="/2022/05/02/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/pic1.jpg" alt></p><p>可以看到，list 容器中各个元素的前后顺序是靠指针来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p><p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为O(1)），并且在 list 容器中移动元素，也比其它容器的效率高。</p><p>使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持<code>容器对象名[6]</code>这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p><blockquote><p>实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</p></blockquote><p>list 容器以模板类 list&lt;T&gt;（T 为存储元素的类型）的形式在&lt;list&gt;头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。</p></blockquote><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素。</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素。</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素。</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><h3 id="list容器的创建"><a href="#list容器的创建" class="headerlink" title="list容器的创建"></a>list容器的创建</h3><p>根据不同的使用场景，有以下 5 种创建 list 容器的方式供选择。</p><p>1) 创建一个没有任何元素的空 list 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values;</span><br></pre></td></tr></table></figure><p>和空 array 容器不同，空的 list 容器在创建之后仍可以添加元素，因此创建 list 容器的方式很常用。</p><p>2) 创建一个包含 n 个元素的 list 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int 类型的默认值为 0）。</p><p>3) 创建一个包含 n 个元素的 list 容器，并为每个元素指定初始值。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如此就创建了一个包含 10 个元素并且值都为 5 的 values 容器。</p><p>4) 在已有 list 容器的情况下，通过拷贝该容器可以创建新的 list 容器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p><p>5) 通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 list 容器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 拷贝其它类型的容器，创建 list 容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">alues</span><span class="params">(arr.<span class="built_in">begin</span>()+<span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>;<span class="comment">// 拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>只有运用迭代器，才能访问 list 容器中存储的各个元素。list 模板类提供了如下表所示的这些迭代器函数：</p><table><thead><tr><th>迭代器函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器（正向迭代器）。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。（正向迭代器）。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，正向迭代器增加了 const 属性，即不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，正向迭代器增加了 const 属性，即不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，反向迭代器增加了 const 属性，即不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，反向迭代器增加了 const 属性，即不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 list 容器。即当操作对象为 list 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p><p>这些成员函数通常是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p><p>前面章节已经详细介绍了 array、vector、deque 容器的迭代器，和它们相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 <code>++p1</code>、 <code>p1++</code>、 <code>p1--</code>、 <code>p1++</code>、 <code>*p1</code>、 <code>p1==p2</code> 以及 <code>p1!=p2</code> 运算符，但不支持以下操作（其中 i 为整数）：</p><ul><li><code>p1[i]</code>：不能通过下标访问 list 容器中指定位置处的元素。</li><li><code>p1-=i</code>、<code>p1+=i</code>、<code>p1+i</code>、<code>p1-i</code>：双向迭代器 p1 不支持使用 <code>-=、+=、+、-</code> 运算符。</li><li><code>p1&lt;p2</code>、<code>p1&gt;p2</code>、<code>p1&lt;=p2</code>、<code>p1&gt;=p2</code>：双向迭代器 p1、p2 不支持使用 <code>&lt;、 &gt;、 &lt;=、 &gt;=</code> 比较运算符。</li></ul><p>下面这个程序演示了如何使用迭代器遍历 list 容器中的各个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>,<span class="string">':'</span>,<span class="string">'/'</span>,<span class="string">'/'</span>,<span class="string">'c'</span>,<span class="string">'.'</span>,<span class="string">'b'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'c'</span>,<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'n'</span>,<span class="string">'g'</span>,<span class="string">'.'</span>,<span class="string">'n'</span>,<span class="string">'e'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用begin()/end()迭代器函数对输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用 rbegin()/rend()迭代器函数输出 lsit 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::reverse_iterator it = values.rbegin(); it != values.rend();++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net</span><br><span class="line">ten.gnehcnaib.c//:ptth</span><br></pre></td></tr></table></figure><blockquote><p>注意，程序中比较迭代器之间的关系，用的是 != 运算符，因为它不支持 &lt; 等运算符。另外在实际场景中，所有迭代器函数的返回值都可以传给使用 auto 关键字定义的变量，因为编译器可以自行判断出该迭代器的类型。</p></blockquote><p>值得一提的是，list 容器在进行插入（insert()）、接合（splice()）等操作时，都不会造成原有的 list 迭代器失效，甚至进行删除操作，而只有指向被删除元素的迭代器失效，其他迭代器不受任何影响。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>,<span class="string">':'</span>,<span class="string">'/'</span>,<span class="string">'/'</span>,<span class="string">'c'</span>,<span class="string">'.'</span>,<span class="string">'b'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'c'</span>,<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'n'</span>,<span class="string">'g'</span>,<span class="string">'.'</span>,<span class="string">'n'</span>,<span class="string">'e'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line">    <span class="comment">// 创建 begin 和 end 迭代器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator <span class="built_in">begin</span> = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 头部和尾部插入字符 '1'</span></span><br><span class="line">    values.insert(<span class="built_in">begin</span>, <span class="string">'1'</span>);</span><br><span class="line">    values.insert(<span class="built_in">end</span>, <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span>;</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net1</span><br></pre></td></tr></table></figure><p>可以看到，在进行插入操作之后，仍使用先前创建的迭代器遍历容器，虽然程序不会出错，但由于插入位置的不同，可能会遗漏新插入的元素。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>不同于之前学过的 STL 容器，访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。</p><blockquote><p>list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。</p></blockquote><p>1) 通过 front() 和 back() 成员函数，可以分别获得 list 容器中第一个元素和最后一个元素的引用形式。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> &amp;first = mylist.front();</span><br><span class="line">    <span class="keyword">int</span> &amp;last = mylist.back();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">" "</span> &lt;&lt; last &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    first = <span class="number">10</span>;</span><br><span class="line">    last = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mylist.front() &lt;&lt; <span class="string">" "</span> &lt;&lt; mylist.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以看到，通过 front() 和 back() 的返回值，我们不仅能分别获取当前 list 容器中的首尾元素，必要时还能修改它们的值。</p><p>2) 除此之外，如果想访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">while</span> (it!=mylist.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++it;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>值得一提的是，对于非 const 类型的 list 容器，迭代器不仅可以访问容器中的元素，也可以对指定元素的值进行修改。</p><blockquote><p>当然，对于修改容器指定元素的值，list 模板类提供有专门的成员函数 assign()。</p></blockquote><h3 id="添加-插入元素"><a href="#添加-插入元素" class="headerlink" title="添加/插入元素"></a>添加/插入元素</h3><p>list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：</p><ul><li>push_front()：向 list 容器首个元素前添加新元素；</li><li>push_back()：向 list 容器最后一个元素后添加新元素；</li><li>emplace_front()：在容器首个元素前直接生成新的元素；</li><li>emplace_back()：在容器最后一个元素后直接生成新的元素；</li><li>emplace()：在容器的指定位置直接生成新的元素；</li><li>insert()：在指定位置插入新元素；</li><li>splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。</li></ul><p>以上这些成员方法中，除了 insert() 和 splice() 方法有多种语法格式外，其它成员方法都仅有 1 种语法格式。下面程序演示了它们的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.push_front(<span class="number">0</span>);<span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line">    values.push_back(<span class="number">4</span>); <span class="comment">//&#123;0,1,2,3,4&#125;</span></span><br><span class="line">    values.emplace_front(<span class="number">-1</span>);<span class="comment">//&#123;-1,0,1,2,3,4&#125;</span></span><br><span class="line">    values.emplace_back(<span class="number">5</span>);  <span class="comment">//&#123;-1,0,1,2,3,4,5&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// emplace(pos,value),其中 pos 表示指明位置的迭代器，value为要插入的元素值</span></span><br><span class="line">    values.emplace(values.<span class="built_in">end</span>(), <span class="number">6</span>);<span class="comment">//&#123;-1,0,1,2,3,4,5,6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="list-insert-成员方法"><a href="#list-insert-成员方法" class="headerlink" title="list insert()成员方法"></a>list insert()成员方法</h4><p>insert() 成员方法的语法格式有 4 种，如下表所示：</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（例如 array、vector、deque 等）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 { } 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的程序演示了如何使用 insert() 方法向 list 容器中插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    values.insert(values.<span class="built_in">begin</span>() , <span class="number">3</span>); <span class="comment">// &#123;3,1,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    values.insert(values.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;3,1,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    values.insert(values.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;3,1,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    values.insert(values.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;3,1,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>同样是实现插入元素的功能，无论是 push_front()、push_back() 还是 insert()，都有以 emplace 为名且功能和前者相同的成员函数。这是因为，后者是 C++ 11 标准新添加的，在大多数场景中，都可以完全替代前者实现同样的功能。更重要的是，实现同样的功能，emplace 系列方法的执行效率更高。</p><h4 id="list-splice-成员方法"><a href="#list-splice-成员方法" class="headerlink" title="list splice()成员方法"></a>list splice()成员方法</h4><p>和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。</p><p>splice() 成员方法的语法格式有 3 种，如下表所示：</p><table><thead><tr><th>语法格式</th><th>功能</th></tr></thead><tbody><tr><td>void splice (iterator position, list&amp; x);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td></tr><tr><td>void splice (iterator position, list&amp; x, iterator i);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td></tr><tr><td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td></tr></tbody></table><p>我们知道，list 容器底层使用的是链表存储结构，splice() 成员方法移动元素的方式是，将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中。这意味着，当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除。</p><p>下面程序演示了 splice() 成员方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 2 个 list 容器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ++mylist1.<span class="built_in">begin</span>(); <span class="comment">// 指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用第一种语法格式</span></span><br><span class="line">    mylist1.splice(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">// 调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.splice(mylist2.<span class="built_in">begin</span>(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.splice(mylist2.<span class="built_in">begin</span>(), mylist1, mylist1.<span class="built_in">begin</span>(), mylist1.<span class="built_in">end</span>()); <span class="comment">// mylist1:</span></span><br><span class="line">                                                                              <span class="comment">// mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1 包含 "</span> &lt;&lt; mylist1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"个元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2 包含 "</span> &lt;&lt; mylist2.<span class="built_in">size</span>() &lt;&lt; <span class="string">"个元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 mylist2 容器中存储的数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.<span class="built_in">begin</span>(); iter != mylist2.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist1 包含 <span class="number">0</span>个元素</span><br><span class="line">mylist2 包含 <span class="number">7</span>个元素</span><br><span class="line">mylist2:<span class="number">1</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>对 list 容器存储的元素执行删除操作，需要借助该容器模板类提供的成员函数。幸运的是，相比其它 STL 容器模板类，list 模板类提供了更多用来实现此操作的成员函数，如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_front()</td><td>删除位于 list 容器头部的一个元素。</td></tr><tr><td>pop_back()</td><td>删除位于 list 容器尾部的一个元素。</td></tr><tr><td>erase()</td><td>该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。</td></tr><tr><td>clear()</td><td>删除 list 容器存储的所有元素。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一份。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr></tbody></table><p>1) 其中，pop_front()、pop_back() 和 clear() 的用法非常简单，这里仅给出一个样例，不再过多解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 删除当前容器中首个元素</span></span><br><span class="line">    values.pop_front();<span class="comment">//&#123;2,3,4&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 删除当前容器最后一个元素</span></span><br><span class="line">    values.pop_back();<span class="comment">//&#123;2,3&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 清空容器，删除容器中所有的元素</span></span><br><span class="line">    values.<span class="built_in">clear</span>(); <span class="comment">//&#123;&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，可以看到输出结果为“空”。</p><p>2) erase() 成员函数有以下 2 种语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>利用第一种语法格式，可实现删除 list 容器中 position 迭代器所指位置处的元素，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 指向元素 1 的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> del = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 迭代器右移，改为指向元素 2</span></span><br><span class="line">    ++del;</span><br><span class="line">    values.erase(del); <span class="comment">// &#123;1,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>利用第二种语法格式，可实现删除 list 容器中 first 迭代器和 last 迭代器限定区域内的所有元素（包括 first 指向的元素，但不包括 last 指向的元素）。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 指定删除区域的左边界</span></span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    ++first; <span class="comment">// 指向元素 2</span></span><br><span class="line">    <span class="comment">// 指向删除区域的右边界</span></span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    --last; <span class="comment">// 指向元素 5</span></span><br><span class="line">    <span class="comment">// 删除 2、3 和 4</span></span><br><span class="line">    values.erase(first, last);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>3) erase() 成员函数是按照被删除元素所在的位置来执行删除操作，如果想根据元素的值来执行删除操作，可以使用 remove() 成员函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125;;</span><br><span class="line">    values.<span class="built_in">remove</span>(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b d</span><br></pre></td></tr></table></figure><p>4) unique() 函数也有以下 2 种语法格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span></span><br><span class="line">void unique（BinaryPredicate）// 传入一个二元谓词函数</span><br></pre></td></tr></table></figure><p>以上 2 种格式都能实现去除 list 容器中相邻重复的元素，仅保留一份。但第 2 种格式的优势在于，我们能自定义去重的规则，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">demo</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>(first) == <span class="keyword">int</span>(second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4.5</span>,<span class="number">4.6</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除相邻重复的元素，仅保留一份</span></span><br><span class="line">    mylist.unique(); <span class="comment">// &#123;1, 1.2, 3, 4, 4.5, 4.6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// demo 为二元谓词函数，是我们自定义的去重规则</span></span><br><span class="line">    mylist.unique(demo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1.2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4.5</span> <span class="number">4.6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，除了以上一定谓词函数的方式，还可以使用 lamba表达式以及函数对象的方式定义。</p></blockquote><p>可以看到，通过调用无参的 unique()，仅能删除相邻重复（也就是相等）的元素，而通过我们自定义去重的规则，可以更好的满足在不同场景下去重的需求。</p><p>5) 除此之外，通过将自定义的谓词函数（不限定参数个数）传给 remove_if() 成员函数，list 容器中能使谓词函数成立的元素都会被删除。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">15</span>, <span class="number">36</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除 mylist 容器中能够使 lamba 表达式成立的所有元素。</span></span><br><span class="line">    mylist.remove_if([](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> (value &lt; <span class="number">10</span>); &#125;); <span class="comment">// &#123;15 36 17 20 39&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">36</span> <span class="number">17</span> <span class="number">20</span> <span class="number">39</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;STL list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：顺序容器之deque</title>
    <link href="http://yoursite.com/2022/04/29/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/"/>
    <id>http://yoursite.com/2022/04/29/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/</id>
    <published>2022-04-29T01:16:35.000Z</published>
    <updated>2022-05-19T10:25:35.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>deque 是 double-ended queue 的缩写，又称双端队列容器。<a id="more"></a>deque 容器和 vecotr 容器有很多相似之处，比如：</p><ul><li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。</li><li>deque 容器也可以根据需要修改自身的容量和大小。</li></ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶O(1)。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><p>deque 容器以模板类 deque&lt;T&gt;（T 为存储元素的类型）的形式在 &lt;deque&gt; 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>基于 deque 双端队列的特点，该容器包含一些 array、vector 容器都没有的成员函数，如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，比如 2^32-1，我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素。</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移除一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td></tr></tbody></table><blockquote><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p></blockquote><p>和 array、vector 相同，C++ 11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2 个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><h3 id="创建deque容器的几种方式"><a href="#创建deque容器的几种方式" class="headerlink" title="创建deque容器的几种方式"></a>创建deque容器的几种方式</h3><p>创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。</p><p>1) 创建一个没有任何元素的空 deque 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br></pre></td></tr></table></figure><p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p><p>2) 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p><p>3) 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure><p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p><p>4) 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p><p>5) 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），也可以创建一个新容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建 deque 容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于所有类型的容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(arr.<span class="built_in">begin</span>() + <span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝 arr 容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>deque 容器迭代器的类型为随机访问迭代器，deque 模板类提供了下表所示这些成员函数，通过调用这些函数，可以获得表示不同含义的随机访问迭代器。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 deque 容器。即当操作对象为 deque 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p><p>同样的，这些成员函数通常也是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p><blockquote><p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p></blockquote><h4 id="deque容器迭代器的基本用法"><a href="#deque容器迭代器的基本用法" class="headerlink" title="deque容器迭代器的基本用法"></a>deque容器迭代器的基本用法</h4><p>deque 容器迭代器常用来遍历容器中存储的各个元素。</p><p>1) begin() 和 end() 分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 deque 容器并输出其中的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 从容器首元素，遍历至最后一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i &lt; d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>前面提到，STL 还提供有全局的 begin() 和 end() 函数，当操作对象为容器时，它们的功能是上面的 begin()/end() 成员函数一样。例如，将上面程序中的第 8~10 行代码可以用如下代码替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">begin</span>(d); i &lt; <span class="built_in">end</span>(d); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行程序，会发现输出结果和上面一致。</p><p>2) cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = d.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = d.cend();</span><br><span class="line">    <span class="comment">// 常量迭代器不能用来修改容器中的元素值</span></span><br><span class="line">    <span class="comment">//*(first + 1) = 6; // 尝试修改容器中元素 2 的值</span></span><br><span class="line">    <span class="comment">//*(end - 1) = 10; // 尝试修改容器中元素 5 的值</span></span><br><span class="line">    <span class="comment">// 常量迭代器可以用来遍历容器、访问容器中的元素</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>程序中，由于 first 和 end 都是常量迭代器，因此第 10、11 行修改容器内元素值的操作都是非法的。</p><p>3) deque 模板类中还提供了 rbegin() 和 rend() 成员函数，它们分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又常称为反向迭代器。</p><blockquote><p>需要注意的是，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p></blockquote><p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.rbegin(); i &lt; d.rend(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>4) crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型迭代器，不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="deque容器迭代器的使用注意事项"><a href="#deque容器迭代器的使用注意事项" class="headerlink" title="deque容器迭代器的使用注意事项"></a>deque容器迭代器的使用注意事项</h4><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p><p>例如，如下代码中注释部分是错误的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//*first = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于空的 deque 容器来说，可以通过 push_back()、push_front() 或者 resize() 成员函数实现向（空）deque 容器中添加元素。</p></blockquote><p>除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 添加元素，会导致 first 失效</span></span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中第 12 行代码，会导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。</p><blockquote><p>在对容器做添加元素的操作之后，如果仍需要使用之前以创建好的迭代器，为了保险起见，一定要重新生成。</p></blockquote><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>1) 和 array、vector 容器一样，可以采用普通数组访问存储元素的方式，访问 deque 容器中的元素，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改指定下标位置处的元素</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>容器名[n]</code>的这种方式，不仅可以访问容器中的元素，还可以对其进行修改。但需要注意的是，使用此方法需确保下标 n 的值不会超过容器中存储元素的个数，否则会发生越界访问的错误。</p><p>如果想有效地避免越界访问，可以使用 deque 模板类提供的 at() 成员函数，由于该函数会返回容器中指定位置处元素的引用形式，因此利用该函数的返回值，既可以访问指定位置处的元素，如果需要还可以对其进行修改。</p><p>不仅如此，at() 成员函数会自行判定访问位置是否越界，如果越界则抛出<code>std::out_of_range</code>异常。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    d.at(<span class="number">1</span>) = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这条语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; d.at(10) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可能会有这样一个疑问，即为什么 deque 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单：因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>2) 除此之外，deque 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回容器中第一个和最后一个元素的引用，通过利用它们的返回值，可以访问（甚至修改）容器中的首尾元素。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    deque&lt;int&gt; d&#123; 1,2,3,4,5 &#125;;</span><br><span class="line">    cout &lt;&lt; &quot;deque 首元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;deque 尾元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 修改首元素</span><br><span class="line">    d.front() &#x3D; 10;</span><br><span class="line">    cout &lt;&lt; &quot;deque 新的首元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 修改尾元素</span><br><span class="line">    d.back() &#x3D; 20;</span><br><span class="line">    cout &lt;&lt; &quot;deque 新的尾元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque 首元素为：<span class="number">1</span></span><br><span class="line">deque 尾元素为：<span class="number">5</span></span><br><span class="line">deque 新的首元素为：<span class="number">10</span></span><br><span class="line">deque 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure><p>3) 注意，和 vector 容器不同，deque 容器没有提供 data() 成员函数，同时 deque 容器在存储元素时，也无法保证其会将元素存储在连续的内存空间中，因此尝试使用指针去访问 deque 容器中指定位置处的元素，是非常危险的。</p><p>4) 另外，结合 deque 模板类中和迭代器相关的成员函数，可以实现遍历 deque 容器中指定区域元素的方法。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 从元素 2 开始遍历</span></span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历至 5 结束（不包括 5）</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = d.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>deque 容器中，无论是添加元素还是删除元素，都只能借助 deque 模板类提供的成员函数。下表中罗列的是所有和添加或删除容器内元素相关的 deque 模板类中的成员函数。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的一个元素。</td></tr><tr><td>push_front()</td><td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部。</td></tr><tr><td>pop_front()</td><td>移除容器尾部的一个元素。</td></tr><tr><td>emplace_back()</td><td>C++11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td></tr><tr><td>emplace_front()</td><td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td></tr><tr><td>insert()</td><td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置。</td></tr><tr><td>emplace()</td><td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程。</td></tr><tr><td>erase()</td><td>移除一个元素或某一区域内的多个元素。</td></tr><tr><td>clear()</td><td>删除容器中所有的元素。</td></tr></tbody></table><blockquote><p>在实际应用中，常用 emplace()、emplace_front() 和 emplace_back() 分别代替 insert()、push_front() 和 push_back()。</p></blockquote><p>以上这些成员函数中，除了 insert() 函数的语法格式比较多，其他函数都只有一种用法（erase() 有 2 种语法格式），下面这段程序演示了它们的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="comment">// 调用push_back()向容器尾部添加数据。</span></span><br><span class="line">    d.push_back(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 调用pop_back()移除容器尾部的一个数据。</span></span><br><span class="line">    d.pop_back(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 调用push_front()向容器头部添加数据。</span></span><br><span class="line">    d.push_front(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 调用pop_front()移除容器头部的一个数据。</span></span><br><span class="line">    d.pop_front(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 调用 emplace 系列函数，向容器中直接生成数据。</span></span><br><span class="line">    d.emplace_back(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    d.emplace_front(<span class="number">3</span>); <span class="comment">// &#123;3,2&#125;</span></span><br><span class="line">    <span class="comment">// emplace() 需要 2 个参数，第一个为指定插入位置的迭代器，第二个是插入的值。</span></span><br><span class="line">    d.emplace(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// &#123;3,4,2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// erase()可以接受一个迭代器表示要删除元素所在位置</span></span><br><span class="line">    <span class="comment">// 也可以接受 2 个迭代器，表示要删除元素所在的区域。</span></span><br><span class="line">    d.erase(d.<span class="built_in">begin</span>()); <span class="comment">// &#123;4,2&#125;</span></span><br><span class="line">    d.erase(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()); <span class="comment">// &#123;&#125;，等同于 d.clear()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>这里重点讲一下 insert() 函数的用法。insert() 函数的功能是在 deque 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示：</p><table><thead><tr><th>语法格式</th><th>功能</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的程序演示了 insert() 函数的这几种用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="emplace系列函数的优势"><a href="#emplace系列函数的优势" class="headerlink" title="emplace系列函数的优势"></a>emplace系列函数的优势</h4><p>有关 emplace()、emplace_front() 和 emplace_back() 分别和 insert()、push_front() 和 push_back() 在运行效率上的对比，可以通过下面的程序体现出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// emplace和insert</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// emplace_front和push_front</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo3;</span><br><span class="line">    demo3.emplace_front(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo4;</span><br><span class="line">    demo4.push_front(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// emplace_back()和push_back()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo5;</span><br><span class="line">    demo5.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo6;</span><br><span class="line">    demo6.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace_front:</span><br><span class="line">调用构造函数</span><br><span class="line">push_front:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>可以看到，相比和它同功能的函数，emplace 系列函数都只调用了构造函数，而没有调用移动构造函数，这无疑提高了代码的运行效率。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;deque 是 double-ended queue 的缩写，又称双端队列容器。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：顺序容器之vector</title>
    <link href="http://yoursite.com/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
    <id>http://yoursite.com/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/</id>
    <published>2022-04-27T02:06:23.000Z</published>
    <updated>2022-05-18T01:59:12.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。<a id="more"></a></p><p>vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为O(1)；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶O(n)。</p><p>vector 容器以类模板 vector&lt;T&gt;（ T 表示存储元素的类型）的形式定义在 &lt;vector&gt; 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，比如 2^32-1，所以我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>capacity()</td><td>返回当前容量。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>reserve()</td><td>增加容器的容量。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 vector 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>vector 容器还有一个 std::swap(x , y) 非成员函数（其中 x 和 y 是存储相同类型元素的  vector 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><h3 id="创建-vector-容器的几种方式"><a href="#创建-vector-容器的几种方式" class="headerlink" title="创建 vector 容器的几种方式"></a>创建 vector 容器的几种方式</h3><p>创建 vector 容器的方式有很多，大致可分为以下几种。</p><p>1) 如下代码展示了如何创建存储 double 类型元素的一个 vector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure><p>注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。</p><p>在创建好空容器的基础上，还可以像下面这样通过调用 reserve() 成员函数来增加容器的容量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.reserve(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素。</p><blockquote><p>还需注意的是，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector&lt;T&gt; 容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。</p></blockquote><p>2) 除了创建空 vector 容器外，还可以在创建的同时指定初始值以及元素个数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br></pre></td></tr></table></figure><p>这样就创建了一个含有 8 个素数的 vector 容器。</p><p>3) 在创建 vector 容器时，也可以指定元素个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如此，values 容器开始时就有 20 个元素，它们的默认初始值都为 0。</p><blockquote><p>注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。</p></blockquote><p>如果不想用 0 作为默认值，也可以指定一个其它值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。</p><p>值得一提的是，圆括号 () 中的 2 个参数，既可以是常量，也可以用变量来表示，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br></pre></td></tr></table></figure><p>4) 通过存储元素类型相同的其它 vector 容器，也可以创建新的 vector 容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">5</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure><p>由此，value2 容器中也具有 5 个字符 ‘c’。在此基础上，如果不想复制其它容器中所有的元素，可以用一对指针或者迭代器来指定初始值的范围，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>)</span></span>; <span class="comment">// values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">begin</span>(value1),<span class="built_in">std</span>::<span class="built_in">begin</span>(value1)+<span class="number">3</span>)</span></span>; <span class="comment">// value2 将保存&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>vector 支持迭代器的成员函数和功能如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 vector 容器。即当操作对象为 vector 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p><p>这些成员函数的具体功能如下图所示：</p><p><img src="/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/pic1.jpg" alt></p><p>从上图可以看出，这些成员函数通常是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p><blockquote><p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p></blockquote><h4 id="vector容器迭代器的基本用法"><a href="#vector容器迭代器的基本用法" class="headerlink" title="vector容器迭代器的基本用法"></a>vector容器迭代器的基本用法</h4><p>vector 容器迭代器最常用的功能就是遍历访问容器中存储的元素。</p><p>1) 首先来看 begin() 和 end() 成员函数，它们分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 vector 容器并输出其中的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，迭代器对象是由 vector 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样使用它们。比如代码中，在保存了元素值后，使用前缀<code>++</code>运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>当然，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，比如将上面代码中第 7、8 行代码用如下代码替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>2) cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.cend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*first = 10;不能修改元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序第 12 行，由于 first 是 const 类型的迭代器，因此不能用于修改容器中元素的值。</p><p>3) vector 模板类中还提供了 rbegin() 和 rend() 成员函数，分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。也就是说，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p><p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.rend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：5 4 3 2 1</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="vector容器迭代器的独特之处"><a href="#vector容器迭代器的独特之处" class="headerlink" title="vector容器迭代器的独特之处"></a>vector容器迭代器的独特之处</h4><p>和 array 容器不同，vector 容器可以随着存储元素的增加，自行申请更多的存储空间。因此，在创建 vector 对象时，我们可以直接创建一个空的 vector 容器，并不会影响后续使用该容器。</p><p>但这会产生一个问题，即在初始化空的 vector 容器时，不能使用迭代器。也就是说，如下初始化 vector 容器的方法是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="comment">// 初始化的同时输出值</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序可以看到，什么也没有输出。这是因为，对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。</p><blockquote><p>所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。</p></blockquote><p>除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，显示如下信息并崩溃：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0096</span>DFE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">00965560</span></span><br></pre></td></tr></table></figure><p>可以看到，values 容器在增加容量之后，首个元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的。因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0164</span>DBE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">01645560</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><h4 id="访问vector容器中单个元素"><a href="#访问vector容器中单个元素" class="headerlink" title="访问vector容器中单个元素"></a>访问vector容器中单个元素</h4><p>1) 首先，vector 容器可以向普通数组那样访问存储的元素，甚至对指定下标处的元素进行修改，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values[<span class="number">0</span>] = values[<span class="number">1</span>] + values[<span class="number">2</span>] + values[<span class="number">3</span>] + values[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>显然，vector 的索引从 0 开始，这和普通数组一样。通过使用索引，总是可以访问到 vector 容器中现有的元素。</p><p>值得一提的是，<code>容器名[n]</code>这种获取元素的方式，需要确保下标 n 的值不会超过容器的容量（可以通过 capacity() 成员函数获取），否则会发生越界访问的错误。幸运的是，和 array 容器一样，vector 容器也提供了 at() 成员函数，当传给 at() 的索引会造成越界时，会抛出<code>std::out_of_range</code>异常。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values.at(<span class="number">0</span>) = values.at(<span class="number">1</span>) + values.at(<span class="number">2</span>) + values.at(<span class="number">3</span>) + values.at(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这条语句会发生 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; values.at(5) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可能会有这样一个疑问，即为什么 vector 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单：因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>2) 除此之外，vector 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改首元素</span></span><br><span class="line">    values.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改尾元素</span></span><br><span class="line">    values.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values 首元素为：<span class="number">1</span></span><br><span class="line">values 尾元素为：<span class="number">5</span></span><br><span class="line">values 新的首元素为：<span class="number">10</span></span><br><span class="line">values 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure><p>3) 另外，vector 容器还提供了 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 输出容器中第 3 个元素的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中第 2 个元素的值</span></span><br><span class="line">    *(values.data() + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="访问vector容器中多个元素"><a href="#访问vector容器中多个元素" class="headerlink" title="访问vector容器中多个元素"></a>访问vector容器中多个元素</h4><p>如果想访问 vector 容器中多个元素，可以借助 size() 成员函数，该函数可以返回 vector 容器中实际存储的元素个数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不要使用 capacity() 成员函数，因为它返回的是 vector 容器的容量，而不是实际存储元素的个数，这两者是有差别的。</p><p>或者也可以使用基于范围的循环，此方式将会逐个遍历容器中的元素。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以使用 vector 迭代器遍历 vector 容器，这里以 begin()/end() 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里也可以使用 rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 以及全局函数 begin()/end() ，它们都可以实现对容器中元素的访问。</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中，第 7 行代码表示向 values 容器尾部添加一个元素，但由于当前 values 容器是空的，因此新添加的元素 1 无疑成为了容器中首个元素；第 8 行代码实现的功能是在现有元素 1 的后面，添加元素 2。</p><p>运行程序，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back()"></a>emplace_back()</h4><p>该函数是 C++ 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。emplace_back() 成员函数的用法也很简单，这里直接举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.emplace_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们可能会发现，以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？</p><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>为了清楚的了解它们之间的区别，创建一个包含类对象的 vector 容器，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace_back(<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.push_back(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>在此基础上，我们可以尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure><p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p>显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议优先选用 emplace_back()。</p><blockquote><p>注意：由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</p></blockquote><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示：</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><p>emplace() 是 C++ 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p><blockquote><p>强调：emplace() 每次只能插入一个元素，而不是多个。</p></blockquote><p>该函数的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator pos, args...)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p><p>简单的理解 args…，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是：emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), testDemo(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure><blockquote><p>注意，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</p></blockquote><p>可以看到，通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。</p><p>简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐优先使用 emplace()。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>前面提到，无论是向现有 vector 容器中访问元素、添加元素还是插入元素，都只能借助 vector 模板类提供的成员函数，但删除 vector 容器的元素例外，完成此操作除了可以借助本身提供的成员函数，还可以借助一些全局函数。</p><p>基于不同场景的需要，删除 vecotr 容器的元素，可以使用下表中所示的函数（或者函数组合）。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table><p>1) pop_back() 成员函数的用法非常简单，它不需要传入任何的参数，也没有返回值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="comment">// 输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以发现，相比原 demo 容器，新的 demo 容器删除了最后一个元素 5，容器的大小减了 1，但容量没变。</p><p>2) 如果想删除 vector 容器中指定位置处的元素，可以使用 erase() 成员函数，该函数的语法格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(pos)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 为指定被删除元素位置的迭代器，同时该函数会返回一个指向删除元素所在位置下一个位置的迭代器。</p><p>下面的例子演示了 erase() 函数的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除元素 2</span></span><br><span class="line">    <span class="comment">// 输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// iter迭代器指向元素 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>通过结果不能看出，erase() 函数在删除元素时，会将删除位置后续的元素陆续前移，并将容器的大小减 1。</p><p>3) 另外，如果不在意容器中元素的排列顺序，可以结合 swap() 和 pop_back() 函数，同样可以实现删除容器中指定位置元素的目的。</p><blockquote><p>注意，swap() 函数在头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;utility&gt;</code> 中都有定义，使用时引入其中一个即可。</p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    swap(*(<span class="built_in">std</span>::<span class="built_in">begin</span>(demo)+<span class="number">1</span>),*(<span class="built_in">std</span>::<span class="built_in">end</span>(demo)<span class="number">-1</span>));<span class="comment">//等同于 swap(demo[1],demo[4])</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 交换位置后的demo容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出demo 容器中剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>4) 当然，除了删除容器中单个元素，还可以删除容器中某个指定区域内的所有元素，同样可以使用 erase() 成员函数实现。该函数有 2 种基本格式，前面介绍了一种，这里使用另一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 是指定被删除元素区域的迭代器，同时该函数会返回指向此区域之后一个位置的迭代器。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，和删除单个元素一样，删除指定区域内的元素时，也会将该区域后续的元素前移，并缩小容器的大小。</p><p>5) 如果要删除容器中和指定元素值相同的所有元素，可以使用 remove() 函数，该函数定义在 <code>&lt;algorithm&gt;</code> 头文件中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = demo.<span class="built_in">begin</span>(); first &lt; iter;++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>注意，在对容器执行完 remove() 函数之后，由于该函数并没有改变容器原来的大小和容量，因此无法使用之前的方法遍历容器，而是需要向程序中那样，借助 remove() 返回的迭代器完成正确的遍历。</p><blockquote><p>remove() 的实现原理是，在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，直到找到一个非目标元素，即用此元素将最先做标记的位置覆盖掉，同时将此非目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。因此，如果将上面程序中 demo 容器的元素全部输出，得到的结果为 <code>1 4 5 4 3 5</code>。</p></blockquote><p>另外还可以看到，既然通过 remove() 函数删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以使用 erase() 成员函数删掉这些 “无用” 的元素。</p><p>比如，修改上面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    demo.erase(iter, demo.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用。</p></blockquote><p>6) 如果想删除容器中所有的元素，则可以使用 clear() 成员函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">0</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：顺序容器</title>
    <link href="http://yoursite.com/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-04-26T02:35:34.000Z</published>
    <updated>2022-05-14T09:23:31.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h3><p>所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。<a id="more"></a></p><p>顺序容器主要包含以下几类容器：</p><ul><li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值。</li><li>vector&lt;T&gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）。</li><li>deque&lt;T&gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶。</li><li>list&lt;T&gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li>forward_list&lt;T&gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><blockquote><p>注意，其实除此之外，stack 和 queue 本质上也属于顺序容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。</p></blockquote><p>下图说明了各种顺序容器及它们之间的区别：</p><p><img src="/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/pic1.jpg" alt></p><hr><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array 容器是 C++ 11 标准中新增的顺序容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p><p>array 容器以类模板的形式定义在 &lt;array&gt; 头文件，并位于命名空间 std 中，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>在 array&lt;T,N&gt; 类模板中，T 用于指明容器中存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。</p><p>1) array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p><p>2) 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>使用该语句，容器中所有的元素都会被初始化为 0.0。</p><p>3) 当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>另外，在 &lt;array&gt; 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>STL 为 array 容器配备了随机访问迭代器，该类迭代器是功能最强大的迭代器。在 array 容器的模板类中，和随机访问迭代器相关的成员函数如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，则该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，则该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，则该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，则该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准新增的 begin() 和 end() 函数，当操作对象为 array 容器时，也和迭代器有关，其功能分别和上表中的 begin()、end() 成员函数相同。</p><h5 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()/end() 和 cbegin()/cend()"></a>begin()/end() 和 cbegin()/cend()</h5><p>1) array 容器模板类中的 begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p><p>例如，可以在循环中显式地使用迭代器来初始化 values 容器的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        ++h;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，因为当操作对象为 array 容器时，它们和 begin()/end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>这样，容器中的一段元素可以由迭代器指定，这让我们有了对它们使用算法的可能。</p><blockquote><p>需要注意的是，STL 中不是只有 array 容器，当迭代器指向容器中的一个特定元素时，它们不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，它是指向 array 容器还是指向 vector 容器。</p></blockquote><p>2) 除此之外，array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.cend();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 *first 为 const 类型，不能用来修改元素，因此下面的代码错误</span></span><br><span class="line">    <span class="comment">// *first = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="comment">// 可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rbegin-rend-和-crbegin-crend"><a href="#rbegin-rend-和-crbegin-crend" class="headerlink" title="rbegin()/rend() 和 crbegin()/crend()"></a>rbegin()/rend() 和 crbegin()/crend()</h5><p>array 模板类中还提供了 rbegin()/rend() 和 crbegin()/crend() 成员函数，它们每对都可以分别得到指向最一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。也就是说，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能“互换”了。</p><p>反向迭代器用于以逆序的方式处理元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.rend();</span><br><span class="line">    <span class="comment">// 初始化 values 容器为 &#123;5,4,3,2,1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        ++h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序遍历容器，并输出各个元素</span></span><br><span class="line">    first = values.rbegin();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，不仅完成了容器的初始化，还遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/rend() 组合的功能唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><h5 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h5><p>1) 首先，可以通过容器名[]的方式直接访问和使用容器中的元素，这和 C++ 标准数组访问元素的方式相同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这种方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.at(<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2.</span>O*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句实现的功能相同，但当传给 at() 的索引是一个越界值时，程序会抛出 <code>std::out_of_range</code> 异常。因此当需要访问容器中某个指定元素时，建议使用 at()，除非确定索引没有越界。</p><blockquote><p>我们可能会有这样一个疑问，即为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单：因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>2) 除此之外，array 容器还提供了 get&lt;n&gt; 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</p><p>下面代码展示了如何使用 get&lt;n&gt; 模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">string</span>, 5&gt; words&#123; <span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 words[3]，即 "four"</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; endl; // 越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 另外，array 容器还提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的指针。通过该指针，我们可以获得容器中的各个元素，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *( words.data()+<span class="number">1</span>); <span class="comment">// 输出结果为：2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h5><p>1) 我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has no elements.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has "</span> &lt;&lt; values.<span class="built_in">size</span>() &lt;&lt; <span class="string">" elements.\n"</span>;</span><br></pre></td></tr></table></figure><p>然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p><blockquote><p>array 容器之所以提供 empty() 成员函数的原因是因为：对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p></blockquote><p>2) 除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;顺序容器概述&quot;&gt;&lt;a href=&quot;#顺序容器概述&quot; class=&quot;headerlink&quot; title=&quot;顺序容器概述&quot;&gt;&lt;/a&gt;顺序容器概述&lt;/h3&gt;&lt;p&gt;所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：容器与迭代器</title>
    <link href="http://yoursite.com/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-04-25T05:23:19.000Z</published>
    <updated>2022-05-13T10:46:32.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。<a id="more"></a>STL 提供有 3 类标准容器，分别是顺序容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示：</p><table><thead><tr><th align="left">容器种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">顺序容器</td><td align="center">主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td align="left">排序容器</td><td align="center">包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以排序容器在查找时具有非常好的性能。</td></tr><tr><td align="left">哈希容器</td><td align="center">C++ 11 新加入 4 种关联容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是顺序容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p><p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p><p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p><p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p><h4 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h4><p>STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。其中，输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。其他3种迭代器的功能如下所示：</p><ul><li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p></li><li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有前向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 <code>--p</code> 或者 <code>p--</code> 操作（即一次向后移动一个位置）。</p></li><li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p+=i：使得 p 往后移动 i 个元素。</span><br><span class="line">p-=i：使得 p 往前移动 i 个元素。</span><br><span class="line">p+i：返回 p 后面第 i 个元素的迭代器。</span><br><span class="line">p-i：返回 p 前面第 i 个元素的迭代器。</span><br><span class="line">p[i]：返回 p 后面第 i 个元素的引用。</span><br></pre></td></tr></table></figure><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减1）。</p></li></ul><p>下表所示，是 C++ 11 标准中不同容器指定使用的迭代器类型：</p><table><thead><tr><th align="left">容器</th><th align="left">对应的迭代器类型</th></tr></thead><tbody><tr><td align="left">array</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">vector</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">deque</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">list</td><td align="left">双向迭代器</td></tr><tr><td align="left">set / multiset</td><td align="left">双向迭代器</td></tr><tr><td align="left">map / multimap</td><td align="left">双向迭代器</td></tr><tr><td align="left">forward_list</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_map / unordered_multimap</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_set / unordered_multiset</td><td align="left">前向迭代器</td></tr><tr><td align="left">stack</td><td align="left">不支持迭代器</td></tr><tr><td align="left">queue</td><td align="left">不支持迭代器</td></tr></tbody></table><blockquote><p>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</p></blockquote><h4 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h4><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如下表所示：</p><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator  迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator  迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator  迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator  迭代器名;</td></tr></tbody></table><p>值得一提的是，上表中的反向迭代器全称为 “反向迭代器适配器”。</p><p>通过定义以上几种迭代器，就可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</p><blockquote><p>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p></blockquote><h4 id="迭代器实例"><a href="#迭代器实例" class="headerlink" title="迭代器实例"></a>迭代器实例</h4><p>1) 以上对迭代器做了很详细的介绍，下面就以 vector 容器为例，实际感受迭代器的用法和功能。通过前面的学习，我们知道 vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;; <span class="comment">// 初始化v，有10个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">// 像普通数组一样使用vector容器</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;    <span class="comment">// 创建一个正向迭代器，当然，vector也支持其他3种定义迭代器的方式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第二种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)  <span class="comment">// 用 "!=" 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第三种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 "&lt;" 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第四种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        i += <span class="number">1</span>; <span class="comment">// 随机访问迭代器支持 "+=" 的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第二种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第三种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第四种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>2) 再举一个例子，我们知道，list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个list容器 v</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法，因为双向迭代器不支持用 “&lt;” 进行比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p>其实在 C++ 中，数组也是容器，数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器，则 a、a+1、a+2 都是 a 的迭代器。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h3&gt;&lt;p&gt;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="http://yoursite.com/2022/04/25/C-STL/"/>
    <id>http://yoursite.com/2022/04/25/C-STL/</id>
    <published>2022-04-25T04:37:18.000Z</published>
    <updated>2022-04-28T01:19:46.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-STL"><a href="#什么是-STL" class="headerlink" title="什么是 STL"></a>什么是 STL</h3><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 <a id="more"></a></p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 标准库的重要组成部分。如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装。STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等。</p><h3 id="STL-的组成"><a href="#STL-的组成" class="headerlink" title="STL 的组成"></a>STL 的组成</h3><p>通常认为，STL 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的，如下表所示：</p><table><thead><tr><th align="left">STL的组成</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">容器</td><td align="center">一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td></tr><tr><td align="left">算法</td><td align="center">STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 &lt;algorithm&gt; 中，少部分位于头文件 &lt;numeric&gt; 中。</td></tr><tr><td align="left">迭代器</td><td align="center">在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td></tr><tr><td align="left">函数对象</td><td align="center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td></tr><tr><td align="left">适配器</td><td align="center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td></tr><tr><td align="left">内存分配器</td><td align="center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td></tr></tbody></table><p>另外，在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++ 标准中，它们被重新组织为 13 个头文件，分别是：&lt;iterator&gt;、&lt;functional&gt;、&lt;vector&gt;、&lt;deque&gt;、&lt;list&gt;、&lt;queue&gt;、&lt;stack&gt;、&lt;set&gt;、&lt;map&gt;、&lt;algorithm&gt;、&lt;numeric&gt;、&lt;memory&gt;和&lt;utility&gt;。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是-STL&quot;&gt;&lt;a href=&quot;#什么是-STL&quot; class=&quot;headerlink&quot; title=&quot;什么是 STL&quot;&gt;&lt;/a&gt;什么是 STL&lt;/h3&gt;&lt;p&gt;STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++:引用计数</title>
    <link href="http://yoursite.com/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</id>
    <published>2022-01-11T09:43:43.000Z</published>
    <updated>2022-05-04T02:51:22.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是引用计数"><a href="#什么是引用计数" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h3><p>引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：</p><ul><li><p>简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。</p></li><li><p>节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中<strong>string</strong>类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。<a id="more"></a></p></li></ul><h3 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h3><p>使用引用计数实现智能指针的关键是，引用计数应该存在哪里。引用计数应该是某个类对象和其复制对象共享的， 而指针成员恰好有这样的特性， 故可以在类中多声明一个size_t* 的成员，用来表示引用计数。</p><ul><li>构造函数中创建类的新对象时，初始化引用计数为1；</li><li>拷贝构造函数复制指针，并使相应的引用计数增加1；</li><li>赋值操作减少左操作数所指对象的引用计数，增加右操作数所指对象的引用计数；</li><li>析构函数使引用计数减少1，并且当引用计数为1时，释放指针所指向的对象；</li></ul><p><img src="/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>; <span class="keyword">using</span> <span class="built_in">std</span>::ostream; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// string()：构造空的string类对象，既空字符串</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125; <span class="comment">// constructor</span></span><br><span class="line">~HasPtr(); <span class="comment">// 析构函数</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> HasPtr&amp; rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++* use; &#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;); <span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span>* ps; <span class="comment">// ps是一个指针，指向string类型</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span>* use; <span class="comment">// use是一个指针，指向size_t类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数的定义</span></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 如果引用计数为变0</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 释放string内存</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放计数器内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载的定义</span></span><br><span class="line">HasPtr&amp;</span><br><span class="line">HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">++* rhs.use;<span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 如果没有其他用户</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">&#125;</span><br><span class="line">ps = rhs.ps;<span class="comment">// 将数据从rhs拷贝到本对象</span></span><br><span class="line">i = rhs.i;</span><br><span class="line">use = rhs.use;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的定义</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">os &lt;&lt; p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.use;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HasPtr temp;</span><br><span class="line">temp = p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, p) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"temp: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, temp) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr str1(\"copy me\"), str2;\n"</span>;</span><br><span class="line">HasPtr str1("copy me"), str2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr2 = str1;\n"</span>;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nfunc(str1);\n"</span>;</span><br><span class="line">func(str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HasPtr str1(<span class="string">"copy me"</span>), str2;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">1</span></span><br><span class="line">str2: <span class="number">011654E8</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">str2 = str1;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line"></span><br><span class="line">func(str1);</span><br><span class="line">p: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line">temp: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line"></span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是引用计数&quot;&gt;&lt;a href=&quot;#什么是引用计数&quot; class=&quot;headerlink&quot; title=&quot;什么是引用计数&quot;&gt;&lt;/a&gt;什么是引用计数&lt;/h3&gt;&lt;p&gt;引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中&lt;strong&gt;string&lt;/strong&gt;类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>python+selenium实现自动刷新网页</title>
    <link href="http://yoursite.com/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/</id>
    <published>2022-01-06T09:03:52.000Z</published>
    <updated>2022-04-08T04:59:21.671Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。</strong></p><a id="more"></a><hr><p>一、安装 selenium</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>二、下载并导入浏览器驱动</p><p>1、查看Chrome浏览器版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://version</span><br></pre></td></tr></table></figure><p>2、根据版本下载对应浏览器驱动</p><p>下载网址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>3、将下载的驱动放入python安装目录Scripts文件夹下。</p><p>三、示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    driver.refresh()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
</feed>
