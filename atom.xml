<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverpptx&#39;s Blog</title>
  
  <subtitle>黑夜给了我黑色的眼睛，我却用它寻找光明</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-01-09T02:05:23.882Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crossoverpptx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图像归一化</title>
    <link href="http://yoursite.com/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/"/>
    <id>http://yoursite.com/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/</id>
    <published>2023-01-09T01:17:09.000Z</published>
    <updated>2023-01-09T02:05:23.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-图像归一化"><a href="#1-图像归一化" class="headerlink" title="1. 图像归一化"></a>1. 图像归一化</h2><p>图像归一化是指对图像进行了一系列标准的处理变换，使之变换为一固定标准形式的过程，该标准图像称作归一化图像。</p><p>在机器学习中，不同评价指标（即特征向量中的不同特征，就是所述的不同评价指标）往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果。为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。其中，最典型的就是数据的归一化处理。简而言之，归一化的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响。</p><p>在深度学习中，通常在模型训练前都会对图像进行归一化处理，而对图像进行归一化处理是将特征值大小调整到相近的范围，不归一化处理时，如果特征值较大时，梯度值也会较大，特征值较小时，梯度值也会较小。在模型反向传播时，梯度值更新与学习率一样，当学习率较小时，梯度值较小会导致更新缓慢，当学习率较大时，梯度值较大会导致模型不易收敛，因此为了使模型训练收敛平稳，对图像进行归一化操作，把不同维度的特征值调整到相近的范围内，就可以采用统一的学习率加速模型训练。<a id="more"></a></p><h2 id="2-图像归一化的常用方法及Python应用"><a href="#2-图像归一化的常用方法及Python应用" class="headerlink" title="2. 图像归一化的常用方法及Python应用"></a>2. 图像归一化的常用方法及Python应用</h2><h3 id="2-1-Min-Max归一化"><a href="#2-1-Min-Max归一化" class="headerlink" title="2.1 Min-Max归一化"></a>2.1 Min-Max归一化</h3><p>通过遍历图像矩阵中的每一个像素，设定max和min，进行数据的归一化处理，公式如下：</p><script type="math/tex; mode=display">x'=(x-min⁡(x))/(max⁡(x)-min⁡(x))</script><p>（1）线性函数将原始数据用线性化的方法转换到[0,1]的范围，计算结果x’为归一化后的数据，x为原始数据。（2）Min-Max归一化方法比较适用在数值比较集中的情况。<br>（3）缺点：如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量来替代max和min。</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">mn = np.min(gray)</span><br><span class="line">mx = np.max(gray)</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">       norm[i,j] = (gray[i,j] - mn) / (mx - mn)</span><br><span class="line">       <span class="comment">#norm[i,j] = gray[i,j] / 255</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化前后灰度图像矩阵如下所示：</p><p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-1.png" alt></p><p>归一化前后灰度图像对比如下所示：</p><p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-2.png" alt></p><h3 id="2-2-z-score标准化"><a href="#2-2-z-score标准化" class="headerlink" title="2.2 z-score标准化"></a>2.2 z-score标准化</h3><p>z-score标准化公式如下：</p><script type="math/tex; mode=display">x'=(x-μ)/σ</script><p>其中，μ、σ分别为原始数据集的均值和方法。<br>（1）将原始数据集归一化为均值为0、方差1的数据集。<br>（2）该种归一化方式要求原始数据的分布可以近似为高斯分布，否则归一化的效果会变得很糟糕。<br>（3）应用场景：在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，z-score standardization表现更好。</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">x_mean = np.mean(gray)</span><br><span class="line">vari = np.sqrt((np.sum((gray-x_mean)**<span class="number">2</span>))/(h*w))</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">       norm[i,j] = (gray[i,j] - x_mean) / vari</span><br><span class="line">       <span class="comment">#norm[i,j] = gray[i,j] / 127.5 - 1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化前后灰度图像矩阵如下所示：</p><p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-3.png" alt></p><p>归一化前后灰度图像对比如下所示：</p><p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-4.png" alt></p><h3 id="2-3-神经网络归一化"><a href="#2-3-神经网络归一化" class="headerlink" title="2.3 神经网络归一化"></a>2.3 神经网络归一化</h3><p>该归一化方法经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括log，反正切等，需要根据数据分布的情况，决定非线性函数的曲线。</p><h4 id="2-3-1-log对数函数归一化"><a href="#2-3-1-log对数函数归一化" class="headerlink" title="2.3.1 log对数函数归一化"></a>2.3.1 log对数函数归一化</h4><p>y = log10(x)，即以10为底的对数转换函数，对应的归一化方法为：</p><script type="math/tex; mode=display">x' = log10(x)/log10(max)</script><p>其中max表示样本数据的最大值，并且所有样本数据均要大于等于1。</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line">norm = np.log10(gray) / np.log10(gray.max())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化前后灰度图像矩阵如下所示：</p><p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-5.png" alt></p><p>归一化前后灰度图像对比如下所示：</p><p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-6.png" alt></p><h4 id="2-3-2-反正切函数归一化"><a href="#2-3-2-反正切函数归一化" class="headerlink" title="2.3.2 反正切函数归一化"></a>2.3.2 反正切函数归一化</h4><p>对应的归一化方法为：x’ = atan(x)*(2/pi)</p><p>使用这个方法需要注意的是如果想映射的区间为[0,1]，则数据都应该大于等于0，小于0的数据将被映射到[－1,0]区间上。</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line">norm = np.arctan(gray) * (<span class="number">2</span> / np.pi)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化前后灰度图像矩阵如下所示：</p><p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-7.png" alt></p><p>归一化前后灰度图像对比如下所示：</p><p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-8.png" alt></p><h3 id="2-4-L2范数归一化"><a href="#2-4-L2范数归一化" class="headerlink" title="2.4 L2范数归一化"></a>2.4 L2范数归一化</h3><p>定义：特征向量中每个元素均除以向量的范数，即如下公式：</p><script type="math/tex; mode=display">x_i'=x_i/(norm(x))</script><p>向量x(x1,x2,…,xn)的L2范数定义为：</p><script type="math/tex; mode=display">norm(x)=\sqrt(x_1^2+x_2^2+⋯+x_n^2)</script><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">       norm_x = <span class="number">0.0</span> + gray[i,j]**<span class="number">2</span></span><br><span class="line">norm_x = np.sqrt(norm_x)</span><br><span class="line">norm = gray / norm_x</span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化前后灰度图像矩阵如下所示：</p><p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-9.png" alt></p><p>归一化前后灰度图像对比如下所示：</p><p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-10.png" alt></p><h2 id="3-opencv-python中归一化方法的应用"><a href="#3-opencv-python中归一化方法的应用" class="headerlink" title="3. opencv-python中归一化方法的应用"></a>3. opencv-python中归一化方法的应用</h2><p>opencv-python中使用cv2.normalize()函数实现归一化，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.normalize(src[, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]]) → dst</span><br></pre></td></tr></table></figure><p>参数说明：<br>src：输入数组；<br>dst：输出数组，数组的大小和原数组一致；<br>alpha：1.用来规范值。2.规范范围，并且是下限；<br>beta：只用来规范范围并且是上限；<br>norm_type：归一化选择的数学公式类型；<br>dtype：当为负，输出在大小深度通道数都等于输入，当为正，输出只在深度与输入不同，不同的地方由dtype决定；<br>mark：掩码。选择感兴趣区域，选定后只能对该区域进行操作。</p><p>归一化选择的数学公式类型有如下几种：<br>NORM_MINMAX：数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用；<br>NORM_INF：矩阵中绝对值的最大值；<br>NORM_L1：归一化数组的L1-范数(绝对值的和)；<br>NORM_L2：归一化数组的(欧几里德)L2-范数。</p><p>测试代码如下（以NORM_MINMAX为例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line">cv.normalize(gray, norm, alpha=<span class="number">0</span>, beta=<span class="number">1</span>, norm_type=cv.NORM_MINMAX, dtype=cv.CV_32F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># norm = np.uint8(norm*255.0)</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>归一化前后灰度图像矩阵如下所示，可以发现与2.1节Min-Max归一化处理结果一致：</p><p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-11.png" alt></p><p>归一化前后灰度图像对比如下所示：</p><p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-12.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-图像归一化&quot;&gt;&lt;a href=&quot;#1-图像归一化&quot; class=&quot;headerlink&quot; title=&quot;1. 图像归一化&quot;&gt;&lt;/a&gt;1. 图像归一化&lt;/h2&gt;&lt;p&gt;图像归一化是指对图像进行了一系列标准的处理变换，使之变换为一固定标准形式的过程，该标准图像称作归一化图像。&lt;/p&gt;
&lt;p&gt;在机器学习中，不同评价指标（即特征向量中的不同特征，就是所述的不同评价指标）往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果。为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。其中，最典型的就是数据的归一化处理。简而言之，归一化的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响。&lt;/p&gt;
&lt;p&gt;在深度学习中，通常在模型训练前都会对图像进行归一化处理，而对图像进行归一化处理是将特征值大小调整到相近的范围，不归一化处理时，如果特征值较大时，梯度值也会较大，特征值较小时，梯度值也会较小。在模型反向传播时，梯度值更新与学习率一样，当学习率较小时，梯度值较小会导致更新缓慢，当学习率较大时，梯度值较大会导致模型不易收敛，因此为了使模型训练收敛平稳，对图像进行归一化操作，把不同维度的特征值调整到相近的范围内，就可以采用统一的学习率加速模型训练。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>直方图均衡化</title>
    <link href="http://yoursite.com/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/"/>
    <id>http://yoursite.com/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</id>
    <published>2023-01-08T12:53:39.000Z</published>
    <updated>2023-01-08T13:11:58.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-图像直方图"><a href="#1-图像直方图" class="headerlink" title="1. 图像直方图"></a>1. 图像直方图</h2><p>图像直方图，是指对整个图像在灰度范围内的像素值(0-255)统计出现频率次数，据此生成的直方图，称为图像直方图或直方图。直方图反映了图像灰度的分布情况，是图像的统计学特征。也可以说，直方图是图像中像素强度分布的图形表达方式，它统计了每一个强度值所具有的像素个数。</p><h2 id="2-直方图均衡化"><a href="#2-直方图均衡化" class="headerlink" title="2. 直方图均衡化"></a>2. 直方图均衡化</h2><p>直方图均衡化是以累计分布函数为核心，将原始图像灰度直方图从比较集中的某个灰度区间，非线性地映射为在全部灰度范围内的较均匀分布，从而增强对比度。</p><a id="more"></a><p>直方图均衡化的数学原理如下：<br>首先作原始图像灰度的概率直方图, 然后设输入像素灰度值为r<sub>k</sub>，累计分布函数为</p><p><img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-1.png" alt></p><p>其中n<sub>i</sub>为图像中灰度值为r<sub>i</sub>的像素频数，n为图像像素总数。设输出像素灰度值为s<sub>k</sub>，像素范围为s<sub>min</sub>-s<sub>max</sub>。期望输出灰度直方图是均匀分布，即</p><p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-2.png" alt></p><p>令C(s<sub>k</sub>)=C(r<sub>k</sub>)，即得</p><p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-3.png" alt></p><p>所以最终直方图均衡化的点算子为</p><p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-4.png" alt></p><h2 id="3-直方图均衡化的Python实现"><a href="#3-直方图均衡化的Python实现" class="headerlink" title="3. 直方图均衡化的Python实现"></a>3. 直方图均衡化的Python实现</h2><p>根据直方图均衡化的数学原理，用Python实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算累计分布函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span><span class="params">(rk)</span>:</span></span><br><span class="line">    <span class="comment"># 读取图片灰度直方图</span></span><br><span class="line">    <span class="comment"># bins为直方图直方柱的取值向量，hist为bins各取值区间上的频数取值</span></span><br><span class="line">    hist, bins = np.histogram(rk, <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    <span class="comment"># 计算累计分布函数</span></span><br><span class="line">    <span class="keyword">return</span> hist.cumsum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算灰度均衡化映射</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">T</span><span class="params">(rk)</span>:</span></span><br><span class="line">    cdf = C(rk)</span><br><span class="line">    <span class="comment"># 均衡化</span></span><br><span class="line">    cdf = (cdf - cdf.min()) * (<span class="number">255</span> - <span class="number">0</span>) / (cdf.max() - cdf.min()) + <span class="number">0</span></span><br><span class="line">    <span class="comment">#cdf = 255.0 * cdf / cdf[-1]</span></span><br><span class="line">    <span class="keyword">return</span> cdf.astype(<span class="string">'uint8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将二维数字图像矩阵转变为一维向量</span></span><br><span class="line">rk = img.flatten()</span><br><span class="line"><span class="comment"># 原始图像灰度直方图</span></span><br><span class="line">plt.hist(rk, <span class="number">256</span>, [<span class="number">0</span>, <span class="number">255</span>], color = <span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line">imgDst = T(rk)[img]     </span><br><span class="line">plt.hist(imgDst.flatten(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">255</span>], color = <span class="string">'b'</span>)</span><br><span class="line">plt.legend([<span class="string">'Before Equalization'</span>,<span class="string">'Equalization'</span>]) </span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 展示前后对比图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Original Gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(imgDst, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Histogram Equalization'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>均衡前后图像灰度直方图如下所示：</p><p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/3-1.png" alt></p><p>直方图均衡化前后的图像对比如下所示：</p><p><img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/3-2.png" alt></p><h2 id="4-opencv-python中直方图均衡化的应用"><a href="#4-opencv-python中直方图均衡化的应用" class="headerlink" title="4. opencv-python中直方图均衡化的应用"></a>4. opencv-python中直方图均衡化的应用</h2><p>opencv-python中使用cv.equalizeHist函数即可实现直方图均衡化，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst=cv.equalizeHist(src[, dst])</span><br></pre></td></tr></table></figure><blockquote><p>注意：输入需是灰度图像。</p></blockquote><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">dst = cv.equalizeHist(img)</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Original Gray'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Histogram Equalization'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/4.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-图像直方图&quot;&gt;&lt;a href=&quot;#1-图像直方图&quot; class=&quot;headerlink&quot; title=&quot;1. 图像直方图&quot;&gt;&lt;/a&gt;1. 图像直方图&lt;/h2&gt;&lt;p&gt;图像直方图，是指对整个图像在灰度范围内的像素值(0-255)统计出现频率次数，据此生成的直方图，称为图像直方图或直方图。直方图反映了图像灰度的分布情况，是图像的统计学特征。也可以说，直方图是图像中像素强度分布的图形表达方式，它统计了每一个强度值所具有的像素个数。&lt;/p&gt;
&lt;h2 id=&quot;2-直方图均衡化&quot;&gt;&lt;a href=&quot;#2-直方图均衡化&quot; class=&quot;headerlink&quot; title=&quot;2. 直方图均衡化&quot;&gt;&lt;/a&gt;2. 直方图均衡化&lt;/h2&gt;&lt;p&gt;直方图均衡化是以累计分布函数为核心，将原始图像灰度直方图从比较集中的某个灰度区间，非线性地映射为在全部灰度范围内的较均匀分布，从而增强对比度。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像缩放、旋转、翻转、平移</title>
    <link href="http://yoursite.com/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/"/>
    <id>http://yoursite.com/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/</id>
    <published>2023-01-07T05:05:28.000Z</published>
    <updated>2023-01-07T05:30:34.271Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍几种常见的图像几何变换方法。<a id="more"></a></p><h2 id="1-图像缩放"><a href="#1-图像缩放" class="headerlink" title="1. 图像缩放"></a>1. 图像缩放</h2><p>图像缩放就是将源图像中的像素点经过算法映射到目标图像的像素点的过程，即找出目标图像中的像素点Pd(Xd，Yd)对应的源图像的像素点Ps(Xs，Ys)，然后将源图像像素点填充到对应目标图像的像素点，最终形成目标图像。常见的图像缩放算法有最邻近点插值法、双线性插值法和BiCubic卷积插值法等。</p><p>在OpenCV中提供函数cv2.resize()实现对图像的缩放，该函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.resize( src, dsize[, fx[, fy[, interpolation]]] )</span><br></pre></td></tr></table></figure><p>参数说明：<br>dst：输出的目标图像，其类型与src相同，大小为dsize（当该值非零时），或者可以通过src.size()、fx、fy计算得到；<br>src：需要进行缩放的原始图像；<br>dsize：输出图像的大小；<br>x：水平方向的缩放比例；<br>y：垂直方向的缩放比例；<br>interpolation：插值方式。</p><p>插值是指图像在进行几何处理时，给无法直接通过映射得到的值的像素点赋值。比如，将原始图像放大为原来的2倍，必然会多出一些无法被直接映射值的像素点，对于这些像素点，插值方式决定了如何确定它们的值。当缩小图像时，使用区域插值方式（INTER_AREA）能够得到最好的效果；当放大图像时，使用三次样条插值（INTER_CUBIC）方式和双线性插值（INTER_LINEAR）方式都能够取得较好的效果。三次样条插值方式速度较慢，双线性插值方式速度相对较快且效果并不逊色。</p><p> 测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"lenna.jpg"</span>)</span><br><span class="line">height, width = img.shape[:<span class="number">2</span>]  <span class="comment"># 获取图像的高度和宽度</span></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩放到原来的二分之一</span></span><br><span class="line">img_test1 = cv2.resize(img, (int(height / <span class="number">2</span>), int(width / <span class="number">2</span>)))</span><br><span class="line">cv2.imshow(<span class="string">'resize1'</span>, img_test1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近邻插值法缩放，缩放到原来的四分之一</span></span><br><span class="line">img_test2 = cv2.resize(img, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.25</span>, fy=<span class="number">0.25</span>, interpolation=cv2.INTER_NEAREST)</span><br><span class="line">cv2.imshow(<span class="string">'resize2'</span>, img_test2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/1.png" alt></p><h2 id="2-图像旋转"><a href="#2-图像旋转" class="headerlink" title="2 图像旋转"></a>2 图像旋转</h2><p>图像旋转是指将图像绕某个中心点旋转一定角度后，得到一幅新的图像。</p><p>Python中imutils工具包提供了如下函数实现图像旋转：<br>imutils.rotate：实现了在旋转完成图分辨率不调整的情况下，对原图像内容旋转，可能局部丢失，缺失部分用黑色填充。<br>imutils.rotate_bound：保持原图完整，旋转完成图分辨率会改变。</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> imutils</span><br><span class="line">img = cv2.imread(<span class="string">"lenna.jpg"</span>)</span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转45度，可能局部丢失，缺失部分用黑色填充</span></span><br><span class="line"></span><br><span class="line">rot1 = imutils.rotate(img, angle=<span class="number">45</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rotated1"</span>, rot1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转45度，保持原图完整，旋转完成图分辨率会改变</span></span><br><span class="line"></span><br><span class="line">rot2 = imutils.rotate_bound(img, angle=<span class="number">45</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rotated2"</span>, rot2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/2.png" alt></p><h2 id="3-图像翻转"><a href="#3-图像翻转" class="headerlink" title="3 图像翻转"></a>3 图像翻转</h2><p>翻转也称镜像，是指将图像沿轴线进行轴对称变换。水平镜像是将图像沿垂直中轴线进行左右翻转，垂直镜像是将图像沿水平中轴线进行上下翻转，水平垂直镜像是水平镜像和垂直镜像的叠加。</p><p>OpenCV提供了cv2.flip函数，可以将图像沿水平方向、垂直方向、或水平/垂直方向同时进行翻转。其函数原型如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.flip(src, flipCode[, dst]) -&gt; dst</span><br></pre></td></tr></table></figure><p>参数说明：<br>scr：变换操作的输入图像；<br>flipCode：控制参数，整型（int），flipCode&gt;0 水平翻转，flipCode=0 垂直翻转，flipCode&lt;0 水平和垂直翻转；<br>dst：变换操作的输出图像，可选项。</p><p> 测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"lenna.jpg"</span>)  <span class="comment"># 读取彩色图像(BGR)</span></span><br><span class="line"></span><br><span class="line">imgFlip1 = cv2.flip(img, <span class="number">0</span>)  <span class="comment"># 垂直翻转</span></span><br><span class="line">imgFlip2 = cv2.flip(img, <span class="number">1</span>)  <span class="comment"># 水平翻转</span></span><br><span class="line">imgFlip3 = cv2.flip(img, <span class="number">-1</span>)  <span class="comment"># 水平和垂直翻转</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Original"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))  <span class="comment"># 原始图像</span></span><br><span class="line">plt.subplot(<span class="number">222</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Flipped Horizontally"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(imgFlip2, cv2.COLOR_BGR2RGB))  <span class="comment"># 水平翻转</span></span><br><span class="line">plt.subplot(<span class="number">223</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Flipped Vertically"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(imgFlip1, cv2.COLOR_BGR2RGB))  <span class="comment"># 垂直翻转</span></span><br><span class="line">plt.subplot(<span class="number">224</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Flipped Horizontally &amp; Vertically"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(imgFlip3, cv2.COLOR_BGR2RGB))  <span class="comment"># 水平垂直翻转</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/3.png" alt></p><h2 id="4-图像平移"><a href="#4-图像平移" class="headerlink" title="4 图像平移"></a>4 图像平移</h2><p>图像的平移就是将图像上的像素点整体移动。图像平移首先定义平移矩阵M，再调用warpAffine()函数实现平移，函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, x], [<span class="number">0</span>, <span class="number">1</span>, y]])</span><br><span class="line">shifted = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p> 测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">image = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像下、上、右、左平移</span></span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>]])</span><br><span class="line">img1 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-100</span>]])</span><br><span class="line">img2 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">img3 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">-100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">img4 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line"></span><br><span class="line">titles = [ <span class="string">'Image-down'</span>, <span class="string">'Image-up'</span>, <span class="string">'Image-right'</span>, <span class="string">'Image-left'</span>]  </span><br><span class="line">images = [img1, img2, img3, img4]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):  </span><br><span class="line">   plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>), plt.imshow(images[i]), plt.title(titles[i])  </span><br><span class="line">   plt.xticks([]),plt.yticks([])  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> 效果如下：</p><p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/4.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍几种常见的图像几何变换方法。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像边缘检测</title>
    <link href="http://yoursite.com/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</id>
    <published>2023-01-06T01:02:17.000Z</published>
    <updated>2023-01-06T01:49:06.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是边缘检测"><a href="#1-什么是边缘检测" class="headerlink" title="1. 什么是边缘检测"></a>1. 什么是边缘检测</h2><p>边缘检测是图像处理与计算机视觉中的重要技术之一。其目的是检测识别出图像中亮度变化剧烈的像素点构成的集合。图像边缘的正确检测对于分析图像中的内容、实现图像中物体的分割、定位等具有重要的作用。边缘检测大大减少了源图像的数据量，剔除了与目标不相干的信息，保留了图像重要的结构属性。</p><p>图像的边缘指的是图像中像素灰度值突然发生变化的区域，如果将图像的每一行像素和每一列像素都描述成一个关于灰度值的函数，那么图像的边缘对应在灰度值函数中是函数值突然变大的区域。函数值的变化趋势可以用函数的导数描述。当函数值突然变大时，导数也必然会变大，而函数值变化较为平缓区域，导数值也比较小，因此可以通过寻找导数值较大的区域去寻找函数中突然变化的区域，进而确定图像中的边缘位置。<a id="more"></a></p><h2 id="2-边缘检测的常用方法及Python应用"><a href="#2-边缘检测的常用方法及Python应用" class="headerlink" title="2 边缘检测的常用方法及Python应用"></a>2 边缘检测的常用方法及Python应用</h2><p>边缘检测的方法大致可分为两类：基于搜索和基于零交叉。</p><p>基于搜索的边缘检测方法：首先计算边缘强度，通常用一阶导数表示，例如梯度模，然后，计算估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值。</p><p>基于零交叉的边缘检测方法：找到由图像得到的二阶导数的零交叉点来定位边缘，通常用拉普拉斯算子或非线性微分方程的零交叉点。</p><p>滤波作为边缘检测的预处理通常是必要的，通常采用高斯滤波。</p><h3 id="2-1-一阶微分算子"><a href="#2-1-一阶微分算子" class="headerlink" title="2.1 一阶微分算子"></a>2.1 一阶微分算子</h3><p>一阶微分为基础的边缘检测，通过计算图像的梯度值来检测图像的边缘，如Roberts算子、Prewitt算子和Sobel算子等。</p><h4 id="2-1-1-Roberts算子"><a href="#2-1-1-Roberts算子" class="headerlink" title="2.1.1 Roberts算子"></a>2.1.1 Roberts算子</h4><p>Roberts算子是一种最简单的算子，它利用局部差分算子寻找边缘。采用对角线相邻两像素之差近似梯度幅值检测边缘，检测垂直边缘的效果比斜向边缘要好，定位精度高，但对噪声比较敏感，无法抑制噪声的影响。</p><p>Roberts算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差，如下的2个卷积核形成了Roberts算子，图像中的每一个点都用这2个核做卷积：</p><p><img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.1-1.png" alt></p><p>若对于输入图像f(x,y),使用Roberts算子后输出的目标图像为g(x,y),则</p><p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.1-2.png" alt></p><p>在Python中，Roberts算子主要是通过Numpy定义模板，再调用OpenCV的filter2D()函数实现边缘提取。该函数主要是利用内核实现对图像的卷积运算，其函数原型如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = filter2D(src, ddepth, kernel, dts, anchor,delta, borderType)</span><br></pre></td></tr></table></figure><p>参数说明：<br>src：表示输入图像；<br>ddepth: 表示目标图像所需的深度；<br>kernel: 表示卷积核,一个单通道浮点型矩阵；<br>anchor： 表示内核的基准点，其默认值为(-1, -1)，位于中心位置；<br>delta：表示在存储目标图像前可选的添加到像素的值，默认值为0；<br>borderType：表示边框模式。</p><p> 实验代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Roberts</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">   img = cv2.imread(srcImg_path)</span><br><span class="line">   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">   <span class="comment"># Roberts算子</span></span><br><span class="line">   kernelx = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>]], dtype=int)</span><br><span class="line">   kernely = np.array([[<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>]], dtype=int)</span><br><span class="line">   x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)</span><br><span class="line">   y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)</span><br><span class="line">   <span class="comment"># 转成uint8</span></span><br><span class="line">   absX = cv2.convertScaleAbs(x)</span><br><span class="line">   absY = cv2.convertScaleAbs(y)</span><br><span class="line">   Roberts = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="comment"># 显示图形</span></span><br><span class="line">   titles = [<span class="string">"Original Image"</span>, <span class="string">"Roberts Image"</span>]</span><br><span class="line">   images = [img, Roberts]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">       plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">       plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">       plt.title(titles[i])</span><br><span class="line">       plt.axis(<span class="string">'off'</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.1-3.png" alt></p><h4 id="2-1-2-Prewitt算子"><a href="#2-1-2-Prewitt算子" class="headerlink" title="2.1.2 Prewitt算子"></a>2.1.2 Prewitt算子</h4><p>Prewitt是一种图像边缘检测的微分算子，其原理是利用特定区域内像素值产生的差分实现边缘检测。由于Prewitt算子采用3x3模板对区域内的像素值进行计算，而Roberts算子的模板为2x2，故Prewitt算子的边缘检测结果在水平和垂直方向均比Roberts算子更加明显。Prewitt算子适合用来识别噪声较多，灰度渐变的图像。</p><p>Prewitt算子卷积核如下：</p><p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.2-1.png" alt></p><p> 实验代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Prewitt</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">   img = cv2.imread(srcImg_path)</span><br><span class="line">   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">   <span class="comment"># Prewitt算子</span></span><br><span class="line">   kernelx = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]], dtype=int)</span><br><span class="line">   kernely = np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=int)</span><br><span class="line">   x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)</span><br><span class="line">   y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)</span><br><span class="line">   <span class="comment"># 转成uint8</span></span><br><span class="line">   absX = cv2.convertScaleAbs(x)</span><br><span class="line">   absY = cv2.convertScaleAbs(y)</span><br><span class="line">   Prewitt = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="comment"># 显示图形</span></span><br><span class="line">   titles = [<span class="string">"Original Image"</span>, <span class="string">"Prewitt Image"</span>]</span><br><span class="line">   images = [img, Prewitt]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">       plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">       plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">       plt.title(titles[i])</span><br><span class="line">       plt.axis(<span class="string">'off'</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>  <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.2-2.png" alt></p><h4 id="2-1-3-Sobel算子"><a href="#2-1-3-Sobel算子" class="headerlink" title="2.1.3 Sobel算子"></a>2.1.3 Sobel算子</h4><p>在边缘检测中，常用的一种模板是Sobel算子。Sobel算子有两个卷积核，一个是检测水平边缘的；另一个是检测垂直边缘的。与Prewitt算子相比，Sobel算子对于像素的位置的影响做了加权，可以降低边缘模糊程度，因此效果更好。</p><p>Sobel算子卷积核如下：</p><p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.3-1.png" alt></p><p> 在opencv-python中定义了Sobel算子，其函数原型如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = Sobel(src, ddepth, dx, dy, dst,ksize, scale, delta, borderType)</span><br></pre></td></tr></table></figure><p>参数说明：<br>src：表示输入图像；<br>dst：表示输出的边缘图，其大小和通道数与输入图像相同；<br>ddepth：表示目标图像所需的深度，针对不同的输入图像，输出目标图像有不同的深度；<br>dx：表示x方向上的差分阶数，取值1或0；<br>dy：表示y方向上的差分阶数，取值1或0；<br>ksize：表示Sobel算子的大小，其值必须是正数和奇数；<br>scale：表示缩放导数的比例常数，默认情况下没有伸缩系数；<br>delta：表示将结果存入目标图像之前，添加到结果中的可选增量值。</p><p> 实验代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sobel_demo</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">   img = cv2.imread(srcImg_path)</span><br><span class="line">   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">   <span class="comment"># Sobel算子</span></span><br><span class="line">   x = cv2.Sobel(grayImage, cv2.CV_16S, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">   y = cv2.Sobel(grayImage, cv2.CV_16S, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="comment"># 转成uint8</span></span><br><span class="line">   absX = cv2.convertScaleAbs(x)</span><br><span class="line">   absY = cv2.convertScaleAbs(y)</span><br><span class="line">   Sobel = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="comment"># 显示图形</span></span><br><span class="line">   titles = [<span class="string">"Original Image"</span>, <span class="string">"Sobel Image"</span>]</span><br><span class="line">   images = [img, Sobel]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">       plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">       plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">       plt.title(titles[i])</span><br><span class="line">       plt.axis(<span class="string">'off'</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.3-2.png" alt></p><h3 id="2-2-二阶微分算子"><a href="#2-2-二阶微分算子" class="headerlink" title="2.2 二阶微分算子"></a>2.2 二阶微分算子</h3><p>二阶微分为基础的边缘检测，通过寻求二阶导数中的过零点来检测边缘，如Laplacian算子和Canny算子等。</p><h4 id="2-2-1-Laplacian算子"><a href="#2-2-1-Laplacian算子" class="headerlink" title="2.2.1 Laplacian算子"></a>2.2.1 Laplacian算子</h4><p>Laplacian算子是n维欧几里德空间中的一个二阶微分算子，常用于图像增强和边缘提取。它通过灰度差分计算邻域内的像素，基本流程是：判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作。在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系，最后通过梯度运算的结果对像素灰度进行调整。</p><p>在opencv-python中，Laplacian算子封装在Laplacian()函数中，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</span><br></pre></td></tr></table></figure><p>参数说明：<br>src：表示输入图像；<br>dst：表示输出的边缘图，其大小和通道数与输入图像相同；<br>ddepth：表示目标图像所需的深度；<br>ksize：表示用于计算二阶导数的滤波器的孔径大小，其值必须是正数和奇数，且默认值为1；<br>scale：表示计算拉普拉斯算子值的可选比例因子，默认值为1；<br>delta：表示将结果存入目标图像之前，添加到结果中的可选增量值，默认值为0；<br>borderType：表示边框模式。</p><p> 当ksize=1时，Laplacian()函数采用3x3模板（四邻域）进行变换处理。下面的实验代码是采用ksize=3的Laplacian算子进行图像锐化处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Laplacian_demo</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv2.imread(srcImg_path)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># Laplacian算子</span></span><br><span class="line">    Laplacian = cv2.Laplacian(grayImage, cv2.CV_16S, ksize=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 转成uint8</span></span><br><span class="line">    Laplacian = cv2.convertScaleAbs(Laplacian)</span><br><span class="line">    <span class="comment"># 显示图形</span></span><br><span class="line">    titles = [<span class="string">"Original Image"</span>, <span class="string">"Laplacian Image"</span>]</span><br><span class="line">    images = [img, Laplacian]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p> 效果如下：</p><p>  <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.2.1-1.png" alt></p><h4 id="2-2-2-Canny算子"><a href="#2-2-2-Canny算子" class="headerlink" title="2.2.2 Canny算子"></a>2.2.2 Canny算子</h4><p>Canny算子由John F. Canny在1986年提出，由于它出色的检测和容错能力，至今一直被广泛使用。Canny边缘检测具有以下特点：<br>较低的错误率 - 只有真实存在的边缘才会被检测到。<br>较好的边缘定位 - 检测出来的结果和图像中真实的边缘在距离上的误差很小。<br>没有重复的检测 - 对于每一条边缘，只会返回一个与之对应的结果。</p><p> Canny算子的计算步骤大概分成以下几步：</p><p>1.图像灰度化<br>2.用高斯滤波去噪：目的是平滑一些纹理较弱的非边缘区域，以得到更准确的边缘。<br>3.计算梯度方向和大小：图像梯度表达的是各个像素点之间，像素值大小的变化幅度大小，变化较大，则可以认为是处于边缘位置。<br>4.非极大值抑制：在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点，即对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。<br>5.双阈值选取和滞后边界跟踪：确定哪些边界才是真正的边界。这时我们需要设置两个阈值：minVal和maxVal。当图像的灰度梯度高于maxVal时被认为是真的边界，那些低于minVal的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p><p> 在Python Opencv接口中，提供了Canny函数，其函数原型如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canny = cv2.Canny(image,threshold1,threshold2)</span><br></pre></td></tr></table></figure><p>参数说明：<br>image：灰度图；<br>threshold1：minval，较小的阈值将间断的边缘连接起来；<br>threshold2：maxval，较大的阈值检测图像中明显的边缘。</p><p> 实验代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Canny_demo</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv2.imread(srcImg_path)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 高斯滤波</span></span><br><span class="line">    img_GaussianBlur = cv2.GaussianBlur(gray, (<span class="number">3</span>,<span class="number">3</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># Canny算子</span></span><br><span class="line">    Canny = cv2.Canny(img_GaussianBlur, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 显示图形</span></span><br><span class="line">    titles = [<span class="string">"Original Image"</span>, <span class="string">"Canny Image"</span>]</span><br><span class="line">    images = [img, Canny]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.2.2-1.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-什么是边缘检测&quot;&gt;&lt;a href=&quot;#1-什么是边缘检测&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是边缘检测&quot;&gt;&lt;/a&gt;1. 什么是边缘检测&lt;/h2&gt;&lt;p&gt;边缘检测是图像处理与计算机视觉中的重要技术之一。其目的是检测识别出图像中亮度变化剧烈的像素点构成的集合。图像边缘的正确检测对于分析图像中的内容、实现图像中物体的分割、定位等具有重要的作用。边缘检测大大减少了源图像的数据量，剔除了与目标不相干的信息，保留了图像重要的结构属性。&lt;/p&gt;
&lt;p&gt;图像的边缘指的是图像中像素灰度值突然发生变化的区域，如果将图像的每一行像素和每一列像素都描述成一个关于灰度值的函数，那么图像的边缘对应在灰度值函数中是函数值突然变大的区域。函数值的变化趋势可以用函数的导数描述。当函数值突然变大时，导数也必然会变大，而函数值变化较为平缓区域，导数值也比较小，因此可以通过寻找导数值较大的区域去寻找函数中突然变化的区域，进而确定图像中的边缘位置。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++：深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2023/01/05/C-%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2023/01/05/C-%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2023-01-05T01:14:15.000Z</published>
    <updated>2023-01-05T01:39:17.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是浅拷贝和深拷贝"><a href="#1-什么是浅拷贝和深拷贝" class="headerlink" title="1. 什么是浅拷贝和深拷贝"></a>1. 什么是浅拷贝和深拷贝</h2><p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是<strong>浅拷贝</strong>，这和调用 memcpy() 函数的效果非常类似。<a id="more"></a></p><p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><p>下面通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。</p><p><strong>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。</strong></p><p>深拷贝的例子比比皆是，除了上面的变长数组类，动态数组类也需要深拷贝；此外，标准模板库STL中的 string、vector、stack、set、map 等也都必须使用深拷贝。</p><p>如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure><p>可以发现，更改 arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，导致 arr2.m_p 和 arr1.m_p 指向了同一块内存，所以会相互影响。</p><p>另外需要注意的是，printArray() 函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了 const 限制，以使得语义更加明确。</p><h2 id="2-到底是浅拷贝还是深拷贝"><a href="#2-到底是浅拷贝还是深拷贝" class="headerlink" title="2. 到底是浅拷贝还是深拷贝"></a>2. 到底是浅拷贝还是深拷贝</h2><p>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</p><p>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1: count = <span class="number">1</span>, time = <span class="number">1488344372</span></span><br><span class="line">obj2: count = <span class="number">2</span>, time = <span class="number">1488344375</span></span><br></pre></td></tr></table></figure><p>运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-什么是浅拷贝和深拷贝&quot;&gt;&lt;a href=&quot;#1-什么是浅拷贝和深拷贝&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是浅拷贝和深拷贝&quot;&gt;&lt;/a&gt;1. 什么是浅拷贝和深拷贝&lt;/h2&gt;&lt;p&gt;对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Base(): m_a(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), m_b(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Base(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b): m_a(a), m_b(b)&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m_a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m_b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = a;  &lt;span class=&quot;comment&quot;&gt;//拷贝&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Base &lt;span class=&quot;title&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Base obj2 = obj1;  &lt;span class=&quot;comment&quot;&gt;//拷贝&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是&lt;strong&gt;浅拷贝&lt;/strong&gt;，这和调用 memcpy() 函数的效果非常类似。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++11：move函数将左值强制转换为右值</title>
    <link href="http://yoursite.com/2023/01/04/C-11%EF%BC%9Amove%E5%87%BD%E6%95%B0%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC/"/>
    <id>http://yoursite.com/2023/01/04/C-11%EF%BC%9Amove%E5%87%BD%E6%95%B0%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC/</id>
    <published>2023-01-04T00:54:35.000Z</published>
    <updated>2023-01-04T01:27:50.637Z</updated>
    
    <content type="html"><![CDATA[<p>通过学习《<a href="https://crossoverpptx.github.io/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">C++11移动构造函数</a>》我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p><p>需要注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p><p><strong>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</strong>基于 move() 函数特殊的功能，其常用于实现移动语义。</p><a id="more"></a><p>move() 函数的用法也很简单，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg )</span><br></pre></td></tr></table></figure><p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p><p>下面用一些代码演示了move() 函数的使用方法。</p><p>（1）move() 函数的基础应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movedemo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    movedemo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    movedemo(<span class="keyword">const</span> movedemo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    movedemo(movedemo &amp;&amp;d):num(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"move construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo2:\n"</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo3:\n"</span>;</span><br><span class="line">    movedemo demo3 = <span class="built_in">std</span>::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line"><span class="built_in">move</span> construct!</span><br></pre></td></tr></table></figure><p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p><blockquote><p>注意：调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 30 行代码会导致程序运行时发生错误。</p></blockquote><p>（2）灵活使用 move() 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    first() :num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    first(first &amp;&amp;d) :num(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"first move construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    second() :fir() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    second(second &amp;&amp; sec) :fir(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"second move construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">first <span class="built_in">move</span> construct!</span><br><span class="line">second <span class="built_in">move</span> construct</span><br></pre></td></tr></table></figure><p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。仔细观察可以发现，程序中使用了两次 move() 函数：</p><ul><li>程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li><li>程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过学习《&lt;a href=&quot;https://crossoverpptx.github.io/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++11移动构造函数&lt;/a&gt;》我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。&lt;/p&gt;
&lt;p&gt;需要注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。&lt;/strong&gt;基于 move() 函数特殊的功能，其常用于实现移动语义。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：移动构造函数</title>
    <link href="http://yoursite.com/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-03T00:44:50.000Z</published>
    <updated>2023-01-03T11:52:07.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拷贝构造函数中的深拷贝问题"><a href="#1-拷贝构造函数中的深拷贝问题" class="headerlink" title="1. 拷贝构造函数中的深拷贝问题"></a>1. 拷贝构造函数中的深拷贝问题</h2><p>在 C++ 98/03 标准中，如果想用其它对象初始化一个同类的新对象，只能借助类中的拷贝构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。<strong>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。</strong></p><a id="more"></a><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ~demo()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"class destruct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</p><p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p><ol><li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</li><li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li><li>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li><li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li></ol><p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure><p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!        &lt;-- 执行 demo()</span><br><span class="line">copy construct!    &lt;-- 执行 <span class="keyword">return</span> demo()</span><br><span class="line">class destruct!     &lt;-- 销毁 demo() 产生的匿名对象</span><br><span class="line">copy construct!    &lt;-- 执行 a = get_demo()</span><br><span class="line">class destruct!     &lt;-- 销毁 get_demo() 返回的临时对象</span><br><span class="line">class destruct!     &lt;-- 销毁 a</span><br></pre></td></tr></table></figure><p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p><blockquote><p>事实上，此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p></blockquote><p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p><h2 id="2-C-移动构造函数（移动语义的具体实现）"><a href="#2-C-移动构造函数（移动语义的具体实现）" class="headerlink" title="2. C++移动构造函数（移动语义的具体实现）"></a>2. C++移动构造函数（移动语义的具体实现）</h2><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p><p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p><blockquote><p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p></blockquote><p>例如，下面程序对 demo 类进行了修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    demo(demo &amp;&amp;d):num(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"move construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"class destruct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。<strong>和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。</strong>并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p><p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="built_in">move</span> construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br><span class="line"><span class="class"><span class="title">move</span> <span class="title">construct</span>!</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">destruct</span>!</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure><p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p><p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p><blockquote><p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p></blockquote><p>那么，如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p><p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-拷贝构造函数中的深拷贝问题&quot;&gt;&lt;a href=&quot;#1-拷贝构造函数中的深拷贝问题&quot; class=&quot;headerlink&quot; title=&quot;1. 拷贝构造函数中的深拷贝问题&quot;&gt;&lt;/a&gt;1. 拷贝构造函数中的深拷贝问题&lt;/h2&gt;&lt;p&gt;在 C++ 98/03 标准中，如果想用其它对象初始化一个同类的新对象，只能借助类中的拷贝构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。&lt;strong&gt;需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++：拷贝构造函数</title>
    <link href="http://yoursite.com/2023/01/02/C-%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2023/01/02/C-%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-02T09:28:09.000Z</published>
    <updated>2023-01-02T11:16:39.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拷贝和拷贝构造函数"><a href="#1-拷贝和拷贝构造函数" class="headerlink" title="1. 拷贝和拷贝构造函数"></a>1. 拷贝和拷贝构造函数</h2><p>拷贝和复制是一个意思，对应的英文单词都是<code>copy</code>。对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。<a id="more"></a></p><p>在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化：</p><ol><li>分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li><li>初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。</li></ol><p>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net http://c.biancheng.net</span></span><br></pre></td></tr></table></figure><p>s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。</p><blockquote><p>对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的，这其实涉及到C++转换构造函数的知识。s4 也是类似的道理。</p></blockquote><p>对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p><p>对于 func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 func() 时，才会将其它对象的数据拷贝给 str 以完成初始化。</p><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。</p><p>下面的例子演示了拷贝构造函数的定义和使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.<span class="built_in">display</span>();</span><br><span class="line">    stu2.<span class="built_in">display</span>();</span><br><span class="line">    stu3.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line">Copy constructor was called.</span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br></pre></td></tr></table></figure><p>第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p><h3 id="1-1-为什么必须是当前类的引用呢？"><a href="#1-1-为什么必须是当前类的引用呢？" class="headerlink" title="1.1 为什么必须是当前类的引用呢？"></a>1.1 为什么必须是当前类的引用呢？</h3><p>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p><h3 id="1-2-为什么是-const-引用呢？"><a href="#1-2-为什么是-const-引用呢？" class="headerlink" title="1.2 为什么是 const 引用呢？"></a>1.2 为什么是 const 引用呢？</h3><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>以上面的 Student 类为例，将 const 去掉后，拷贝构造函数的原型变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(Student &amp;stu);</span><br></pre></td></tr></table></figure><p>此时，下面的代码就会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure><p>stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用<code>Student::Student(const Student &amp;stu)</code>，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用<code>Student::Student(Student &amp;stu)</code>，所以最终调用失败了。</p><p>当然，也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。</p><h2 id="2-默认拷贝构造函数"><a href="#2-默认拷贝构造函数" class="headerlink" title="2. 默认拷贝构造函数"></a>2. 默认拷贝构造函数</h2><p>其实，即使我们没学习过拷贝构造函数，实际上却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。</p><p>对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-拷贝和拷贝构造函数&quot;&gt;&lt;a href=&quot;#1-拷贝和拷贝构造函数&quot; class=&quot;headerlink&quot; title=&quot;1. 拷贝和拷贝构造函数&quot;&gt;&lt;/a&gt;1. 拷贝和拷贝构造函数&lt;/h2&gt;&lt;p&gt;拷贝和复制是一个意思，对应的英文单词都是&lt;code&gt;copy&lt;/code&gt;。对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>梅子鸡之味</title>
    <link href="http://yoursite.com/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/"/>
    <id>http://yoursite.com/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/</id>
    <published>2023-01-01T13:59:52.000Z</published>
    <updated>2023-01-02T09:08:34.089Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有安静地看一部电影了，在新年的第一天，经一位网友的推荐，看了这部充满浪漫色彩的“喜剧”。电影开始时确实有点让人摸不着头脑，以至于常常被逗笑，可越看越有一种悲伤的气息扑面而来。我倒没有真的很悲伤，但确实引发了我的一些思考。</p><p>影片的结构很精巧，开始就说明了主人公的最终命运——八天后的死亡，然后从第一天直到第八天，层层递进，描绘了他面对即将到来的死亡的内心变化，并且在这之间穿插了过往历史进行深入阐述，直至最后与影片开头呼应，将整个故事完美串联到一起。</p><p>影片采用一种夸张的浪漫主义手法讲述故事。故事背景设定在上世纪中叶的法国，电影画面营造了一种饱含历史气息的氛围，让人很难想象这是一部2011年的电影。正是这种氛围，让人渐渐走进故事，就像被拉进了故事中，仿佛真切看到了发生的一切，让我想起了一部很久前看过的电影《爱有来生》，似有异曲同工之妙。</p><p>影片的故事从主人公、主人公的妻子、主人公的所爱三个人展开，主人公与所爱互相爱慕，却因为现实不得不分开，主人公的妻子深爱主人公，却爱而不得，最终导致了三个人的悲剧。摔坏的小提琴是主人公爱的破碎，也是主人公妻子爱的破碎，更是主人公所爱爱的破碎，正因如此，他才会选择死亡。电影从爱情与婚姻、艺术与生活、梦与现实，乃至教育、家庭、责任、社会、宗教、死亡、命运等多个角度进行了深入探讨，每一个角度都值得我们深入思考，所以这不仅仅是一个悲惨的爱情故事，更是一部千姿百态的生活全景图。</p><p>然而，电影在充满悲剧色彩的故事中还是给了我们一丝温暖与慰藉的。电影结尾，在主人公的坟墓前，爱他的人都来送他最后一程，包括他的挚爱；电影中主人公最想不到的小儿子在深夜为他默默祈祷；主人公母亲去世后坟墓上漂浮的烟雾花朵。即使生活充满支离破碎，命运满是伤痕，总是有人在乎你，爱着你的，即使他们终将离我们而去，但曾经留下的痕迹与回忆相信在最寒冷的黑夜也能给我们些许暖意。</p><p>最后，这确实是一部值得推荐和隔一段时间反复观看的电影。</p><p><img src="/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/梅子鸡之味.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久没有安静地看一部电影了，在新年的第一天，经一位网友的推荐，看了这部充满浪漫色彩的“喜剧”。电影开始时确实有点让人摸不着头脑，以至于常常被逗笑，可越看越有一种悲伤的气息扑面而来。我倒没有真的很悲伤，但确实引发了我的一些思考。&lt;/p&gt;
&lt;p&gt;影片的结构很精巧，开始就说明了主</summary>
      
    
    
    
    <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>C++11：引用限定符</title>
    <link href="http://yoursite.com/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    <id>http://yoursite.com/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/</id>
    <published>2023-01-01T00:49:01.000Z</published>
    <updated>2023-01-01T01:26:38.500Z</updated>
    
    <content type="html"><![CDATA[<p>C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p><a id="more"></a><h2 id="1-C-11：引用限定符"><a href="#1-C-11：引用限定符" class="headerlink" title="1. C++11：引用限定符"></a>1. C++11：引用限定符</h2><p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p><p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。<strong>所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</strong><br>修改上面程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 17 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。<br>同理，我们再次修改程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p><blockquote><p>注意：引用限定符不适用于静态成员函数和友元函数。</p></blockquote><h2 id="2-const和引用限定符"><a href="#2-const和引用限定符" class="headerlink" title="2. const和引用限定符"></a>2. const和引用限定符</h2><p>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 get_num() 就是一个常成员函数。const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。<br>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num,<span class="keyword">int</span> num2) :num(num),num2(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="keyword">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num2() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>不知如何起标题的2022</title>
    <link href="http://yoursite.com/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/"/>
    <id>http://yoursite.com/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/</id>
    <published>2022-12-31T08:44:48.000Z</published>
    <updated>2023-01-16T03:04:15.157Z</updated>
    
    <content type="html"><![CDATA[<p>想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）</p><p>翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成，庆幸的是总还是有一点进展的，虽然只是一点点。</p><p>无论如何，还是认识了一些新朋友，新老师，还有新网友。从他们那里，学到了很多东西，说明走出去，多见见世面，总归是好的。学习上，上课、看论文、做实验，有条不紊。虽然没怎么用功，但还是获得了二等学业奖学金，还是很开心的。科研上，还没有什么实质性成果，但是研究方向和目标已经明确和清晰，接下来就是一步步向前迈进和解决问题。生活上，没什么特别高兴的事，但比起糟糕的2021年，已经是很大的进步了。</p><p>这么看，今年还是不错的一年，但，还是有很多遗憾。因为疫情，上半年一直在家上网课，下半年被封在学校，始终没能出去走走看看。马上2023年了，我还是一个人，今晚的跨年又是一个人过，可悲可叹！其实，去年认识了一个女生，虽然接触不多，但我也不知道为什么对她有莫名的好感。从小到大，我都没有喜欢过一个女孩，我曾经一度以为，我是一个没有心的人，不懂得什么叫喜欢，因为我真的不知道喜欢一个人是什么感觉，直到遇见了她。对不起，内心戏有点多了，这也许并不是喜欢，只是有好感吧，又或者，这只是一个我想象中的女生，因为我已经一年没见过她了，只在微信聊过几句学习上的事。甚至她可能已经有男朋友了吧？笑死，我真是太可笑了！</p><p>3年的疫情终于迎来了转机，虽然我在放开后第一波就感染了，过程还很难受，好在很快就恢复了。身边越来越多的亲戚朋友都感染了，倒是没有听说有严重的，但是现实中肯定还是有很多重症。身处时代的漩涡中，作为普通人，我们无可奈何，只能尽力而为，保护好自己和所爱的人。</p><p>可是，阴霾总会过去的！我不是天生的乐观派，但我依旧相信希望，人总得有点希望。虽然这世间的一切本来不属于某个人，也终将不属于某个人。虽然我们可能经历苦难，面对疾病，遭遇挫折，背负谩骂，可是那又怎么样呢？宇宙那么大，我们何其渺小，就让我们做颗遥远恒星，隐约在茫茫天际，闪烁着微光足矣。</p><p>愿我所爱，万事胜意！</p><p>愿爱我的人，永远幸福！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）&lt;/p&gt;
&lt;p&gt;翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++11：longlong超长整型和nullptr初始化空指针</title>
    <link href="http://yoursite.com/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/</id>
    <published>2022-12-31T00:42:06.000Z</published>
    <updated>2022-12-31T01:31:44.597Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。<a id="more"></a></p><h2 id="1-C-11：long-long-超长整型"><a href="#1-C-11：long-long-超长整型" class="headerlink" title="1. C++11：long long 超长整型"></a>1. C++11：long long 超长整型</h2><p>C++ 11 标准中，基于整数大小的考虑，共提供了如下表所示的这些数据类型。与此同时，标准中还明确限定了各个数据类型最少占用的位数。</p><div class="table-container"><table><thead><tr><th>整数类型</th><th>等价类型</th><th>C++11标准规定占用最少位数</th></tr></thead><tbody><tr><td>short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short int</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned short</td><td>unsigned short int（无符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned short int</td><td>unsigned short int（无符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned</td><td>unsigned int（无符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned int</td><td>unsigned int（无符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long int</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>signed long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>signed long int</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>unsigned long</td><td>unsigned long int（无符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>unsigned long int</td><td>unsigned long int（无符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>long long int（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>signed long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>signed long long int（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>unsigned long long（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>unsigned long long int（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td>至少 64 位（8 个字节）</td></tr></tbody></table></div><blockquote><p>C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。不过需要注意的是，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</p></blockquote><p>在上表罗列的这些数据类型中，long long 超长整型是 C++ 11 标准新添加的。其实早在 1995 年，就有人提议将 long long 整形写入 C++ 98 标准，但被委员会拒绝了。而后 long long 整形被 C99 标准（C语言标准之一）采纳，并逐渐被很多编译器支持，于是 C++ 标准委员会重新决定将 long long 整形写入 C++ 11 标准中。</p><p>如同 long 类型整数需明确标注 “L” 或者 “l” 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p><ul><li>对于有符号 long long 整形，后缀用 “LL” 或者 “ll” 标识。例如，”10LL” 就表示有符号超长整数 10；</li><li>对于无符号 long long 整形，后缀用 “ULL”、”ull”、”Ull” 或者 “uLL” 标识。例如，”10ULL” 就表示无符号超长整数 10。</li></ul><blockquote><p>如果不添加任何标识，则所有的整数都会默认为 int 类型。</p></blockquote><p>对于 long long 类型来说，如果想了解当前平台上 long long 整形的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：<br>1）LLONG_MIN：代表当前平台上最小的 long long 类型整数；<br>2）LLONG_MAX：代表当前平台上最大的 long long 类型整数；<br>3）ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"long long最大值："</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">" "</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt;<span class="string">"long long最小值："</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt; <span class="string">"unsigned long long最大值："</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为（不唯一）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">-9223372036854775808</span> <span class="number">8000000000000000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最小值：<span class="number">9223372036854775807</span> <span class="number">7f</span>ffffffffffffff</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">18446744073709551615</span> ffffffffffffffff</span><br></pre></td></tr></table></figure><p>此程序中，输出了各最大值和最小值对应的十六进制，显然在当前平台（Windows10 64位操作系统）上，long long 超长整型占用 64 位（也就是 16 个字节）的存储空间。</p><h2 id="2-C-11：nullptr-初始化空指针"><a href="#2-C-11：nullptr-初始化空指针" class="headerlink" title="2. C++11：nullptr 初始化空指针"></a>2. C++11：nullptr 初始化空指针</h2><p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p><blockquote><p>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p></blockquote><p>C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。<br>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p><p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="number">0</span>);</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">int</span> n</span><br></pre></td></tr></table></figure><p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。<br>C++ 98/03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isnull( (<span class="keyword">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line">isnull( (<span class="keyword">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure><p>如此，才会成功调用我们预期的函数。</p><p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。</p><blockquote><p>在使用 nullptr 之前，需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，则需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std=c++0x 编译选项）。</p></blockquote><p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p><p>值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p><p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    isnull(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">void</span>*c</span><br></pre></td></tr></table></figure><p>借助执行结果不难看出，由于 nullptr 无法隐式转换为整形，而可以隐式匹配指针类型，因此执行结果和我们的预期相符。</p><p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：constexpr关键字</title>
    <link href="http://yoursite.com/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-12-30T02:17:44.000Z</published>
    <updated>2022-12-30T03:08:35.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-常量表达式"><a href="#1-C-常量表达式" class="headerlink" title="1. C++常量表达式"></a>1. C++常量表达式</h2><p>constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。</p><p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。<a id="more"></a></p><p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure><p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p><p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。而常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p><blockquote><p>注意：获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p></blockquote><h2 id="2-constexpr修饰普通变量"><a href="#2-constexpr修饰普通变量" class="headerlink" title="2. constexpr修饰普通变量"></a>2. constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：2</p><blockquote><p>注意：可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p></blockquote><p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p><blockquote><p>需要注意的是，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。但我们必须清楚，const 和 constexpr 并不相同。</p><p>另外需要注意的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p></blockquote><h2 id="3-constexpr修饰函数"><a href="#3-constexpr修饰函数" class="headerlink" title="3. constexpr修饰函数"></a>3. constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。但需要注意，constexpr 并非可以修改任意函数的返回值，一个函数要想成为常量表达式函数，必须满足如下 4 个条件：</p><p>1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。如下是正确的定义 display() 常量表达式函数的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p><p>2) 该函数必须有返回值，即函数的返回值类型不能是 void。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p><p>3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; noconst_dis(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：可尝试将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p></blockquote><p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p><p>4) return 返回的表达式必须是常量表达式，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p><blockquote><p>注意：在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的。</p></blockquote><h2 id="4-constexpr修饰类的构造函数"><a href="#4-constexpr修饰类的构造函数" class="headerlink" title="4. constexpr修饰类的构造函数"></a>4. constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p><p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    constexpr myType(char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p><blockquote><p>注意：constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p></blockquote><p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr myType(const char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.getname();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.getage();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p></blockquote><h2 id="5-constexpr修饰模板函数"><a href="#5-constexpr修饰模板函数" class="headerlink" title="5. constexpr修饰模板函数"></a>5. constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> = <span class="title">dispaly</span>(<span class="title">stu</span>);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret.name &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = dispaly(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p><ul><li>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li><li>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-C-常量表达式&quot;&gt;&lt;a href=&quot;#1-C-常量表达式&quot; class=&quot;headerlink&quot; title=&quot;1. C++常量表达式&quot;&gt;&lt;/a&gt;1. C++常量表达式&lt;/h2&gt;&lt;p&gt;constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。&lt;/p&gt;
&lt;p&gt;所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：for循环（基于范围的循环）</title>
    <link href="http://yoursite.com/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/</id>
    <published>2022-12-29T01:18:12.000Z</published>
    <updated>2022-12-29T12:18:25.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-98-03标准的for循环"><a href="#1-C-98-03标准的for循环" class="headerlink" title="1. C++ 98/03标准的for循环"></a>1. C++ 98/03标准的for循环</h2><p>在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如，下面程序演示了用上述结构遍历数组和容器的具体实现过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc,arc+<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (iter = myvector.<span class="built_in">begin</span>(); iter != myvector.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/</span></span><br></pre></td></tr></table></figure><h2 id="2-C-11标准的for循环"><a href="#2-C-11标准的for循环" class="headerlink" title="2. C++ 11标准的for循环"></a>2. C++ 11标准的for循环</h2><p>在 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li><li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li></ul><p>可以看到，同 C++ 98/03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p><p>下面程序演示了如何用 C++ 11 标准中的 for 循环遍历上面程序定义的 arc 数组和 myvector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : arc) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/ !</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/!</span></span><br></pre></td></tr></table></figure><p>这里有以下 2 点需要说明：<br>1) 程序中在遍历 myvector 容器时，定义了 auto 类型的 ch 变量，当编译器编译程序时，会通过 myvector 容器中存储的元素类型自动推导出 ch 为 char 类型。注意，这里的 ch 不是迭代器类型，而表示的是 myvector 容器中存储的每个元素。</p><p>2) 仔细观察程序的输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为 myvector 容器中没有存储 ‘\0’。</p><h3 id="2-1-遍历用-大括号初始化的列表"><a href="#2-1-遍历用-大括号初始化的列表" class="headerlink" title="2.1 遍历用{}大括号初始化的列表"></a>2.1 遍历用<code>{}</code>大括号初始化的列表</h3><p>新语法格式的 for 循环还支持遍历用<code>{}</code>大括号初始化的列表，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2-2-declaration-参数处定义引用形式的变量"><a href="#2-2-declaration-参数处定义引用形式的变量" class="headerlink" title="2.2 declaration 参数处定义引用形式的变量"></a>2.2 declaration 参数处定义引用形式的变量</h3><p>在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdef</span><br></pre></td></tr></table></figure><p>此程序中先后使用了 2 个新语法格式的 for 循环，其中前者用于修改 myvector 容器中各个元素的值，后者用于输出修改后的 myvector 容器中的各个元素。</p><p>既然 declaration 参数既可以定义普通形式的变量，也可以定义引用形式的变量，应该如何选择呢？其实很简单，如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-C-98-03标准的for循环&quot;&gt;&lt;a href=&quot;#1-C-98-03标准的for循环&quot; class=&quot;headerlink&quot; title=&quot;1. C++ 98/03标准的for循环&quot;&gt;&lt;/a&gt;1. C++ 98/03标准的for循环&lt;/h2&gt;&lt;p&gt;在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(表达式 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; 表达式 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; 表达式 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//循环体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：非受限联合体（union）</title>
    <link href="http://yoursite.com/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/</id>
    <published>2022-12-28T01:54:11.000Z</published>
    <updated>2022-12-28T02:31:44.155Z</updated>
    
    <content type="html"><![CDATA[<p>在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p><a id="more"></a><p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> T&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p><h2 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h2><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++11 取消了这种限制。</p><p>POD 是 C++ 中一个比较重要的概念，POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：<br>1) 没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</p><p>2) 不能包含虚函数和虚基类。</p><p>3) 非静态成员必须声明为 public。</p><p>4) 类中的第一个非静态成员的类型与其基类不同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure><p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p><p>5) 在类或者结构体继承时，满足以下两种情况之一：</p><ul><li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li><li>基类有非静态成员，而派生类没有非静态成员。</li></ul><p>比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; <span class="keyword">int</span> n1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span> :</span> B2 &#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure><p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p><p>6) 所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p><p>7) 此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p><h2 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h2><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p><h2 id="3-非受限联合体的赋值注意事项"><a href="#3-非受限联合体的赋值注意事项" class="headerlink" title="3. 非受限联合体的赋值注意事项"></a>3. 非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。这条规则可能导致对象构造失败，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p><p>解决上面问题的一般需要用到 placement new，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U() &#123; <span class="keyword">new</span>(&amp;s) <span class="built_in">string</span>; &#125;</span><br><span class="line">    ~U() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p><h3 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h3><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。placement new 的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) ClassConstruct(...)</span><br></pre></td></tr></table></figure><p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p><h2 id="4-非受限联合体的匿名声明和“枚举式类”"><a href="#4-非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="4. 非受限联合体的匿名声明和“枚举式类”"></a>4. 非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U&#123;</span><br><span class="line">  <span class="keyword">union</span> &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p><p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Type &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    Singer(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : s(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    Singer(<span class="keyword">int</span> i) : id(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, <span class="built_in">size</span>);</span><br><span class="line">        name[s] = <span class="string">'\0'</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singer(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    Singer(<span class="number">310217</span>);</span><br><span class="line">    Singer(<span class="string">"J Michael"</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：列表初始化</title>
    <link href="http://yoursite.com/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-12-27T01:23:31.000Z</published>
    <updated>2022-12-27T02:29:03.262Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++98/03 中，对象初始化方法有很多种，如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。<a id="more"></a></p><blockquote><p>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p></blockquote><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98/03 可以使用初始化列表（initializer list）进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，比如下面的代码：通过初始化列表初始化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: 'Foo::Foo(const Foo &amp;)' is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。<br>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。<br>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<br>a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p><p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure><blockquote><p>在初始化时，<code>{}</code>前面的等于号是否书写对初始化行为没有影响。</p></blockquote><p>另外，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。<br>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。<br>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p><p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span>, <span class="keyword">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p><p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++98/03 中，对象初始化方法有很多种，如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始化列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i_arr[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;;  &lt;span class=&quot;comment&quot;&gt;//普通数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; a = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;#123; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125; &amp;#125;;  &lt;span class=&quot;comment&quot;&gt;//POD类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//拷贝初始化（copy-initialization）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Foo(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; foo = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//需要拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//直接初始化（direct-initialization）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Foo &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：tuple元组</title>
    <link href="http://yoursite.com/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/"/>
    <id>http://yoursite.com/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/</id>
    <published>2022-12-26T02:48:05.000Z</published>
    <updated>2022-12-26T02:57:51.952Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p><p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p><a id="more"></a><h2 id="1-tuple对象的创建"><a href="#1-tuple对象的创建" class="headerlink" title="1. tuple对象的创建"></a>1. tuple对象的创建</h2><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</tuple></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br></pre></td></tr></table></figure><p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p><h4 id="1-1-类的构造函数"><a href="#1-1-类的构造函数" class="headerlink" title="1.1 类的构造函数"></a>1.1 类的构造函数</h4><p>tuple 模板类提供有很多构造函数，包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line">tuple (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span> <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span>      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span>  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span>       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span>            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    std::tuple&lt;int, char&gt; second(first);                     // 2)   second&#123;&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; third(std::make_tuple(20, 'b'));   // 3)   third&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;long, char&gt; fourth(third);                    // 4)的左值方式, fourth&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; fifth(10, 'a');                    // 5)的右值方式, fifth&#123;10.'a'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; sixth(std::make_pair(30, 'c'));    // 6)的右值方式, sixth&#123;30,''c&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-make-tuple-函数"><a href="#1-2-make-tuple-函数" class="headerlink" title="1.2 make_tuple()函数"></a>1.2 make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</tuple></p><p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>,<span class="string">'a'</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>; <span class="keyword">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = <span class="built_in">std</span>::make_tuple (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure><p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p><h2 id="2-tuple常用函数"><a href="#2-tuple常用函数" class="headerlink" title="2. tuple常用函数"></a>2. tuple常用函数</h2><p>为了方便在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数，<tuple> 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如下表所示：</tuple></p><div class="table-container"><table><thead><tr><th>函数或类模板</th><th>描 述</th></tr></thead><tbody><tr><td>tup1.swap(tup2) swap(tup1, tup2)</td><td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。</tuple></td></tr><tr><td>get<num>(tup)</num></td><td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</tuple></td></tr><tr><td>tuple_size<type>::value</type></td><td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</tuple></td></tr><tr><td>tuple_element<I, type>::type</I,></td><td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</tuple></td></tr><tr><td>forward_as_tuple<args...></args...></td><td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td></tr><tr><td>tie(args…) = tup</td><td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</tuple></td></tr><tr><td>tuple_cat(args…)</td><td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</tuple></td></tr></tbody></table></div><blockquote><p>tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、&lt;、&gt;、&gt;=、&lt;= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。</p></blockquote><p>以下程序演示了上表中一部分函数模板和类模板的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 'x'</span></span><br><span class="line">    std::tuple&lt;int, char&gt; mytuple(10, 'x');</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple(<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">double</span> mydou;</span><br><span class="line">    <span class="keyword">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    <span class="built_in">std</span>::tie(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = <span class="built_in">std</span>::tuple_cat(mytuple, bar);</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> x</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。&lt;/p&gt;
&lt;p&gt;tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：支持函数模板的默认模板参数</title>
    <link href="http://yoursite.com/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/</id>
    <published>2022-12-25T11:13:04.000Z</published>
    <updated>2022-12-25T11:19:10.033Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++98/03 标准中，类模板可以有默认的模板参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是却不支持函数的默认模板参数：<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;  <span class="comment">// error in C++98/03: default template arguments</span></span><br><span class="line"><span class="keyword">void</span> func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p><p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p><p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R func(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int；最后 func<double,int>(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</double,int></char></p><p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">double</span>&gt;</span><br><span class="line"><span class="keyword">void</span> func(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    func(<span class="string">'c'</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    func();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T=char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。由此不难看出，编译器的自动推导能力并没有想象的那么强大。</p><p>总的来说，C++11 支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++98/03 标准中，类模板可以有默认的模板参数，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; U = &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, U N = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct Foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是却不支持函数的默认模板参数：&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：返回值类型后置（跟踪返回值类型）</title>
    <link href="http://yoursite.com/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/</id>
    <published>2022-12-24T02:54:10.000Z</published>
    <updated>2022-12-24T03:03:36.357Z</updated>
    
    <content type="html"><![CDATA[<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。</p><a id="more"></a><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。比如如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure><p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p><p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) add(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，直接像上面这样写是编译不过的。因为 t、u 在参数列表中，而 C++ 的返回值是前置语法，在返回值定义的时候参数变量还不存在。<br>可行的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(T() + U()) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。因此，<strong>在 C++11 中增加了返回类型后置（trailing-return-type，又称跟踪返回类型）语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</strong></p><p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步说明这个语法，再看另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto func(T&amp; val) -&gt; decltype(foo(val))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说前一个例子中的 add 使用 C++98/03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>图像轮廓提取</title>
    <link href="http://yoursite.com/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"/>
    <id>http://yoursite.com/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/</id>
    <published>2022-12-23T09:11:13.000Z</published>
    <updated>2022-12-23T09:33:19.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、轮廓提取"><a href="#1、轮廓提取" class="headerlink" title="1、轮廓提取"></a>1、轮廓提取</h2><p>轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。<a id="more"></a></p><h2 id="2、轮廓提取方法及Python实现"><a href="#2、轮廓提取方法及Python实现" class="headerlink" title="2、轮廓提取方法及Python实现"></a>2、轮廓提取方法及Python实现</h2><h3 id="2-1-掏空内部点法"><a href="#2-1-掏空内部点法" class="headerlink" title="2.1 掏空内部点法"></a>2.1 掏空内部点法</h3><p>掏空内部点法的原理非常简单：如果原图中有一点为黑，且它的8个相邻点皆为黑色，则将该点删除，否则认为该点在图像的边缘，需要保留。依次处理图像中每一个像素，则最后留下来的就是图像的轮廓。对于非二值图像，需要先进行二值化处理。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_contour</span><span class="params">(bin_img)</span>:</span></span><br><span class="line">    contour_img = np.zeros(shape=(bin_img.shape),dtype=np.uint8)</span><br><span class="line">    contour_img += <span class="number">255</span></span><br><span class="line">    h = bin_img.shape[<span class="number">0</span>]</span><br><span class="line">    w = bin_img.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,h<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,w<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span>(bin_img[i][j]==<span class="number">0</span>):</span><br><span class="line">                contour_img[i][j] = <span class="number">0</span></span><br><span class="line">                sum = <span class="number">0</span></span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> sum ==  <span class="number">0</span>:</span><br><span class="line">                    contour_img[i][j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contour_img</span><br></pre></td></tr></table></figure><p>效果如下（左侧是Otsu二值化图像；右侧是轮廓图像）：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/1.png" alt></p><h3 id="2-2-opencv-python中轮廓提取方法的应用"><a href="#2-2-opencv-python中轮廓提取方法的应用" class="headerlink" title="2.2 opencv-python中轮廓提取方法的应用"></a>2.2 opencv-python中轮廓提取方法的应用</h3><p>（1）opencv-python中使用cv2.findContours函数来检测图像的边缘，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</span><br></pre></td></tr></table></figure><p><strong>参数说明如下：</strong><br>image：输入图像；<br>mode：轮廓检索模式；<br>method：轮廓逼近方法；<br>contours：返回的轮廓；<br>hierachy：每条轮廓对应的属性；<br>offset：每个轮廓点移动的可选偏移量。<br>备注：image参数需要是二值图，而不是灰度图，返回结果是等高线和层次结构。</p><p><strong>轮廓检索模式：</strong><br>cv2.RETR_EXTERNAL：表示只检测外轮廓；<br>cv2.RETR_LIST：检测的轮廓，不建立等级关系；<br>cv2.RETR_CCOMP：建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层；<br>cv2.RETR_TREE：建立一个等级树结构的轮廓。</p><p><strong>轮廓逼近方法：</strong><br>cv2.CHAIN_APPROX_NONE：存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即 max(abs(x1-x2),abs(y2-y1))==1，一般不会用到；<br>cv2.CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息；<br>cv2.CHAIN_APPROX_TC89_L1，cv2.CV_CHAIN_APPROX_TC89_KCOS：使用teh-Chinl chain近似算法。</p><p>（2）轮廓发现之后，还要通过cv2.drawContours函数绘制轮廓，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])</span><br></pre></td></tr></table></figure><p><strong>参数说明如下：</strong><br>image：输入图像；<br>contours：轮廓，在Python中是一个list，就是cv2.findContours函数找出来的点集，一个列表；<br>contourIdx：轮廓的索引，指定绘制轮廓list中的哪条轮廓，要绘制所有轮廓，传递-1；<br>color：颜色；<br>thickness：厚度，如果是-1，表示填充；<br>lineType：线型；<br>hierarchy：层次结构的可选信息；<br>maxLevel：绘制轮廓的最大级别，0：仅绘制指定的轮廓，1：绘制轮廓和所有嵌套轮廓，2：绘制轮廓，所有嵌套轮廓，所有嵌套到嵌套的轮廓；<br>offset：轮廓偏移参数。</p><p>根据上面两个函数，测试代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：读入图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：对图像做灰度处理</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：对图像做二值化处理</span></span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：获得图像的轮廓值</span></span><br><span class="line">contours, heriachy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步：绘制图像轮廓</span></span><br><span class="line">img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">res = cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(res, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'contour'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/2.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、轮廓提取&quot;&gt;&lt;a href=&quot;#1、轮廓提取&quot; class=&quot;headerlink&quot; title=&quot;1、轮廓提取&quot;&gt;&lt;/a&gt;1、轮廓提取&lt;/h2&gt;&lt;p&gt;轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="轮廓提取" scheme="http://yoursite.com/tags/%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
</feed>
