<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverpptx&#39;s Blog</title>
  
  <subtitle>黑夜给了我黑色的眼睛，我却用它寻找光明</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-01-01T01:26:38.500Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crossoverpptx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11：引用限定符</title>
    <link href="http://yoursite.com/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    <id>http://yoursite.com/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/</id>
    <published>2023-01-01T00:49:01.000Z</published>
    <updated>2023-01-01T01:26:38.500Z</updated>
    
    <content type="html"><![CDATA[<p>C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p><a id="more"></a><h2 id="1-C-11：引用限定符"><a href="#1-C-11：引用限定符" class="headerlink" title="1. C++11：引用限定符"></a>1. C++11：引用限定符</h2><p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p><p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。<strong>所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</strong><br>修改上面程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 17 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。<br>同理，我们再次修改程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p><blockquote><p>注意：引用限定符不适用于静态成员函数和友元函数。</p></blockquote><h2 id="2-const和引用限定符"><a href="#2-const和引用限定符" class="headerlink" title="2. const和引用限定符"></a>2. const和引用限定符</h2><p>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 get_num() 就是一个常成员函数。const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。<br>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num,<span class="keyword">int</span> num2) :num(num),num2(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="keyword">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num2() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>不知如何起标题的2022</title>
    <link href="http://yoursite.com/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/"/>
    <id>http://yoursite.com/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/</id>
    <published>2022-12-31T08:44:48.000Z</published>
    <updated>2022-12-31T13:26:27.418Z</updated>
    
    <content type="html"><![CDATA[<p>想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）</p><p>翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成，庆幸的是总还是有一点进展的，虽然只是一点点。</p><p>无论如何，还是认识了一些新朋友，新老师，还有新网友。从他们那里，学到了很多东西，说明走出去，多见见世面，总归是好的。学习上，上课、看论文、做实验，有条不紊。虽然没怎么用功，但还是获得了二等学业奖学金，还是很开心的。科研上，还没有什么实质性成果，但是研究方向和目标已经明确和清晰，接下来就是一步步向前迈进和解决问题。生活上，没什么特别高兴的事，但比起糟糕的2021年，已经是很大的进步了。</p><p>这么看，今年还是不错的一年，但，还是有很多遗憾。因为疫情，上半年一直在家上网课，下半年被封在学校，始终没能出去走走看看。马上2023年了，我还是一个人，今晚的跨年又是一个人过，可悲可叹！其实，去年认识了一个女生，虽然接触不多，但我也不知道为什么对她有莫名的好感。从小到大，我都没有喜欢过一个女孩，我曾经一度以为，我是一个没有心的人，不懂得什么叫喜欢，因为我真的不知道喜欢一个人是什么感觉，直到遇见了她。对不起，内心戏有点多了，这也许并不是喜欢，只是有好感吧，又或者，这只是一个我想象中的女生，因为我已经一年没见过她了，只在微信聊过几句学习上的事。甚至她可能已经有男朋友了吧？笑死，我真是太可笑了！那就定一个目标吧，如果知道明年她还没有对象，我就鼓起勇气真正地走近她，至少不留遗憾。</p><p>3年的疫情终于迎来了转机，虽然我在放开后第一波就感染了，过程还很难受，好在很快就恢复了。身边越来越多的亲戚朋友都感染了，倒是没有听说有严重的，但是现实中肯定还是有很多重症。身处时代的漩涡中，作为普通人，我们无可奈何，只能尽力而为，保护好自己和所爱的人。</p><p>可是，阴霾总会过去的！我不是天生的乐观派，但我依旧相信希望，人总得有点希望。虽然这世间的一切本来不属于某个人，也终将不属于某个人。虽然我们可能经历苦难，面对疾病，遭遇挫折，背负谩骂，可是那又怎么样呢？宇宙那么大，我们何其渺小，就让我们做颗遥远恒星，隐约在茫茫天际，闪烁着微光足矣。</p><p>愿我所爱，万事胜意！</p><p>愿爱我的人，永远幸福！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）&lt;/p&gt;
&lt;p&gt;翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++11：longlong超长整型和nullptr初始化空指针</title>
    <link href="http://yoursite.com/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/</id>
    <published>2022-12-31T00:42:06.000Z</published>
    <updated>2022-12-31T01:31:44.597Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。<a id="more"></a></p><h2 id="1-C-11：long-long-超长整型"><a href="#1-C-11：long-long-超长整型" class="headerlink" title="1. C++11：long long 超长整型"></a>1. C++11：long long 超长整型</h2><p>C++ 11 标准中，基于整数大小的考虑，共提供了如下表所示的这些数据类型。与此同时，标准中还明确限定了各个数据类型最少占用的位数。</p><div class="table-container"><table><thead><tr><th>整数类型</th><th>等价类型</th><th>C++11标准规定占用最少位数</th></tr></thead><tbody><tr><td>short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short int</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned short</td><td>unsigned short int（无符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned short int</td><td>unsigned short int（无符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned</td><td>unsigned int（无符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned int</td><td>unsigned int（无符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long int</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>signed long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>signed long int</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>unsigned long</td><td>unsigned long int（无符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>unsigned long int</td><td>unsigned long int（无符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>long long int（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>signed long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>signed long long int（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>unsigned long long（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>unsigned long long int（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td>至少 64 位（8 个字节）</td></tr></tbody></table></div><blockquote><p>C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。不过需要注意的是，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</p></blockquote><p>在上表罗列的这些数据类型中，long long 超长整型是 C++ 11 标准新添加的。其实早在 1995 年，就有人提议将 long long 整形写入 C++ 98 标准，但被委员会拒绝了。而后 long long 整形被 C99 标准（C语言标准之一）采纳，并逐渐被很多编译器支持，于是 C++ 标准委员会重新决定将 long long 整形写入 C++ 11 标准中。</p><p>如同 long 类型整数需明确标注 “L” 或者 “l” 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p><ul><li>对于有符号 long long 整形，后缀用 “LL” 或者 “ll” 标识。例如，”10LL” 就表示有符号超长整数 10；</li><li>对于无符号 long long 整形，后缀用 “ULL”、”ull”、”Ull” 或者 “uLL” 标识。例如，”10ULL” 就表示无符号超长整数 10。</li></ul><blockquote><p>如果不添加任何标识，则所有的整数都会默认为 int 类型。</p></blockquote><p>对于 long long 类型来说，如果想了解当前平台上 long long 整形的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：<br>1）LLONG_MIN：代表当前平台上最小的 long long 类型整数；<br>2）LLONG_MAX：代表当前平台上最大的 long long 类型整数；<br>3）ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"long long最大值："</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">" "</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt;<span class="string">"long long最小值："</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt; <span class="string">"unsigned long long最大值："</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为（不唯一）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">-9223372036854775808</span> <span class="number">8000000000000000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最小值：<span class="number">9223372036854775807</span> <span class="number">7f</span>ffffffffffffff</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">18446744073709551615</span> ffffffffffffffff</span><br></pre></td></tr></table></figure><p>此程序中，输出了各最大值和最小值对应的十六进制，显然在当前平台（Windows10 64位操作系统）上，long long 超长整型占用 64 位（也就是 16 个字节）的存储空间。</p><h2 id="2-C-11：nullptr-初始化空指针"><a href="#2-C-11：nullptr-初始化空指针" class="headerlink" title="2. C++11：nullptr 初始化空指针"></a>2. C++11：nullptr 初始化空指针</h2><p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p><blockquote><p>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p></blockquote><p>C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。<br>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p><p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="number">0</span>);</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">int</span> n</span><br></pre></td></tr></table></figure><p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。<br>C++ 98/03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isnull( (<span class="keyword">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line">isnull( (<span class="keyword">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure><p>如此，才会成功调用我们预期的函数。</p><p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。</p><blockquote><p>在使用 nullptr 之前，需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，则需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std=c++0x 编译选项）。</p></blockquote><p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p><p>值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p><p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    isnull(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">void</span>*c</span><br></pre></td></tr></table></figure><p>借助执行结果不难看出，由于 nullptr 无法隐式转换为整形，而可以隐式匹配指针类型，因此执行结果和我们的预期相符。</p><p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：constexpr关键字</title>
    <link href="http://yoursite.com/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-12-30T02:17:44.000Z</published>
    <updated>2022-12-30T03:08:35.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-常量表达式"><a href="#1-C-常量表达式" class="headerlink" title="1. C++常量表达式"></a>1. C++常量表达式</h2><p>constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。</p><p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。<a id="more"></a></p><p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure><p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p><p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。而常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p><blockquote><p>注意：获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p></blockquote><h2 id="2-constexpr修饰普通变量"><a href="#2-constexpr修饰普通变量" class="headerlink" title="2. constexpr修饰普通变量"></a>2. constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：2</p><blockquote><p>注意：可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p></blockquote><p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p><blockquote><p>需要注意的是，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。但我们必须清楚，const 和 constexpr 并不相同。</p><p>另外需要注意的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p></blockquote><h2 id="3-constexpr修饰函数"><a href="#3-constexpr修饰函数" class="headerlink" title="3. constexpr修饰函数"></a>3. constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。但需要注意，constexpr 并非可以修改任意函数的返回值，一个函数要想成为常量表达式函数，必须满足如下 4 个条件：</p><p>1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。如下是正确的定义 display() 常量表达式函数的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p><p>2) 该函数必须有返回值，即函数的返回值类型不能是 void。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p><p>3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; noconst_dis(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：可尝试将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p></blockquote><p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p><p>4) return 返回的表达式必须是常量表达式，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p><blockquote><p>注意：在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的。</p></blockquote><h2 id="4-constexpr修饰类的构造函数"><a href="#4-constexpr修饰类的构造函数" class="headerlink" title="4. constexpr修饰类的构造函数"></a>4. constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p><p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    constexpr myType(char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p><blockquote><p>注意：constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p></blockquote><p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr myType(const char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.getname();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.getage();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p></blockquote><h2 id="5-constexpr修饰模板函数"><a href="#5-constexpr修饰模板函数" class="headerlink" title="5. constexpr修饰模板函数"></a>5. constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> = <span class="title">dispaly</span>(<span class="title">stu</span>);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret.name &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = dispaly(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p><ul><li>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li><li>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-C-常量表达式&quot;&gt;&lt;a href=&quot;#1-C-常量表达式&quot; class=&quot;headerlink&quot; title=&quot;1. C++常量表达式&quot;&gt;&lt;/a&gt;1. C++常量表达式&lt;/h2&gt;&lt;p&gt;constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。&lt;/p&gt;
&lt;p&gt;所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：for循环（基于范围的循环）</title>
    <link href="http://yoursite.com/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/</id>
    <published>2022-12-29T01:18:12.000Z</published>
    <updated>2022-12-29T12:18:25.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-98-03标准的for循环"><a href="#1-C-98-03标准的for循环" class="headerlink" title="1. C++ 98/03标准的for循环"></a>1. C++ 98/03标准的for循环</h2><p>在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如，下面程序演示了用上述结构遍历数组和容器的具体实现过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc,arc+<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (iter = myvector.<span class="built_in">begin</span>(); iter != myvector.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/</span></span><br></pre></td></tr></table></figure><h2 id="2-C-11标准的for循环"><a href="#2-C-11标准的for循环" class="headerlink" title="2. C++ 11标准的for循环"></a>2. C++ 11标准的for循环</h2><p>在 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li><li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li></ul><p>可以看到，同 C++ 98/03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p><p>下面程序演示了如何用 C++ 11 标准中的 for 循环遍历上面程序定义的 arc 数组和 myvector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : arc) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/ !</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/!</span></span><br></pre></td></tr></table></figure><p>这里有以下 2 点需要说明：<br>1) 程序中在遍历 myvector 容器时，定义了 auto 类型的 ch 变量，当编译器编译程序时，会通过 myvector 容器中存储的元素类型自动推导出 ch 为 char 类型。注意，这里的 ch 不是迭代器类型，而表示的是 myvector 容器中存储的每个元素。</p><p>2) 仔细观察程序的输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为 myvector 容器中没有存储 ‘\0’。</p><h3 id="2-1-遍历用-大括号初始化的列表"><a href="#2-1-遍历用-大括号初始化的列表" class="headerlink" title="2.1 遍历用{}大括号初始化的列表"></a>2.1 遍历用<code>{}</code>大括号初始化的列表</h3><p>新语法格式的 for 循环还支持遍历用<code>{}</code>大括号初始化的列表，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2-2-declaration-参数处定义引用形式的变量"><a href="#2-2-declaration-参数处定义引用形式的变量" class="headerlink" title="2.2 declaration 参数处定义引用形式的变量"></a>2.2 declaration 参数处定义引用形式的变量</h3><p>在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdef</span><br></pre></td></tr></table></figure><p>此程序中先后使用了 2 个新语法格式的 for 循环，其中前者用于修改 myvector 容器中各个元素的值，后者用于输出修改后的 myvector 容器中的各个元素。</p><p>既然 declaration 参数既可以定义普通形式的变量，也可以定义引用形式的变量，应该如何选择呢？其实很简单，如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-C-98-03标准的for循环&quot;&gt;&lt;a href=&quot;#1-C-98-03标准的for循环&quot; class=&quot;headerlink&quot; title=&quot;1. C++ 98/03标准的for循环&quot;&gt;&lt;/a&gt;1. C++ 98/03标准的for循环&lt;/h2&gt;&lt;p&gt;在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(表达式 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; 表达式 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; 表达式 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//循环体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：非受限联合体（union）</title>
    <link href="http://yoursite.com/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/</id>
    <published>2022-12-28T01:54:11.000Z</published>
    <updated>2022-12-28T02:31:44.155Z</updated>
    
    <content type="html"><![CDATA[<p>在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p><a id="more"></a><p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> T&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p><h2 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h2><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++11 取消了这种限制。</p><p>POD 是 C++ 中一个比较重要的概念，POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：<br>1) 没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</p><p>2) 不能包含虚函数和虚基类。</p><p>3) 非静态成员必须声明为 public。</p><p>4) 类中的第一个非静态成员的类型与其基类不同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure><p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p><p>5) 在类或者结构体继承时，满足以下两种情况之一：</p><ul><li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li><li>基类有非静态成员，而派生类没有非静态成员。</li></ul><p>比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; <span class="keyword">int</span> n1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span> :</span> B2 &#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure><p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p><p>6) 所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p><p>7) 此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p><h2 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h2><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p><h2 id="3-非受限联合体的赋值注意事项"><a href="#3-非受限联合体的赋值注意事项" class="headerlink" title="3. 非受限联合体的赋值注意事项"></a>3. 非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。这条规则可能导致对象构造失败，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p><p>解决上面问题的一般需要用到 placement new，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U() &#123; <span class="keyword">new</span>(&amp;s) <span class="built_in">string</span>; &#125;</span><br><span class="line">    ~U() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p><h3 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h3><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。placement new 的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) ClassConstruct(...)</span><br></pre></td></tr></table></figure><p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p><h2 id="4-非受限联合体的匿名声明和“枚举式类”"><a href="#4-非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="4. 非受限联合体的匿名声明和“枚举式类”"></a>4. 非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U&#123;</span><br><span class="line">  <span class="keyword">union</span> &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p><p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Type &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    Singer(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : s(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    Singer(<span class="keyword">int</span> i) : id(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, <span class="built_in">size</span>);</span><br><span class="line">        name[s] = <span class="string">'\0'</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singer(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    Singer(<span class="number">310217</span>);</span><br><span class="line">    Singer(<span class="string">"J Michael"</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：列表初始化</title>
    <link href="http://yoursite.com/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-12-27T01:23:31.000Z</published>
    <updated>2022-12-27T02:29:03.262Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++98/03 中，对象初始化方法有很多种，如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。<a id="more"></a></p><blockquote><p>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p></blockquote><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98/03 可以使用初始化列表（initializer list）进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，比如下面的代码：通过初始化列表初始化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: 'Foo::Foo(const Foo &amp;)' is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。<br>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。<br>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<br>a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p><p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure><blockquote><p>在初始化时，<code>{}</code>前面的等于号是否书写对初始化行为没有影响。</p></blockquote><p>另外，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。<br>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。<br>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p><p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span>, <span class="keyword">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p><p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++98/03 中，对象初始化方法有很多种，如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始化列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i_arr[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;;  &lt;span class=&quot;comment&quot;&gt;//普通数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; a = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;#123; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125; &amp;#125;;  &lt;span class=&quot;comment&quot;&gt;//POD类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//拷贝初始化（copy-initialization）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Foo(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; foo = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//需要拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//直接初始化（direct-initialization）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Foo &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：tuple元组</title>
    <link href="http://yoursite.com/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/"/>
    <id>http://yoursite.com/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/</id>
    <published>2022-12-26T02:48:05.000Z</published>
    <updated>2022-12-26T02:57:51.952Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p><p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p><a id="more"></a><h2 id="1-tuple对象的创建"><a href="#1-tuple对象的创建" class="headerlink" title="1. tuple对象的创建"></a>1. tuple对象的创建</h2><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</tuple></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br></pre></td></tr></table></figure><p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p><h4 id="1-1-类的构造函数"><a href="#1-1-类的构造函数" class="headerlink" title="1.1 类的构造函数"></a>1.1 类的构造函数</h4><p>tuple 模板类提供有很多构造函数，包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line">tuple (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span> <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span>      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span>  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span>       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span>            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    std::tuple&lt;int, char&gt; second(first);                     // 2)   second&#123;&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; third(std::make_tuple(20, 'b'));   // 3)   third&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;long, char&gt; fourth(third);                    // 4)的左值方式, fourth&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; fifth(10, 'a');                    // 5)的右值方式, fifth&#123;10.'a'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; sixth(std::make_pair(30, 'c'));    // 6)的右值方式, sixth&#123;30,''c&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-make-tuple-函数"><a href="#1-2-make-tuple-函数" class="headerlink" title="1.2 make_tuple()函数"></a>1.2 make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</tuple></p><p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>,<span class="string">'a'</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>; <span class="keyword">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = <span class="built_in">std</span>::make_tuple (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure><p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p><h2 id="2-tuple常用函数"><a href="#2-tuple常用函数" class="headerlink" title="2. tuple常用函数"></a>2. tuple常用函数</h2><p>为了方便在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数，<tuple> 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如下表所示：</tuple></p><div class="table-container"><table><thead><tr><th>函数或类模板</th><th>描 述</th></tr></thead><tbody><tr><td>tup1.swap(tup2) swap(tup1, tup2)</td><td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。</tuple></td></tr><tr><td>get<num>(tup)</num></td><td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</tuple></td></tr><tr><td>tuple_size<type>::value</type></td><td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</tuple></td></tr><tr><td>tuple_element<I, type>::type</I,></td><td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</tuple></td></tr><tr><td>forward_as_tuple<args...></args...></td><td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td></tr><tr><td>tie(args…) = tup</td><td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</tuple></td></tr><tr><td>tuple_cat(args…)</td><td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</tuple></td></tr></tbody></table></div><blockquote><p>tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、&lt;、&gt;、&gt;=、&lt;= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。</p></blockquote><p>以下程序演示了上表中一部分函数模板和类模板的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 'x'</span></span><br><span class="line">    std::tuple&lt;int, char&gt; mytuple(10, 'x');</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple(<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">double</span> mydou;</span><br><span class="line">    <span class="keyword">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    <span class="built_in">std</span>::tie(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = <span class="built_in">std</span>::tuple_cat(mytuple, bar);</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> x</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。&lt;/p&gt;
&lt;p&gt;tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：支持函数模板的默认模板参数</title>
    <link href="http://yoursite.com/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/</id>
    <published>2022-12-25T11:13:04.000Z</published>
    <updated>2022-12-25T11:19:10.033Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++98/03 标准中，类模板可以有默认的模板参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是却不支持函数的默认模板参数：<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;  <span class="comment">// error in C++98/03: default template arguments</span></span><br><span class="line"><span class="keyword">void</span> func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p><p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p><p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R func(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int；最后 func<double,int>(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</double,int></char></p><p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">double</span>&gt;</span><br><span class="line"><span class="keyword">void</span> func(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    func(<span class="string">'c'</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    func();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T=char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。由此不难看出，编译器的自动推导能力并没有想象的那么强大。</p><p>总的来说，C++11 支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++98/03 标准中，类模板可以有默认的模板参数，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; U = &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, U N = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct Foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是却不支持函数的默认模板参数：&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：返回值类型后置（跟踪返回值类型）</title>
    <link href="http://yoursite.com/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/</id>
    <published>2022-12-24T02:54:10.000Z</published>
    <updated>2022-12-24T03:03:36.357Z</updated>
    
    <content type="html"><![CDATA[<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。</p><a id="more"></a><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。比如如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure><p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p><p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) add(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，直接像上面这样写是编译不过的。因为 t、u 在参数列表中，而 C++ 的返回值是前置语法，在返回值定义的时候参数变量还不存在。<br>可行的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(T() + U()) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。因此，<strong>在 C++11 中增加了返回类型后置（trailing-return-type，又称跟踪返回类型）语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</strong></p><p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步说明这个语法，再看另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto func(T&amp; val) -&gt; decltype(foo(val))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说前一个例子中的 add 使用 C++98/03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>图像轮廓提取</title>
    <link href="http://yoursite.com/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"/>
    <id>http://yoursite.com/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/</id>
    <published>2022-12-23T09:11:13.000Z</published>
    <updated>2022-12-23T09:33:19.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、轮廓提取"><a href="#1、轮廓提取" class="headerlink" title="1、轮廓提取"></a>1、轮廓提取</h2><p>轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。<a id="more"></a></p><h2 id="2、轮廓提取方法及Python实现"><a href="#2、轮廓提取方法及Python实现" class="headerlink" title="2、轮廓提取方法及Python实现"></a>2、轮廓提取方法及Python实现</h2><h3 id="2-1-掏空内部点法"><a href="#2-1-掏空内部点法" class="headerlink" title="2.1 掏空内部点法"></a>2.1 掏空内部点法</h3><p>掏空内部点法的原理非常简单：如果原图中有一点为黑，且它的8个相邻点皆为黑色，则将该点删除，否则认为该点在图像的边缘，需要保留。依次处理图像中每一个像素，则最后留下来的就是图像的轮廓。对于非二值图像，需要先进行二值化处理。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_contour</span><span class="params">(bin_img)</span>:</span></span><br><span class="line">    contour_img = np.zeros(shape=(bin_img.shape),dtype=np.uint8)</span><br><span class="line">    contour_img += <span class="number">255</span></span><br><span class="line">    h = bin_img.shape[<span class="number">0</span>]</span><br><span class="line">    w = bin_img.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,h<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,w<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span>(bin_img[i][j]==<span class="number">0</span>):</span><br><span class="line">                contour_img[i][j] = <span class="number">0</span></span><br><span class="line">                sum = <span class="number">0</span></span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> sum ==  <span class="number">0</span>:</span><br><span class="line">                    contour_img[i][j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contour_img</span><br></pre></td></tr></table></figure><p>效果如下（左侧是Otsu二值化图像；右侧是轮廓图像）：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/1.png" alt></p><h3 id="2-2-opencv-python中轮廓提取方法的应用"><a href="#2-2-opencv-python中轮廓提取方法的应用" class="headerlink" title="2.2 opencv-python中轮廓提取方法的应用"></a>2.2 opencv-python中轮廓提取方法的应用</h3><p>（1）opencv-python中使用cv2.findContours函数来检测图像的边缘，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</span><br></pre></td></tr></table></figure><p><strong>参数说明如下：</strong><br>image：输入图像；<br>mode：轮廓检索模式；<br>method：轮廓逼近方法；<br>contours：返回的轮廓；<br>hierachy：每条轮廓对应的属性；<br>offset：每个轮廓点移动的可选偏移量。<br>备注：image参数需要是二值图，而不是灰度图，返回结果是等高线和层次结构。</p><p><strong>轮廓检索模式：</strong><br>cv2.RETR_EXTERNAL：表示只检测外轮廓；<br>cv2.RETR_LIST：检测的轮廓，不建立等级关系；<br>cv2.RETR_CCOMP：建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层；<br>cv2.RETR_TREE：建立一个等级树结构的轮廓。</p><p><strong>轮廓逼近方法：</strong><br>cv2.CHAIN_APPROX_NONE：存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即 max(abs(x1-x2),abs(y2-y1))==1，一般不会用到；<br>cv2.CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息；<br>cv2.CHAIN_APPROX_TC89_L1，cv2.CV_CHAIN_APPROX_TC89_KCOS：使用teh-Chinl chain近似算法。</p><p>（2）轮廓发现之后，还要通过cv2.drawContours函数绘制轮廓，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])</span><br></pre></td></tr></table></figure><p><strong>参数说明如下：</strong><br>image：输入图像；<br>contours：轮廓，在Python中是一个list，就是cv2.findContours函数找出来的点集，一个列表；<br>contourIdx：轮廓的索引，指定绘制轮廓list中的哪条轮廓，要绘制所有轮廓，传递-1；<br>color：颜色；<br>thickness：厚度，如果是-1，表示填充；<br>lineType：线型；<br>hierarchy：层次结构的可选信息；<br>maxLevel：绘制轮廓的最大级别，0：仅绘制指定的轮廓，1：绘制轮廓和所有嵌套轮廓，2：绘制轮廓，所有嵌套轮廓，所有嵌套到嵌套的轮廓；<br>offset：轮廓偏移参数。</p><p>根据上面两个函数，测试代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：读入图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：对图像做灰度处理</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：对图像做二值化处理</span></span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：获得图像的轮廓值</span></span><br><span class="line">contours, heriachy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步：绘制图像轮廓</span></span><br><span class="line">img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">res = cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(res, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'contour'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/2.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、轮廓提取&quot;&gt;&lt;a href=&quot;#1、轮廓提取&quot; class=&quot;headerlink&quot; title=&quot;1、轮廓提取&quot;&gt;&lt;/a&gt;1、轮廓提取&lt;/h2&gt;&lt;p&gt;轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="轮廓提取" scheme="http://yoursite.com/tags/%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>C++11：lambda匿名函数</title>
    <link href="http://yoursite.com/2022/11/27/C-11%EF%BC%9Alambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2022/11/27/C-11%EF%BC%9Alambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2022-11-27T14:55:41.000Z</published>
    <updated>2022-11-28T08:02:25.271Z</updated>
    
    <content type="html"><![CDATA[<p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p><a id="more"></a><h2 id="1-lambda匿名函数的定义"><a href="#1-lambda匿名函数的定义" class="headerlink" title="1. lambda匿名函数的定义"></a>1. lambda匿名函数的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)<span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type&#123;statement&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>[capture]：捕捉列表，[] 是lambda引出符，编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表用于捕捉父域中的变量以供lambda函数使用，捕捉列表可以由多个项组成，用”,”分割。[var]表示以值传递方式捕捉父域中的变量var，[=]表示以值传递方式捕捉父域中的所有变量（包括this），[&amp;var]表示以引用传递方式捕捉父域中的变量var，[&amp;]表示以引用传递方式捕捉父域中的所有变量（包括this）,[this]表示以值传递方式捕捉当前的this指针。</li><li>(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号()一起省略。</li><li>mutable：mutable修饰符，默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li><li>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，不需要返回值的时候可以连同符号-&gt;一起省略。在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li><li>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li></ul><h3 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h3><div class="table-container"><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td></tr><tr><td>[=]</td><td>只有一个 = 等号，表示以值传递的方式导入所有外部变量；</td></tr><tr><td>[&amp;]</td><td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td></tr><tr><td>[val1,val2,…]</td><td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td>[&amp;val1,&amp;val2,…]</td><td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td>[val,&amp;val2,…]</td><td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr><tr><td>[=,&amp;val1,…]</td><td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的 this 指针。</td></tr></tbody></table></div><blockquote><p> 注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p></blockquote><h3 id="最简单的lambda匿名函数"><a href="#最简单的lambda匿名函数" class="headerlink" title="最简单的lambda匿名函数"></a>最简单的lambda匿名函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure><p>此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，这是一个没有任何功能的 lambda 匿名函数。</p><h2 id="2-lambda匿名函数的使用"><a href="#2-lambda匿名函数的使用" class="headerlink" title="2. lambda匿名函数的使用"></a>2. lambda匿名函数的使用</h2><h3 id="2-1-lambda匿名函数的定义和使用"><a href="#2-1-lambda匿名函数的定义和使用" class="headerlink" title="2.1 lambda匿名函数的定义和使用"></a>2.1 lambda匿名函数的定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 对数组 num 中的元素进行升序排序</span></span><br><span class="line">    sort(num, num + <span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> x &lt; y; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。而如果使用普通函数，需以如下代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_up</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 对数组 num 中的元素进行升序排序</span></span><br><span class="line">    sort(num, num + <span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序中 sort_up() 函数的功能和上一个程序中的 lambda 匿名函数完全相同。显然在类似的场景中，使用 lambda 匿名函数更有优势。</p><p>除此之外，虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">display</span> = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; <span class="keyword">void</span>&#123;<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">// 调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 输出：10 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p><h3 id="2-2-值传递和引用传递的区别"><a href="#2-2-值传递和引用传递的区别" class="headerlink" title="2.2 值传递和引用传递的区别"></a>2.2 值传递和引用传递的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda1:\n"</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=] &#123;</span><br><span class="line">        <span class="comment">// 全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda2:\n"</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;] &#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lambda1:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">lambda2:</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。其中，lambda1 匿名函数是以 [=] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</p><h3 id="2-3-执行抛出异常类型"><a href="#2-3-执行抛出异常类型" class="headerlink" title="2.3 执行抛出异常类型"></a>2.3 执行抛出异常类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="keyword">throw</span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        except();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获到了整形异常"</span>;<span class="comment">// 输出：捕获到了整形异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p><p>在此基础上，再看一下反例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="keyword">throw</span>(<span class="keyword">char</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        except1();</span><br><span class="line">        except2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获到了整形异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p><blockquote><p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>图像滤波</title>
    <link href="http://yoursite.com/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/"/>
    <id>http://yoursite.com/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/</id>
    <published>2022-10-12T09:04:16.000Z</published>
    <updated>2022-10-12T09:15:52.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图像滤波"><a href="#1-图像滤波" class="headerlink" title="1. 图像滤波"></a>1. 图像滤波</h1><p>图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</p><p>图像滤波按图像域可分为两种类型：</p><p>邻域滤波(Spatial Domain Filter)，其本质是数字窗口上的数学运算。一般用于图像平滑、图像锐化、特征提取(如纹理测量、边缘检测)等，邻域滤波使用邻域算子——利用给定像素周围像素值以决定此像素最终输出的一种算子。邻域滤波方式又分为线性滤波和非线性滤波，其中线性滤波包括均值滤波、方框滤波和高斯滤波等，非线性滤波包括中值滤波和双边滤波等。</p><p>频域滤波(Frequency Domain Filter)，其本质是对像素频率的修改。一般用于降噪、重采样、图像压缩等。按图像频率滤除效果主要分为两种类型：低通滤波（滤除原图像的高频成分，即模糊图像边缘与细节）和高通滤波（滤除原图像的低频成分，即图像锐化）。</p><a id="more"></a><h1 id="2-图像滤波的常用方法"><a href="#2-图像滤波的常用方法" class="headerlink" title="2. 图像滤波的常用方法"></a>2. 图像滤波的常用方法</h1><h2 id="2-1-均值滤波"><a href="#2-1-均值滤波" class="headerlink" title="2.1 均值滤波"></a>2.1 均值滤波</h2><p>均值滤波采用多次测量取平均值的思想，用每一个像素周围的像素的平均值代替自身。均值滤波是方框滤波归一化后的特殊情况。</p><p>取卷积核（Kernel）区域下所有像素的平均值并替换中心元素，如下公式：</p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.1.png" alt></p><p>优点：能够将受到噪声影响的像素使用该噪声周围的像素值进行修复，对椒盐噪声的滤除比较好。<br>缺点：不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊。</p><h2 id="2-2-方框滤波"><a href="#2-2-方框滤波" class="headerlink" title="2.2 方框滤波"></a>2.2 方框滤波</h2><p>与均值滤波不同的是，方框滤波不会计算像素的均值。在均值滤波中，滤波结果的像素值是任意一个点的邻域平均值，等于各邻域像素值之和除以邻域面积。而在方框滤波中，可以自由选择是否对均值滤波的结果进行归一化，即可以自由选择滤波结果是邻域像素值之和的平均值，还是邻域像素值之和。</p><p>公式如下：</p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.2.png" alt></p><p>当normalize=True时，与均值滤波结果相同；<br>当normalize=False时，表示对加和后的结果不进行平均操作，大于255的使用255表示。</p><h2 id="2-3-高斯滤波"><a href="#2-3-高斯滤波" class="headerlink" title="2.3 高斯滤波"></a>2.3 高斯滤波</h2><p>高斯滤波(Gauss Filter)基于二维高斯核函数。用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。高斯滤波主要用来去除高斯噪声。</p><p>高斯滤波具有在保持细节的条件下进行噪声滤波的能力，因此广泛应用于图像降噪中，但其效率比均值滤波低。</p><h2 id="2-4-中值滤波"><a href="#2-4-中值滤波" class="headerlink" title="2.4 中值滤波"></a>2.4 中值滤波</h2><p>中值滤波将待处理的像素周围像素从小到大排序，取中值代替该像素。</p><p>优点：去除脉冲噪声、椒盐噪声的同时又能保留图像边缘细节。<br>缺点：当卷积核较大时，仍然使得图像变得模糊，而且计算量很大。</p><h2 id="2-5-双边滤波"><a href="#2-5-双边滤波" class="headerlink" title="2.5 双边滤波"></a>2.5 双边滤波</h2><p>因为高斯滤波把距离设为权重，设计滤波模板作为滤波系数，并且只考虑像素之间的空间位置关系，所以滤波结果丢失了边缘信息。</p><p>双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。</p><h2 id="2-6-低通滤波"><a href="#2-6-低通滤波" class="headerlink" title="2.6 低通滤波"></a>2.6 低通滤波</h2><p>规则为低频信息能正常通过，而超过设定临界值的高频信息则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序（目的）而改变。</p><p>低通滤波，通过了低频信息，保留了图像背景和基本内容，图像边缘被阻挡，图像变模糊。</p><h2 id="2-7-高通滤波"><a href="#2-7-高通滤波" class="headerlink" title="2.7 高通滤波"></a>2.7 高通滤波</h2><p>规则为高频信息能正常通过，而低于设定临界值的低频信息则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序(目的)而改变。</p><p>高通滤波，通过了高频信息，提取了图像边缘和噪声。</p><h1 id="3-opencv-python中各种滤波方法的应用"><a href="#3-opencv-python中各种滤波方法的应用" class="headerlink" title="3. opencv-python中各种滤波方法的应用"></a>3. opencv-python中各种滤波方法的应用</h1><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line">img_blur = cv.blur(img, (<span class="number">3</span>,<span class="number">3</span>)) <span class="comment"># (3,3)代表卷积核尺寸，随着尺寸变大，图像会越来越模糊</span></span><br><span class="line">img_blur = cv.cvtColor(img_blur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方框滤波</span></span><br><span class="line">img_boxFilter1 = cv.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>,<span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment"># 当 normalize=True 时，与均值滤波结果相同</span></span><br><span class="line">img_boxFilter1 = cv.cvtColor(img_boxFilter1, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line">img_boxFilter2 = cv.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>,<span class="number">3</span>), normalize=<span class="literal">False</span>)</span><br><span class="line">img_boxFilter2 = cv.cvtColor(img_boxFilter2, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line">img_GaussianBlur= cv.GaussianBlur(img, (<span class="number">3</span>,<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 参数说明：(源图像，核大小，x方向的标准差，y方向的标准差)</span></span><br><span class="line">img_GaussianBlur = cv.cvtColor(img_GaussianBlur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line">img_medianBlur = cv.medianBlur(img, <span class="number">3</span>)</span><br><span class="line">img_medianBlur = cv.cvtColor(img_medianBlur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双边滤波</span></span><br><span class="line"><span class="comment"># 参数说明：(源图像，核大小，sigmaColor，sigmaSpace)</span></span><br><span class="line">img_bilateralFilter=cv.bilateralFilter(img, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">img_bilateralFilter = cv.cvtColor(img_bilateralFilter, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'img_blur'</span>, <span class="string">'img_boxFilter1'</span>, <span class="string">'img_boxFilter2'</span>,</span><br><span class="line">          <span class="string">'img_GaussianBlur'</span>, <span class="string">'img_medianBlur'</span>, <span class="string">'img_bilateralFilter'</span>]</span><br><span class="line">images = [img_blur, img_boxFilter1, img_boxFilter2, img_GaussianBlur, img_medianBlur, img_bilateralFilter]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i+<span class="number">1</span>), plt.imshow(images[i]), plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通滤波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Low_Pass_Filter</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    <span class="comment">#img = cv.imread('srcImg_path', 0)</span></span><br><span class="line">    img = np.array(Image.open(srcImg_path))</span><br><span class="line">    img = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶变换</span></span><br><span class="line">    dft = cv.dft(np.float32(img), flags = cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    fshift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置低通滤波器</span></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment"># 中心位置</span></span><br><span class="line">    mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 掩膜图像和频谱图像乘积</span></span><br><span class="line">    f = fshift * mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶逆变换</span></span><br><span class="line">    ishift = np.fft.ifftshift(f)</span><br><span class="line">    iimg = cv.idft(ishift)</span><br><span class="line">    res = cv.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">High_Pass_Filter</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    <span class="comment">#img = cv.imread(srcImg_path, 0)</span></span><br><span class="line">    img = np.array(Image.open(srcImg_path))</span><br><span class="line">    img = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶变换</span></span><br><span class="line">    dft = cv.dft(np.float32(img), flags = cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    fshift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置高通滤波器</span></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment"># 中心位置</span></span><br><span class="line">    mask = np.ones((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 掩膜图像和频谱图像乘积</span></span><br><span class="line">    f = fshift * mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶逆变换</span></span><br><span class="line">    ishift = np.fft.ifftshift(f)</span><br><span class="line">    iimg = cv.idft(ishift)</span><br><span class="line">    res = cv.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">img_Low_Pass_Filter = Low_Pass_Filter(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img_Low_Pass_Filter, <span class="string">'gray'</span>), plt.title(<span class="string">'img_Low_Pass_Filter'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">img_High_Pass_Filter = High_Pass_Filter(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(img_High_Pass_Filter, <span class="string">'gray'</span>), plt.title(<span class="string">'img_High_Pass_Filter'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>滤波图像如下：</p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.8.1.png" alt></p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.8.2.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-图像滤波&quot;&gt;&lt;a href=&quot;#1-图像滤波&quot; class=&quot;headerlink&quot; title=&quot;1. 图像滤波&quot;&gt;&lt;/a&gt;1. 图像滤波&lt;/h1&gt;&lt;p&gt;图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。&lt;/p&gt;
&lt;p&gt;图像滤波按图像域可分为两种类型：&lt;/p&gt;
&lt;p&gt;邻域滤波(Spatial Domain Filter)，其本质是数字窗口上的数学运算。一般用于图像平滑、图像锐化、特征提取(如纹理测量、边缘检测)等，邻域滤波使用邻域算子——利用给定像素周围像素值以决定此像素最终输出的一种算子。邻域滤波方式又分为线性滤波和非线性滤波，其中线性滤波包括均值滤波、方框滤波和高斯滤波等，非线性滤波包括中值滤波和双边滤波等。&lt;/p&gt;
&lt;p&gt;频域滤波(Frequency Domain Filter)，其本质是对像素频率的修改。一般用于降噪、重采样、图像压缩等。按图像频率滤除效果主要分为两种类型：低通滤波（滤除原图像的高频成分，即模糊图像边缘与细节）和高通滤波（滤除原图像的低频成分，即图像锐化）。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像二值化</title>
    <link href="http://yoursite.com/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/"/>
    <id>http://yoursite.com/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/</id>
    <published>2022-10-11T10:26:05.000Z</published>
    <updated>2022-10-11T11:50:42.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图像二值化"><a href="#1-图像二值化" class="headerlink" title="1. 图像二值化"></a>1. 图像二值化</h1><p>图像二值化就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。</p><p>要得到二值化图像，首先要把图像灰度化，然后将256个亮度等级的灰度图像通过适当的阈值选取而获得仍然可以反映图像整体和局部特征的二值化图像。所有灰度大于或等于阈值的像素被判定为属于特定物体，其灰度值为255，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。</p><a id="more"></a><h1 id="2-图像二值化方法及Python实现"><a href="#2-图像二值化方法及Python实现" class="headerlink" title="2. 图像二值化方法及Python实现"></a>2. 图像二值化方法及Python实现</h1><p>比较常用的二值化方法有：简单二值法，平均值法，双峰法和OTSU法等。</p><h2 id="2-1-简单二值法"><a href="#2-1-简单二值法" class="headerlink" title="2.1 简单二值法"></a>2.1 简单二值法</h2><p>将图像灰度化后，我们选择127(灰度值范围的一半)作为阈值，即将像素值大于127的像素值全部设为255，小于127的全部设为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Easy_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    img_gray[img_gray&gt;<span class="number">127</span>] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=<span class="number">127</span>] = <span class="number">0</span></span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Easy_Binarization'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.1.png" alt></p><h2 id="2-2-平均值法"><a href="#2-2-平均值法" class="headerlink" title="2.2 平均值法"></a>2.2 平均值法</h2><p>为了应对每张图片的灰度值大不相同，阈值取为图像本身的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mean_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    threshold = np.mean(img_gray)</span><br><span class="line">    print(threshold)</span><br><span class="line">    img_gray[img_gray&gt;threshold] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=threshold] = <span class="number">0</span></span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Mean_Binarization'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.2.png" alt></p><p>实验中该方法计算的阈值为123。</p><h2 id="2-3-双峰法"><a href="#2-3-双峰法" class="headerlink" title="2.3 双峰法"></a>2.3 双峰法</h2><p>直方图是图像的重要特质，它可以帮助我们分析图像中的灰度变化。因此，如果物体与背景的灰度值对比明显，直方图就会包含双峰，它们分别为图像的前景和背景，而它们之间的谷底即为边缘附近相对较少数目的像素点，一般来讲，这个最小值就为最优二值化的分界点，通过这个点可以把前景和背景很好地分开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hist_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    hist = img_gray.flatten()</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.hist(hist,<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    cnt_hist = Counter(hist)</span><br><span class="line">    print(cnt_hist)</span><br><span class="line">    begin,end = cnt_hist.most_common(<span class="number">2</span>)[<span class="number">0</span>][<span class="number">0</span>],cnt_hist.most_common(<span class="number">2</span>)[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> begin &gt; end:</span><br><span class="line">        begin, end = end, begin</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;begin&#125;</span>: <span class="subst">&#123;end&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    cnt = np.iinfo(np.int16).max</span><br><span class="line">    threshold = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin,end+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> cnt_hist[i]&lt;cnt:</span><br><span class="line">            cnt = cnt_hist[i]</span><br><span class="line">            threshold = i</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;threshold&#125;</span>: <span class="subst">&#123;cnt&#125;</span>'</span>)</span><br><span class="line">    img_gray[img_gray&gt;threshold] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=threshold] = <span class="number">0</span></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.3.png" alt></p><p>实验中该方法得到的双峰为(145,154)，阈值为150。</p><h2 id="2-4-OTSU法"><a href="#2-4-OTSU法" class="headerlink" title="2.4 OTSU法"></a>2.4 OTSU法</h2><p>双峰法具有明显的缺陷，因为直方图是不连续的，有非常多尖峰和抖动，要找到准确的极值点十分困难。日本工程师大津展之为这个波谷找到了一个合适的数学表达，并于1979年发表。这个二值化方法称为大津算法（Otsu’s method）。</p><p>OTSU法也称作最大类间方差法，因为按照大津法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大。它被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致类间差别变小。因此,使类间方差最大的分割意味着错分概率最小。</p><p>具体计算阈值方法如下：<br>设阈值为t, 将原图转化成灰度图后，将其高与宽存于h,w，并将小于阈值的灰度值存储在前景front中，大于等于阈值的存在背景back中。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阈值：t</span></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">front = img[img &lt; t]</span><br><span class="line">back = img[img &gt;= t]</span><br></pre></td></tr></table></figure><p> 显然，前景与背景的长度和应与h, w的乘积相等，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(front) + len(back) == h * w.</span><br></pre></td></tr></table></figure><p>设前景像素数量占总像素数量的比重为frontP，背景像素数量占总像素数量的比重为backP，前景和背景的灰度平均值分别为frontMean和backMean，总平均灰度值为m，则方差公式可写成：</p><script type="math/tex; mode=display">v=frontP*(frontMean-m)^2+backP*(backMean-m)^2</script><p>又因为：</p><script type="math/tex; mode=display">m=frontP*frontMean+backP*backMean</script><p>上式可化简为：</p><script type="math/tex; mode=display">v=frontP*backP*(frontMean-backMean)^2</script><p>实验代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Otsu</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    threshold_t = <span class="number">0</span></span><br><span class="line">    max_g = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">        front = img[img &lt; t]</span><br><span class="line">        back = img[img &gt;= t]</span><br><span class="line">        front_p = len(front) / (h * w)</span><br><span class="line">        back_p = len(back) / (h * w)</span><br><span class="line">        front_mean = np.mean(front) <span class="keyword">if</span> len(front) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.</span></span><br><span class="line">        back_mean = np.mean(back) <span class="keyword">if</span> len(back) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.</span></span><br><span class="line">        </span><br><span class="line">        g = front_p * back_p * ((front_mean - back_mean)**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> g &gt; max_g:</span><br><span class="line">            max_g = g</span><br><span class="line">            threshold_t = t</span><br><span class="line">    print(<span class="string">f"threshold = <span class="subst">&#123;threshold_t&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    img[img &lt; threshold_t] = <span class="number">0</span></span><br><span class="line">    img[img &gt;= threshold_t] = <span class="number">255</span></span><br><span class="line">    plt.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Otsu'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>二值化图像如下：</p><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.4.png" alt></p><p><strong>对比以上四种方法可以发现，Otsu方法得到的二值化图像细节更多，图像更细腻。</strong></p><h1 id="3-opencv-python中二值化方法的应用"><a href="#3-opencv-python中二值化方法的应用" class="headerlink" title="3. opencv-python中二值化方法的应用"></a>3. opencv-python中二值化方法的应用</h1><p>在OpenCV中，分为简单的阈值分割与自适应阈值分割。</p><h2 id="3-1-简单阈值分割（Simple-Thresholding）"><a href="#3-1-简单阈值分割（Simple-Thresholding）" class="headerlink" title="3.1 简单阈值分割（Simple Thresholding）"></a>3.1 简单阈值分割（Simple Thresholding）</h2><p>函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval, dst = cv.threshold(src, thresh, maxval, type[, dst])</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一个参数src为原图，需要注意的是输入的图像需为灰度图。</span><br><span class="line">第二个参数thresh即为阈值，用于对像素值的分类(一般定义为<span class="number">127</span>)。</span><br><span class="line">第三个参数maxval是最大值，即超过阈值后所定义的值(<span class="number">255</span>)。</span><br><span class="line">第四个参数type，在Simple Thresholding中一共有五种不同的方式：</span><br><span class="line">cv.THRESH_BINARY</span><br><span class="line">cv.THRESH_BINARY_INV</span><br><span class="line">cv.THRESH_TRUNC</span><br><span class="line">cv.THRESH_TOZERO</span><br><span class="line">cv.THRESH_TOZERO_INV</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)</span><br><span class="line">ret,thresh1 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下图是5种方式的实际效果：</p><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/3.1.png" alt></p><h2 id="3-2-自适应阈值分割（Adaptive-Thresholding）"><a href="#3-2-自适应阈值分割（Adaptive-Thresholding）" class="headerlink" title="3.2 自适应阈值分割（Adaptive Thresholding）"></a>3.2 自适应阈值分割（Adaptive Thresholding）</h2><p>函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])</span><br></pre></td></tr></table></figure><p>其中src, maxValue和thresholdType与Simple Thresholding相同。</p><p>在自适应阈值分割中，adaptive method(阈值的计算方式)有两种：<br>cv.ADAPTIVE_THRESH_MEAN_C: 邻域面积(blockSize * blockSize)的平均值并减去C.<br>cv.ADAPTIVE_THRESH_GAUSSIAN_C: 邻域面积的高斯加权总和然后减去C.</p><p>下面是它们的实际效果(对于thresholdType在这里选择cv.THRESH_BINARY），测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)</span><br><span class="line">ret,th1 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,\</span><br><span class="line">            cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,\</span><br><span class="line">            cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>, <span class="string">'Simple Thresholding'</span>,</span><br><span class="line">            <span class="string">'Adaptive Mean Thresholding'</span>, <span class="string">'Adaptive Gaussian Thresholding'</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/3.2.png" alt></p><p>发现没有像之前otsu那样输出一张类似的图片，但是，它将图像中的边框描绘了出来，实际应用中这样的方式更适合处理文字形式的图片。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-图像二值化&quot;&gt;&lt;a href=&quot;#1-图像二值化&quot; class=&quot;headerlink&quot; title=&quot;1. 图像二值化&quot;&gt;&lt;/a&gt;1. 图像二值化&lt;/h1&gt;&lt;p&gt;图像二值化就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。&lt;/p&gt;
&lt;p&gt;要得到二值化图像，首先要把图像灰度化，然后将256个亮度等级的灰度图像通过适当的阈值选取而获得仍然可以反映图像整体和局部特征的二值化图像。所有灰度大于或等于阈值的像素被判定为属于特定物体，其灰度值为255，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像灰度化处理</title>
    <link href="http://yoursite.com/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/</id>
    <published>2022-10-10T12:29:56.000Z</published>
    <updated>2022-10-11T11:50:30.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图像灰度化"><a href="#1-图像灰度化" class="headerlink" title="1. 图像灰度化"></a>1. 图像灰度化</h1><p>在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255，当灰度为255的时候，表示最亮（纯白）；当灰度为0的时候，表示最暗（纯黑）。</p><p>灰度化的好处是：相较于彩色图像灰度图像占内存更小，运行速度更快；灰度图像后可以在视觉上增加对比，突出目标区域。</p><a id="more"></a><h1 id="2-图像灰度化处理方法"><a href="#2-图像灰度化处理方法" class="headerlink" title="2. 图像灰度化处理方法"></a>2. 图像灰度化处理方法</h1><p>图像灰度化处理有三种常用方法：最大值法、平均值法和加权平均法。</p><h2 id="2-1-最大值法"><a href="#2-1-最大值法" class="headerlink" title="2.1 最大值法"></a>2.1 最大值法</h2><p>最大值法，即直接取R,B,G三个分量中数值最大的分量的数值（0视为最小，255视为最大）。公式为：R=G=B=max(R,G,B)。</p><h2 id="2-2-平均值法"><a href="#2-2-平均值法" class="headerlink" title="2.2 平均值法"></a>2.2 平均值法</h2><p>平均值法，即取R,B,G三个分量中数值的均值。公式为：R=G=B=(R+G+B)/3。</p><h2 id="2-3-加权平均法"><a href="#2-3-加权平均法" class="headerlink" title="2.3 加权平均法"></a>2.3 加权平均法</h2><p>根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度图像：</p><script type="math/tex; mode=display">Gray(i,j)=0.299*R(i,j)+0.578*G(i,j)+0.114*B(i,j)</script><h1 id="3-图像灰度化处理方法的Python实现"><a href="#3-图像灰度化处理方法的Python实现" class="headerlink" title="3. 图像灰度化处理方法的Python实现"></a>3. 图像灰度化处理方法的Python实现</h1><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">'lenna.png'</span>)</span><br><span class="line">img1 = cv.cvtColor(img, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(<span class="string">'Src_img'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.0.1.png" alt></p><h2 id="3-1-最大值法"><a href="#3-1-最大值法" class="headerlink" title="3.1 最大值法"></a>3.1 最大值法</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Max_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = max(img[i,j,<span class="number">0</span>],img[i,j,<span class="number">1</span>],img[i,j,<span class="number">2</span>]) <span class="comment"># 求3通道中最大值</span></span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'Max_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.1.1.png" alt></p><h2 id="3-2-平均值法"><a href="#3-2-平均值法" class="headerlink" title="3.2 平均值法"></a>3.2 平均值法</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Avrage_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = (int(img[i,j,<span class="number">0</span>])+int(img[i,j,<span class="number">1</span>])+int(img[i,j,<span class="number">2</span>]))/<span class="number">3</span> <span class="comment"># 求3通道像素的平均值作为灰度值</span></span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'Avrage_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.2.1.png" alt></p><h2 id="3-3-加权平均法"><a href="#3-3-加权平均法" class="headerlink" title="3.3 加权平均法"></a>3.3 加权平均法</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WeightedAvrage_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = <span class="number">0.114</span>*int(img[i,j,<span class="number">0</span>])+<span class="number">0.578</span>*int(img[i,j,<span class="number">1</span>])+<span class="number">0.299</span>*int(img[i,j,<span class="number">2</span>])</span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'WeightedAvrage_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.3.1.png" alt></p><h2 id="3-4-最大值法、平均值法和加权平均法的比较"><a href="#3-4-最大值法、平均值法和加权平均法的比较" class="headerlink" title="3.4 最大值法、平均值法和加权平均法的比较"></a>3.4 最大值法、平均值法和加权平均法的比较</h2><p>综上，3种方法的灰度处理图像如下所示：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.4.png" alt></p><p>可以发现，最大值法转换的灰度图亮度最高，平均值法产生的灰度图像较暗，加权平均法得到的灰度图像明暗介于两者之间。</p><h2 id="3-5-opencv-python中灰度处理方法的应用"><a href="#3-5-opencv-python中灰度处理方法的应用" class="headerlink" title="3.5 opencv-python中灰度处理方法的应用"></a>3.5 opencv-python中灰度处理方法的应用</h2><p>opencv-python中有图像灰度处理的接口，直接调用即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.png'</span>)</span><br><span class="line">img1 = cv.cvtColor(img, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(<span class="string">'Src_img'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度转换</span></span><br><span class="line">image2 = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(image2, plt.cm.gray)</span><br><span class="line">plt.title(<span class="string">'Gray_img'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> 图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.5.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-图像灰度化&quot;&gt;&lt;a href=&quot;#1-图像灰度化&quot; class=&quot;headerlink&quot; title=&quot;1. 图像灰度化&quot;&gt;&lt;/a&gt;1. 图像灰度化&lt;/h1&gt;&lt;p&gt;在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255，当灰度为255的时候，表示最亮（纯白）；当灰度为0的时候，表示最暗（纯黑）。&lt;/p&gt;
&lt;p&gt;灰度化的好处是：相较于彩色图像灰度图像占内存更小，运行速度更快；灰度图像后可以在视觉上增加对比，突出目标区域。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>初见辽东</title>
    <link href="http://yoursite.com/2022/09/29/%E5%88%9D%E8%A7%81%E4%B8%B9%E4%B8%9C/"/>
    <id>http://yoursite.com/2022/09/29/%E5%88%9D%E8%A7%81%E4%B8%B9%E4%B8%9C/</id>
    <published>2022-09-29T12:15:22.000Z</published>
    <updated>2022-09-29T12:57:04.451Z</updated>
    
    <content type="html"><![CDATA[<p>时隔整整9个月，再一次来到学校，不过和上次不同的是，学校不在沈阳，而在丹东。作为学校和丹东首批的联合培养学生，刚被录取时得知这个消息我是有点担心的，感觉就像是“被抛弃了”。不过，后来我慢慢发现，这未尝不是一次不一样的人生旅程，毕竟到哪都是学习。</p><p>于是，我怀着一丝憧憬，当然还有半分担忧（科研？论文？），踏上了开往丹东的动车。一个半小时的动车很快，中间我还小睡了一会。刚出站就看到了学校的迎新队伍，于是作为一个“新生”，混在了开往学校的大巴里。一切都很顺利，被志愿者领着来到宿舍，环境比想象的好得多，另一个室友还没来，现在是一个人独占两人寝。</p><p>时间很快，转眼已是研二，一年半的联培时间相信也很快，我必须抓紧起来，学习，科研，还有生活。人们总是在熟悉了某个环境后就安于现状，或者说“被迫”安于现状。所以，我们必须时常审视自身，把眼光放长远，这样才不会落入时间的陷阱。</p><p>人生就是一场奇遇，我永远也不曾想过会来到这样的边境城市，一个距离我的家乡几千公里的地方。可是这样的事情偏偏发生了，这就是命运吧！在这里，我还会遇到各种各样的人，发生各种各样的事，也许两三年后离开东北，我再也不会踏足这片土地，但我一定会记得我曾经在这里生活过，记得初见这里时的画面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时隔整整9个月，再一次来到学校，不过和上次不同的是，学校不在沈阳，而在丹东。作为学校和丹东首批的联合培养学生，刚被录取时得知这个消息我是有点担心的，感觉就像是“被抛弃了”。不过，后来我慢慢发现，这未尝不是一次不一样的人生旅程，毕竟到哪都是学习。&lt;/p&gt;
&lt;p&gt;于是，我怀着一</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++11：智能指针</title>
    <link href="http://yoursite.com/2022/09/16/C-11%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/09/16/C-11%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-09-16T02:25:22.000Z</published>
    <updated>2022-09-16T03:58:10.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是智能指针"><a href="#一、什么是智能指针" class="headerlink" title="一、什么是智能指针"></a>一、什么是智能指针</h1><p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<a id="more"></a>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。随着C++的发展，有三个解决方案，一个方案对应着一种智能指针。</p><ul><li>将指针的管理权转移给另外一个对象。对应C++98的auto_ptr。</li><li>防止拷贝。对应C++11的unique_ptr。</li><li>引用计数。对应C++11的shared_ptr。</li></ul><p>其实，C++一共提供了四种智能指针：auto_ptr， unique_ptr，shared_ptr，weak_ptr。其中后三个是C++11新增的，第一个由C++98提出，已经被C++11弃用。智能指针都包含在memory库中，要使用智能指针必须包含这个库。</p><h1 id="二、auto-ptr"><a href="#二、auto-ptr" class="headerlink" title="二、auto_ptr"></a>二、auto_ptr</h1><p>  auto_ptr的原理是：将资源的管理权由一个对象转移给另外一个对象。但auto_ptr存在下面一些问题：</p><h2 id="1、auto-ptr不能共享所有权"><a href="#1、auto-ptr不能共享所有权" class="headerlink" title="1、auto_ptr不能共享所有权"></a>1、auto_ptr不能共享所有权</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p3;</span><br><span class="line">p3 = p1; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><p>这样会导致p1，p2，p3同时指向p1内部的原始指针，由于每一个auto_ptr在被销毁的时候都会删除其所指向的对象，原始指针就会被重复删除3次，为了解决这个问题，要么禁用拷贝与赋值运算符，要么设计当auto_ptr拷贝或者赋值的时候对原始指针的所有权转移到新对象去。</p><h2 id="2、auto-ptr不能指向数组"><a href="#2、auto-ptr不能指向数组" class="headerlink" title="2、auto_ptr不能指向数组"></a>2、auto_ptr不能指向数组</h2><h2 id="3、auto-ptr不能作为容器成员"><a href="#3、auto-ptr不能作为容器成员" class="headerlink" title="3、auto_ptr不能作为容器成员"></a>3、auto_ptr不能作为容器成员</h2><h2 id="4、auto-ptr不能通过赋值操作来初始化"><a href="#4、auto-ptr不能通过赋值操作来初始化" class="headerlink" title="4、auto_ptr不能通过赋值操作来初始化"></a>4、auto_ptr不能通过赋值操作来初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>) <span class="comment">// 错</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)) <span class="comment">// 对</span></span><br></pre></td></tr></table></figure><h1 id="三、unique-ptr"><a href="#三、unique-ptr" class="headerlink" title="三、unique_ptr"></a>三、unique_ptr</h1><p>unique_ptr可以看成是auto_ptr的替代品，用法如下：</p><h2 id="1、不支持拷贝构造和赋值运算函数"><a href="#1、不支持拷贝构造和赋值运算函数" class="headerlink" title="1、不支持拷贝构造和赋值运算函数"></a>1、不支持拷贝构造和赋值运算函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> Obj)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span> <span class="title">one</span><span class="params">(ap)</span></span>; <span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">unique_ptr</span> two= one; <span class="comment">// 会出错</span></span><br></pre></td></tr></table></figure><h2 id="2、可以移动构造和移动赋值操作"><a href="#2、可以移动构造和移动赋值操作" class="headerlink" title="2、可以移动构造和移动赋值操作"></a>2、可以移动构造和移动赋值操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">Getobj</span><span class="params">()</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Obj)</span></span>;</span><br><span class="line">     <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">unique&lt;Obj&gt; ptr = Getobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Obj())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(ptr1))</span></span>;</span><br></pre></td></tr></table></figure><h1 id="四、shared-ptr"><a href="#四、shared-ptr" class="headerlink" title="四、shared_ptr"></a>四、shared_ptr</h1><p>如果程序要使用多个指向同一个对象的指针，那么可以使用shared_ptr。基本使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> &lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">5</span>));</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pint = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr&lt;int&gt;p3 = pint; //error</span></span><br><span class="line"><span class="comment">//p3 = pint; //error</span></span><br><span class="line"></span><br><span class="line">use_count() <span class="comment">//计数数量</span></span><br><span class="line"></span><br><span class="line">unique() <span class="comment">//是否只被一个使用</span></span><br></pre></td></tr></table></figure><h1 id="五、weak-ptr"><a href="#五、weak-ptr" class="headerlink" title="五、weak_ptr"></a>五、weak_ptr</h1><p>shared_ptr是一种强引用关系，智能指针直接引用对象，代码会引起循环引用，从而造成内存泄漏。</p><p>weak_ptr用于配合shared_ptr使用并不影响对象的生命周期，即存在与否并不影响对象的引用计数器，weak_ptr并没有重载operator-&gt; 和operator* 操作符，因此不可直接通过weak_ptr使用对象。提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象shared_ptr智能指针（对象销毁时，返回空shared_ptr）。</p><p>weak_ptr被设计为shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源观测权，但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>使用weak_ptr的use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价use_count()==0但更快，表示被观测资源（也就是shared_ptr管理的资源）已经不复存在。</p><p>weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源，但当expired==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi2</span><span class="params">(spi1)</span></span>;</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp1 = spi1; <span class="comment">//观察spi1，不增加引用计数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp1.use_count()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//观察，不能使用 *、-&gt;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp1.expired() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//观察，不能使用 *、-&gt;</span></span><br><span class="line"><span class="keyword">auto</span> spi1 = wp1.lock();</span><br><span class="line"><span class="keyword">if</span>(spi) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*spi&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、什么是智能指针&quot;&gt;&lt;a href=&quot;#一、什么是智能指针&quot; class=&quot;headerlink&quot; title=&quot;一、什么是智能指针&quot;&gt;&lt;/a&gt;一、什么是智能指针&lt;/h1&gt;&lt;p&gt;在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换</title>
    <link href="http://yoursite.com/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</id>
    <published>2022-08-16T06:29:31.000Z</published>
    <updated>2022-08-16T08:52:52.892Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机视觉中，有一个经典的变换被广泛使用——傅里叶变换。傅里叶变换是将时间域上的信号转变为频率域上的信号，进而进行图像去噪、图像增强等处理。</p><a id="more"></a><h1 id="时域与频域"><a href="#时域与频域" class="headerlink" title="时域与频域"></a>时域与频域</h1><p>什么是时域（Time domain）？从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。</p><p>什么是频域（Frequency domain）？频域是描述信号在频率方面特性时用到的一种坐标系。用线性代数的语言就是装着正弦函数的空间。频域最重要的性质是：它不是真实的，而是一个数学构造。频域是一个遵循特定规则的数学范畴。正弦波是频域中唯一存在的波形，这是频域中最重要的规则，即正弦波是对频域的描述，因为时域中的任何波形都可用正弦波合成。</p><p>对于一个信号来说，信号强度随时间的变化规律就是时域特性，信号是由哪些单一频率的信号合成的就是频域特性。</p><p>时域分析与频域分析是对信号的两个观察面。时域分析是以时间轴为坐标表示动态信号的关系；频域分析是把信号变为以频率轴为坐标表示出来。一般来说，时域的表示较为形象与直观，频域分析则更为简练，剖析问题更为深刻和方便。目前，信号分析的趋势是从时域向频域发展。然而，它们是互相联系，缺一不可，相辅相成的。贯穿时域与频域的方法之一，就是传说中的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)。</p><h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><p>傅里叶级数是一种对周期信号进行分解的方式。</p><p>如下图所示，左上角为正弦方波，余下为通过不同的正弦谐波数可以去拟合这个方波结果。</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换01.jpg" alt></p><p>可以看到，叠加的谐波信号越多时，越接近于方波信号。</p><p>傅里叶级数由法国数学家傅里叶提出，即满足条件（狄利克雷条件）的任何周期函数可以由一系列不同频率的正弦（余弦）函数叠加而成。这种相加形式又称为级数，所以也称为傅里叶级数。</p><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><p>那么对信号的不同频率进行分解有什么好处呢？</p><p>如下图所示，从时域上看，最下方叠加得到的信号是很难分析出里面蕴含的频率信息的。</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换02.jpg" alt></p><p>而通过傅里叶分解后，如下图右图所示，可以很容易地观察到频率的有无和幅度的大小（相位也有对应的相位谱，这里没有列出）。</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换03.jpg" alt></p><p>因此，通过傅里叶变换将某一信号分解为不同频率的信号，可以很容易地对信号中的某一段频段进行观察和操作。</p><h2 id="傅里叶变换分类"><a href="#傅里叶变换分类" class="headerlink" title="傅里叶变换分类"></a>傅里叶变换分类</h2><p>根据原信号的不同类型，我们可以把傅立叶变换分为四种类别：</p><ul><li>非周期性连续信号（傅立叶变换（Fourier Transform））</li><li>周期性连续信号（傅立叶级数(Fourier Series)）</li><li>非周期性离散信号（离散时域傅立叶变换（Discrete Time Fourier Transform））</li><li>周期性离散信号（离散傅立叶变换(Discrete Fourier Transform)）</li></ul><p>这四种傅立叶变换都是针对正无穷大和负无穷大的信号，即信号的的长度是无穷大的，我们知道这对于计算机处理来说是不可能的，那么有没有针对长度有限的傅立叶变换呢？没有。因为正余弦波被定义成从负无穷小到正无穷大，我们无法把一个长度无限的信号组合成长度有限的信号。</p><p>面对这种困难，方法是把长度有限的信号表示成长度无限的信号，可以把信号无限地从左右进行延伸，延伸的部分用零来表示，这样，这个信号就可以被看成是非周期性离散信号，我们就可以用到离散时域傅立叶变换的方法。还有，也可以把信号用复制的方法进行延伸，这样信号就变成了周期性离散信号，这时我们就可以用离散傅立叶变换方法进行变换。</p><p>但是对于非周期性的信号，我们需要用无穷多不同频率的正弦曲线来表示，这对于计算机来说是不可能实现的，因为在计算机中只有离散的和有限长度的数据才能被处理。所以对于离散信号的变换只有离散傅立叶变换（DFT）才能被适用，对于其它的变换类型只有在数学演算中才能用到，在计算机中我们只能用DFT方法。</p><h2 id="一维傅里叶公式"><a href="#一维傅里叶公式" class="headerlink" title="一维傅里叶公式"></a>一维傅里叶公式</h2><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换04.jpg" alt></p><p>其中，ω 表示频率, t 表示时间, 它将频率域的函数表示为时间域函数 f(t) 的积分。</p><h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>我们知道，灰度图像是由二维的离散的点构成的。二维离散傅里叶变换（Two-Dimensional Discrete Fourier Transform）常用于图像处理中，对图像进行傅里叶变换后得到其频谱图。频谱图中频率高低表征图像中灰度变化的剧烈程度。图像中边缘和噪声往往是高频信号，而图像背景往往是低频信号。我们在频率域内可以很方便地对图像的高频或低频信息进行操作，完成图像去噪，图像增强，图像边缘提取等操作。</p><p>对二维图像进行傅里叶变换公式如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换05.jpg" alt></p><p>其中，图像长 M，高 N。F(u,v)表示频域图像，f(x,y)表示时域图像。u 的范围为[0,M-1]，v 的范围为[0,N-1]。</p><p> 对二维图像进行傅里叶逆变换公式如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换06.jpg" alt></p><p>其中，图像长 M，高 N。f(x,y)表示时域图像，F(u,v)表示频域图像。x 的范围为[0,M-1]，y 的范围为[0,N-1]。</p><h1 id="OpenCV中傅里叶变换的应用"><a href="#OpenCV中傅里叶变换的应用" class="headerlink" title="OpenCV中傅里叶变换的应用"></a>OpenCV中傅里叶变换的应用</h1><h2 id="傅里叶变换-1"><a href="#傅里叶变换-1" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将频谱低频从左上角移动至中心位置</span></span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 频谱图像双通道复数转换为0-255区间</span></span><br><span class="line">result = <span class="number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Original Image'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(result, cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Magnitude Spectrum'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换07.jpg" alt></p><h2 id="傅里叶逆变换"><a href="#傅里叶逆变换" class="headerlink" title="傅里叶逆变换"></a>傅里叶逆变换</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dftshift = np.fft.fftshift(dft)</span><br><span class="line">res1= <span class="number">20</span>*np.log(cv2.magnitude(dftshift[:,:,<span class="number">0</span>], dftshift[:,:,<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶逆变换</span></span><br><span class="line">ishift = np.fft.ifftshift(dftshift)</span><br><span class="line">iimg = cv2.idft(ishift)</span><br><span class="line">res2 = cv2.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">131</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'Original Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>), plt.imshow(res1, <span class="string">'gray'</span>), plt.title(<span class="string">'Fourier Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>), plt.imshow(res2, <span class="string">'gray'</span>), plt.title(<span class="string">'Inverse Fourier Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换08.jpg" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机视觉中，有一个经典的变换被广泛使用——傅里叶变换。傅里叶变换是将时间域上的信号转变为频率域上的信号，进而进行图像去噪、图像增强等处理。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>C++11：右值引用</title>
    <link href="http://yoursite.com/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2022-06-23T10:40:22.000Z</published>
    <updated>2022-06-23T11:06:02.264Z</updated>
    
    <content type="html"><![CDATA[<p>右值引用是一种新的 C++ 语法，基于右值引用引申出了 2 种 C++ 编程技巧，分别为移动语义和完美转发。本文主要介绍什么是右值引用以及它的基本用法。</p><a id="more"></a><h3 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h3><p>右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p><blockquote><p>左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p></blockquote><p>通常情况下，判断某个表达式是左值还是右值，有以下 2 种方法：</p><p>1) 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">// 错误，5 不能为左值</span></span><br></pre></td></tr></table></figure><p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。C++ 中的左值也可以当做右值使用，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure><p>2) 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p><p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p><blockquote><p>注意，以上 2 种判定方法只适用于大部分场景。</p></blockquote><h3 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h3><p>前面提到，其实 C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p><p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p><p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  // 右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// a = 100</span></span><br></pre></td></tr></table></figure><p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; a = <span class="number">10</span>; <span class="comment">// 编译器不会报错</span></span><br></pre></td></tr></table></figure><p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p><p>下图给出 C++ 左值引用和右值引用的可以引用的值类型和使用场景：</p><p><img src="/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/右值引用.jpg" alt></p><p>表中，Y 表示支持，N 表示不支持。</p><blockquote><p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值，而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。当然对于纯右值和将亡值，都属于右值。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;右值引用是一种新的 C++ 语法，基于右值引用引申出了 2 种 C++ 编程技巧，分别为移动语义和完美转发。本文主要介绍什么是右值引用以及它的基本用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：使用using定义别名</title>
    <link href="http://yoursite.com/2022/06/06/C-11%EF%BC%9A%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D/"/>
    <id>http://yoursite.com/2022/06/06/C-11%EF%BC%9A%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D/</id>
    <published>2022-06-06T01:45:14.000Z</published>
    <updated>2022-06-06T02:06:15.615Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++11 中使用 using 定义别名的用法。<a id="more"></a></p><h3 id="using简介"><a href="#using简介" class="headerlink" title="using简介"></a>using简介</h3><p>大家都知道，在 C++ 中可以通过 typedef 重定义一个类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure><p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">uint_t</span>)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure><p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。想象下面这个场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="keyword">map_str_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p><p>因此，在 C++98/03 中往往不得不这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="keyword">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p><p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">str_map_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">str_map_t</span>&lt;<span class="keyword">int</span>&gt; map1;</span><br></pre></td></tr></table></figure><p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p><h3 id="using应用"><a href="#using应用" class="headerlink" title="using应用"></a>using应用</h3><h4 id="重定义普通类型"><a href="#重定义普通类型" class="headerlink" title="重定义普通类型"></a>重定义普通类型</h4><p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">map_int_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;;</span><br></pre></td></tr></table></figure><p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p><h4 id="重定义函数指针"><a href="#重定义函数指针" class="headerlink" title="重定义函数指针"></a>重定义函数指针</h4><p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p><h4 id="重定义模板"><a href="#重定义模板" class="headerlink" title="重定义模板"></a>重定义模板</h4><p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt;::type xx_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="keyword">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure><p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。</p><p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t\<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</int></p><p>因此，下面这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span> (*func_call)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; func_call)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure><p>同样是无法实现重载的，func_t\<int> 只是 void(*)(int, int) 类型的等价物。</int></p><p>可以发现，using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p><p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">type_t</span> = T;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">type_t</span>&lt;<span class="keyword">int</span>&gt; i;</span><br></pre></td></tr></table></figure><p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t\<int> 将等价于 int。</int></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++11 中使用 using 定义别名的用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
</feed>
