<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++11：decltype类型推导</title>
    <url>/2022/05/25/C-11%EF%BC%9Adecltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<p>decltype 是 C++ 11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。<a id="more"></a></p>
<p>decltype 是 “declare type” 的缩写，译为“声明类型”。既然已经有了 auto 关键字，为什么还需要 decltype 关键字呢？这是因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p>
<p>auto 和 decltype 关键字虽然都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">exp</span>) varname = value;</span><br></pre></td></tr></table></figure>
<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。auto 根据<code>=</code>右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</p>
<p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。因此 decltype 可以写成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">exp</span>) varname;</span><br></pre></td></tr></table></figure>
<h3 id="exp-注意事项"><a href="#exp-注意事项" class="headerlink" title="exp 注意事项"></a>exp 注意事项</h3><p>原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</p>
<p>C++ decltype 用法举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">// b 被推导成了 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">// x 被推导成了 double</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">// y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
<p>可以看到，decltype 能够根据变量、字面量、带有运算符的表达式推导出变量的类型。</p>
<h3 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h3><p>上面的例子让我们初步感受了一下 decltype 的用法，但不要认为 decltype 就这么简单，它的玩法实际上可以非常复杂。当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</p>
<ul>
<li>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>为了更好地理解 decltype 的推导规则，我们来看几个实际的例子。</p>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">// n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">// r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">// total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">"https://www.baidu.com"</span>;  <span class="comment">// total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，按照推导规则 1，对于一般的表达式，decltype 的推导结果就和这个表达式的类型一致。</p>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;  <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">(<span class="keyword">double</span>)</span></span>;  <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">// decltype类型推导</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(func_int_r(<span class="number">100</span>, <span class="string">'A'</span>)) a = n;  <span class="comment">// a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(func_int_rr()) b = <span class="number">0</span>;  <span class="comment">// b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(func_int(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">// c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(fun_cint_r(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">// x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(func_cint_rr()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被<code>( )</code>包围：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Base obj;</span><br><span class="line">    <span class="comment">// 带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">// obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">// obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;</span></span><br><span class="line">    <span class="comment">// 加法表达式</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">// n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">// n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要重点说一下左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</p>
<h3 id="decltype-实际应用"><a href="#decltype-实际应用" class="headerlink" title="decltype 实际应用"></a>decltype 实际应用</h3><p>我们知道，auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">// 注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.func(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<p>要想解决这个问题，在之前的 C++98/03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(T().<span class="built_in">begin</span>()) m_it;  <span class="comment">// 注意这里</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看起来是不是很清爽？但是需要注意，有些低版本的编译器不支持<code>T().begin()</code>这种写法，以上代码在 VS2019 下测试通过，在 VS2015 下测试失败。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：auto类型推导</title>
    <url>/2022/05/21/C-11%EF%BC%9Aauto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<p>在 C++11 之前的版本（C++98 和 C++ 03）中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 C#、JavaScript、PHP、Python 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便。C++11 为了顺应这种趋势也开始支持该语法，使用 auto 关键字来支持自动类型推导。<a id="more"></a></p>
<h3 id="语法和规则"><a href="#语法和规则" class="headerlink" title="语法和规则"></a>语法和规则</h3><p>在之前的 C++ 版本中，auto 关键字用来指明变量的存储类型，它和 static 关键字是相对的。auto 表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，一般我们也不写，这使得 auto 关键字的存在变得非常鸡肋。C++11 赋予 auto 关键字新的含义，使用它来做自动类型推导。也就是说，使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，这样我们就不用手动指明变量的数据类型了。</p>
<p>auto 关键字基本的使用语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = value;	<span class="comment">// name 是变量的名字，value 是变量的初始值。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
</blockquote>
<p>auto 类型推导的简单例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="number">12.8</span>;</span><br><span class="line"><span class="keyword">auto</span> p = &amp;n;</span><br><span class="line"><span class="keyword">auto</span> url = <span class="string">"http://c.biancheng.net/cplus/"</span>;</span><br></pre></td></tr></table></figure>
<p>下面我们来解释一下：</p>
<ul>
<li>第 1 行中，10 是一个整数，默认是 int 类型，所以推导出变量 n 的类型是 int。</li>
<li>第 2 行中，12.8 是一个小数，默认是 double 类型，所以推导出变量 f 的类型是 double。</li>
<li>第 3 行中，&amp;n 的结果是一个 int<em> 类型的指针，所以推导出变量 p 的类型是 int</em>。</li>
<li>第 4 行中，由双引号<code>&quot;&quot;</code>包围起来的字符串是 const char<em> 类型，所以推导出变量 url 的类型是 const char</em>，也即一个常量指针。</li>
</ul>
<p>我们也可以连续定义多个变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> *p = &amp;n, m = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>
<p>先看前面的第一个子表达式，&amp;n 的类型是 int<em>，编译器会根据 auto </em>p 推导出 auto 为 int；后面的 m 变量自然也为 int 类型，所以把 99 赋值给它也是正确的。</p>
<p>这里我们要注意，推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作<code>m=12.5</code>就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。</p>
<p>还有一个值得注意的地方是：使用 auto 类型推导的变量必须马上初始化，这个很容易理解，因为 auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明。</p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>1) auto 除了可以独立使用，还可以和某些具体类型混合使用，这样 auto 表示的就是“半个”类型，而不是完整的类型。请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">// p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span>  p2 = &amp;x;   <span class="comment">// p2 为 int*，auto 推导为 int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1  = x;   <span class="comment">// r1 为 int&amp;，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;    <span class="comment">// r2 为 int，auto 推导为 int</span></span><br></pre></td></tr></table></figure>
<p>下面我们来解释一下：</p>
<ul>
<li>第 2 行代码中，p1 为 int<em> 类型，也即 auto </em> 为 int *，所以 auto 被推导成了 int 类型。</li>
<li>第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</li>
<li>第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</li>
<li>第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当<code>=</code>右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</li>
</ul>
<p>2) 接下来，我们再来看一下 auto 和 const 的结合：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n = x;  <span class="comment">// n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;        <span class="comment">// f 为 const int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">// r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;     <span class="comment">// r1 为 const int&amp; 类型，auto 被推导为 const int 类型</span></span><br></pre></td></tr></table></figure>
<p>下面我们来解释一下：</p>
<ul>
<li>第 2 行代码中，n 为 const int，auto 被推导为 int。</li>
<li>第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当<code>=</code>右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。</li>
<li>第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</li>
<li>第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。</li>
</ul>
<p>最后我们来简单总结一下 auto 与 const 结合的用法：</p>
<ul>
<li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li>
<li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li>
</ul>
<h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h3><p>前面介绍推导规则的时候我们说过，使用 auto 的时候必须对变量进行初始化，这是 auto 的限制之一。那么，除此以外，auto 还有哪些其它的限制呢？</p>
<p>1) auto 不能在函数的参数中使用。</p>
<p>这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。</p>
<p>2) auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。</p>
<p>3) auto 关键字不能定义数组，比如下面的例子就是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> url[] = <span class="string">"www.baidu.com"</span>;</span><br><span class="line"><span class="keyword">auto</span> str[] = url; <span class="comment">// str 为数组，所以不能使用 auto</span></span><br></pre></td></tr></table></figure>
<p>4) auto 不能作用于模板参数，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="auto-的应用"><a href="#auto-的应用" class="headerlink" title="auto 的应用"></a>auto 的应用</h3><h4 id="使用-auto-定义迭代器"><a href="#使用-auto-定义迭代器" class="headerlink" title="使用 auto 定义迭代器"></a>使用 auto 定义迭代器</h4><p>auto 的一个典型应用场景是用来定义 STL 的迭代器。</p>
<p>我们在使用 STL 容器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，书写起来很麻烦，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。</p>
<p>修改上面的代码，使之变得非常简洁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>auto 可以根据表达式 v.begin() 的类型（begin() 函数的返回值类型）来推导出变量 i 的类型。</p>
<h4 id="auto-用于泛型编程"><a href="#auto-用于泛型编程" class="headerlink" title="auto 用于泛型编程"></a>auto 用于泛型编程</h4><p>auto 的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"www.baidu.com"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    func&lt;A&gt;();</span><br><span class="line">    func&lt;B&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure>
<p>本例中的模板函数 func() 会调用所有类的静态函数 get()，并对它的返回值做统一处理，但是 get() 的返回值类型并不一样，而且不能自动转换。这种要求在以前的 C++ 版本中实现起来非常的麻烦，需要额外增加一个模板参数，并在调用时手动给该模板参数赋值，用以指明变量 val 的类型。</p>
<p>但是有了 auto 类型自动推导，编译器就可以根据 get() 的返回值自己推导出 val 变量的类型，不用再增加一个模板参数了。</p>
<p>下面的代码演示了不使用 auto 的解决办法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://c.biancheng.net/cplus/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">// 需要额外增加一个模板参数 T2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    T2 val = T1::<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用时也要手动给模板参数赋值</span></span><br><span class="line">    func&lt;A, <span class="keyword">int</span>&gt;();</span><br><span class="line">    func&lt;B, <span class="keyword">const</span> <span class="keyword">char</span>*&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：for循环（基于范围的循环）</title>
    <url>/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-C-98-03标准的for循环"><a href="#1-C-98-03标准的for循环" class="headerlink" title="1. C++ 98/03标准的for循环"></a>1. C++ 98/03标准的for循环</h2><p>在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例如，下面程序演示了用上述结构遍历数组和容器的具体实现过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc,arc+<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (iter = myvector.<span class="built_in">begin</span>(); iter != myvector.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/</span></span><br></pre></td></tr></table></figure>
<h2 id="2-C-11标准的for循环"><a href="#2-C-11标准的for循环" class="headerlink" title="2. C++ 11标准的for循环"></a>2. C++ 11标准的for循环</h2><p>在 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li>
<li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li>
</ul>
<p>可以看到，同 C++ 98/03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p>
<p>下面程序演示了如何用 C++ 11 标准中的 for 循环遍历上面程序定义的 arc 数组和 myvector 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : arc) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/ !</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/!</span></span><br></pre></td></tr></table></figure>
<p>这里有以下 2 点需要说明：<br>1) 程序中在遍历 myvector 容器时，定义了 auto 类型的 ch 变量，当编译器编译程序时，会通过 myvector 容器中存储的元素类型自动推导出 ch 为 char 类型。注意，这里的 ch 不是迭代器类型，而表示的是 myvector 容器中存储的每个元素。</p>
<p>2) 仔细观察程序的输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为 myvector 容器中没有存储 ‘\0’。</p>
<h3 id="2-1-遍历用-大括号初始化的列表"><a href="#2-1-遍历用-大括号初始化的列表" class="headerlink" title="2.1 遍历用{}大括号初始化的列表"></a>2.1 遍历用<code>{}</code>大括号初始化的列表</h3><p>新语法格式的 for 循环还支持遍历用<code>{}</code>大括号初始化的列表，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-declaration-参数处定义引用形式的变量"><a href="#2-2-declaration-参数处定义引用形式的变量" class="headerlink" title="2.2 declaration 参数处定义引用形式的变量"></a>2.2 declaration 参数处定义引用形式的变量</h3><p>在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bcdef</span><br></pre></td></tr></table></figure>
<p>此程序中先后使用了 2 个新语法格式的 for 循环，其中前者用于修改 myvector 容器中各个元素的值，后者用于输出修改后的 myvector 容器中的各个元素。</p>
<p>既然 declaration 参数既可以定义普通形式的变量，也可以定义引用形式的变量，应该如何选择呢？其实很简单，如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：constexpr关键字</title>
    <url>/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="1-C-常量表达式"><a href="#1-C-常量表达式" class="headerlink" title="1. C++常量表达式"></a>1. C++常量表达式</h2><p>constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。<a id="more"></a></p>
<p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure>
<p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p>
<p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。而常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<blockquote>
<p>注意：获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
</blockquote>
<h2 id="2-constexpr修饰普通变量"><a href="#2-constexpr修饰普通变量" class="headerlink" title="2. constexpr修饰普通变量"></a>2. constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：2</p>
<blockquote>
<p>注意：可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
</blockquote>
<p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<blockquote>
<p>需要注意的是，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。但我们必须清楚，const 和 constexpr 并不相同。</p>
<p>另外需要注意的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
</blockquote>
<h2 id="3-constexpr修饰函数"><a href="#3-constexpr修饰函数" class="headerlink" title="3. constexpr修饰函数"></a>3. constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。但需要注意，constexpr 并非可以修改任意函数的返回值，一个函数要想成为常量表达式函数，必须满足如下 4 个条件：</p>
<p>1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。如下是正确的定义 display() 常量表达式函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<p>2) 该函数必须有返回值，即函数的返回值类型不能是 void。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<p>3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; noconst_dis(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可尝试将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
</blockquote>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<p>4) return 返回的表达式必须是常量表达式，举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<blockquote>
<p>注意：在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的。</p>
</blockquote>
<h2 id="4-constexpr修饰类的构造函数"><a href="#4-constexpr修饰类的构造函数" class="headerlink" title="4. constexpr修饰类的构造函数"></a>4. constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。<br>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序无法通过编译，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    constexpr myType(char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<blockquote>
<p>注意：constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
</blockquote>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr myType(const char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.getname();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.getage();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
</blockquote>
<h2 id="5-constexpr修饰模板函数"><a href="#5-constexpr修饰模板函数" class="headerlink" title="5. constexpr修饰模板函数"></a>5. constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> = <span class="title">dispaly</span>(<span class="title">stu</span>);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret.name &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = dispaly(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li>
<li>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li>
</ul>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：longlong超长整型和nullptr初始化空指针</title>
    <url>/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。<a id="more"></a></p>
<h2 id="1-C-11：long-long-超长整型"><a href="#1-C-11：long-long-超长整型" class="headerlink" title="1. C++11：long long 超长整型"></a>1. C++11：long long 超长整型</h2><p>C++ 11 标准中，基于整数大小的考虑，共提供了如下表所示的这些数据类型。与此同时，标准中还明确限定了各个数据类型最少占用的位数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>整数类型</th>
<th>等价类型</th>
<th>C++11标准规定占用最少位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed short</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed short int</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>unsigned short</td>
<td>unsigned short int（无符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>unsigned short int（无符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>int</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed int</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>unsigned</td>
<td>unsigned int（无符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>unsigned int</td>
<td>unsigned int（无符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>long</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>long int</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>signed long</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>signed long int</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>unsigned long</td>
<td>unsigned long int（无符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>unsigned long int</td>
<td>unsigned long int（无符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>long long（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>long long int（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>signed long long（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>signed long long int（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>unsigned long long（C++11）</td>
<td>unsigned long long int（无符号超长整型）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>unsigned long long int（C++11）</td>
<td>unsigned long long int（无符号超长整型）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。不过需要注意的是，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</p>
</blockquote>
<p>在上表罗列的这些数据类型中，long long 超长整型是 C++ 11 标准新添加的。其实早在 1995 年，就有人提议将 long long 整形写入 C++ 98 标准，但被委员会拒绝了。而后 long long 整形被 C99 标准（C语言标准之一）采纳，并逐渐被很多编译器支持，于是 C++ 标准委员会重新决定将 long long 整形写入 C++ 11 标准中。</p>
<p>如同 long 类型整数需明确标注 “L” 或者 “l” 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p>
<ul>
<li>对于有符号 long long 整形，后缀用 “LL” 或者 “ll” 标识。例如，”10LL” 就表示有符号超长整数 10；</li>
<li>对于无符号 long long 整形，后缀用 “ULL”、”ull”、”Ull” 或者 “uLL” 标识。例如，”10ULL” 就表示无符号超长整数 10。</li>
</ul>
<blockquote>
<p>如果不添加任何标识，则所有的整数都会默认为 int 类型。</p>
</blockquote>
<p>对于 long long 类型来说，如果想了解当前平台上 long long 整形的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：<br>1）LLONG_MIN：代表当前平台上最小的 long long 类型整数；<br>2）LLONG_MAX：代表当前平台上最大的 long long 类型整数；<br>3）ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）。<br>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"long long最大值："</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">" "</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt;<span class="string">"long long最小值："</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt; <span class="string">"unsigned long long最大值："</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为（不唯一）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">-9223372036854775808</span> <span class="number">8000000000000000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最小值：<span class="number">9223372036854775807</span> <span class="number">7f</span>ffffffffffffff</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">18446744073709551615</span> ffffffffffffffff</span><br></pre></td></tr></table></figure>
<p>此程序中，输出了各最大值和最小值对应的十六进制，显然在当前平台（Windows10 64位操作系统）上，long long 超长整型占用 64 位（也就是 16 个字节）的存储空间。</p>
<h2 id="2-C-11：nullptr-初始化空指针"><a href="#2-C-11：nullptr-初始化空指针" class="headerlink" title="2. C++11：nullptr 初始化空指针"></a>2. C++11：nullptr 初始化空指针</h2><p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p>
<blockquote>
<p>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p>
</blockquote>
<p>C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。<br>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p>
<p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="number">0</span>);</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">int</span> n</span><br></pre></td></tr></table></figure>
<p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。<br>C++ 98/03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">isnull( (<span class="keyword">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line">isnull( (<span class="keyword">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p>如此，才会成功调用我们预期的函数。</p>
<p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。</p>
<blockquote>
<p>在使用 nullptr 之前，需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，则需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std=c++0x 编译选项）。</p>
</blockquote>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p>
<p>值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p>
<p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    isnull(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">void</span>*c</span><br></pre></td></tr></table></figure>
<p>借助执行结果不难看出，由于 nullptr 无法隐式转换为整形，而可以隐式匹配指针类型，因此执行结果和我们的预期相符。</p>
<p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：lambda匿名函数</title>
    <url>/2022/11/27/C-11%EF%BC%9Alambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<a id="more"></a>
<h2 id="1-lambda匿名函数的定义"><a href="#1-lambda匿名函数的定义" class="headerlink" title="1. lambda匿名函数的定义"></a>1. lambda匿名函数的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](parameters)<span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type&#123;statement&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>[capture]：捕捉列表，[] 是lambda引出符，编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表用于捕捉父域中的变量以供lambda函数使用，捕捉列表可以由多个项组成，用”,”分割。[var]表示以值传递方式捕捉父域中的变量var，[=]表示以值传递方式捕捉父域中的所有变量（包括this），[&amp;var]表示以引用传递方式捕捉父域中的变量var，[&amp;]表示以引用传递方式捕捉父域中的所有变量（包括this）,[this]表示以值传递方式捕捉当前的this指针。</li>
<li>(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号()一起省略。</li>
<li>mutable：mutable修饰符，默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li>
<li>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，不需要返回值的时候可以连同符号-&gt;一起省略。在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ul>
<h3 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h3><div class="table-container">
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[=]</td>
<td>只有一个 = 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[=,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p> 注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<h3 id="最简单的lambda匿名函数"><a href="#最简单的lambda匿名函数" class="headerlink" title="最简单的lambda匿名函数"></a>最简单的lambda匿名函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，这是一个没有任何功能的 lambda 匿名函数。</p>
<h2 id="2-lambda匿名函数的使用"><a href="#2-lambda匿名函数的使用" class="headerlink" title="2. lambda匿名函数的使用"></a>2. lambda匿名函数的使用</h2><h3 id="2-1-lambda匿名函数的定义和使用"><a href="#2-1-lambda匿名函数的定义和使用" class="headerlink" title="2.1 lambda匿名函数的定义和使用"></a>2.1 lambda匿名函数的定义和使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 对数组 num 中的元素进行升序排序</span></span><br><span class="line">    sort(num, num + <span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> x &lt; y; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。而如果使用普通函数，需以如下代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_up</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 对数组 num 中的元素进行升序排序</span></span><br><span class="line">    sort(num, num + <span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此程序中 sort_up() 函数的功能和上一个程序中的 lambda 匿名函数完全相同。显然在类似的场景中，使用 lambda 匿名函数更有优势。</p>
<p>除此之外，虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">display</span> = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; <span class="keyword">void</span>&#123;<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">// 调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 输出：10 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<h3 id="2-2-值传递和引用传递的区别"><a href="#2-2-值传递和引用传递的区别" class="headerlink" title="2.2 值传递和引用传递的区别"></a>2.2 值传递和引用传递的区别</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda1:\n"</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=] &#123;</span><br><span class="line">        <span class="comment">// 全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda2:\n"</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;] &#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lambda1:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">lambda2:</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。其中，lambda1 匿名函数是以 [=] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</p>
<h3 id="2-3-执行抛出异常类型"><a href="#2-3-执行抛出异常类型" class="headerlink" title="2.3 执行抛出异常类型"></a>2.3 执行抛出异常类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="keyword">throw</span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        except();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获到了整形异常"</span>;	<span class="comment">// 输出：捕获到了整形异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p>
<p>在此基础上，再看一下反例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="keyword">throw</span>(<span class="keyword">char</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        except1();</span><br><span class="line">        except2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获到了整形异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p>
<blockquote>
<p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：move函数将左值强制转换为右值</title>
    <url>/2023/01/04/C-11%EF%BC%9Amove%E5%87%BD%E6%95%B0%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<p>通过学习《<a href="https://crossoverpptx.github.io/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">C++11移动构造函数</a>》我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>需要注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p><strong>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</strong>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
<a id="more"></a>
<p>move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg )</span><br></pre></td></tr></table></figure>
<p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p>
<p>下面用一些代码演示了move() 函数的使用方法。</p>
<p>（1）move() 函数的基础应用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movedemo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    movedemo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    movedemo(<span class="keyword">const</span> movedemo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    movedemo(movedemo &amp;&amp;d):num(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"move construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo2:\n"</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo3:\n"</span>;</span><br><span class="line">    movedemo demo3 = <span class="built_in">std</span>::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line"><span class="built_in">move</span> construct!</span><br></pre></td></tr></table></figure>
<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<blockquote>
<p>注意：调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 30 行代码会导致程序运行时发生错误。</p>
</blockquote>
<p>（2）灵活使用 move() 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    first() :num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    first(first &amp;&amp;d) :num(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"first move construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    second() :fir() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    second(second &amp;&amp; sec) :fir(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"second move construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line">first <span class="built_in">move</span> construct!</span><br><span class="line">second <span class="built_in">move</span> construct</span><br></pre></td></tr></table></figure>
<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。仔细观察可以发现，程序中使用了两次 move() 函数：</p>
<ul>
<li>程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li>
<li>程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li>
</ul>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：tuple元组</title>
    <url>/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<p>C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p>
<p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p>
<a id="more"></a>
<h2 id="1-tuple对象的创建"><a href="#1-tuple对象的创建" class="headerlink" title="1. tuple对象的创建"></a>1. tuple对象的创建</h2><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</tuple></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br></pre></td></tr></table></figure>
<p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p>
<h4 id="1-1-类的构造函数"><a href="#1-1-类的构造函数" class="headerlink" title="1.1 类的构造函数"></a>1.1 类的构造函数</h4><p>tuple 模板类提供有很多构造函数，包括：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line">tuple (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span> <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span>      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span>  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span>       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span>            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    std::tuple&lt;int, char&gt; second(first);                     // 2)   second&#123;&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; third(std::make_tuple(20, 'b'));   // 3)   third&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;long, char&gt; fourth(third);                    // 4)的左值方式, fourth&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; fifth(10, 'a');                    // 5)的右值方式, fifth&#123;10.'a'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; sixth(std::make_pair(30, 'c'));    // 6)的右值方式, sixth&#123;30,''c&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-make-tuple-函数"><a href="#1-2-make-tuple-函数" class="headerlink" title="1.2 make_tuple()函数"></a>1.2 make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</tuple></p>
<p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>,<span class="string">'a'</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>; <span class="keyword">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = <span class="built_in">std</span>::make_tuple (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure>
<p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p>
<h2 id="2-tuple常用函数"><a href="#2-tuple常用函数" class="headerlink" title="2. tuple常用函数"></a>2. tuple常用函数</h2><p>为了方便在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数，<tuple> 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如下表所示：</tuple></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数或类模板</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tup1.swap(tup2) swap(tup1, tup2)</td>
<td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。</tuple></td>
</tr>
<tr>
<td>get<num>(tup)</num></td>
<td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</tuple></td>
</tr>
<tr>
<td>tuple_size<type>::value</type></td>
<td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</tuple></td>
</tr>
<tr>
<td>tuple_element<I, type>::type</I,></td>
<td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</tuple></td>
</tr>
<tr>
<td>forward_as_tuple<args...></args...></td>
<td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td>
</tr>
<tr>
<td>tie(args…) = tup</td>
<td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</tuple></td>
</tr>
<tr>
<td>tuple_cat(args…)</td>
<td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</tuple></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、&lt;、&gt;、&gt;=、&lt;= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。</p>
</blockquote>
<p>以下程序演示了上表中一部分函数模板和类模板的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 'x'</span></span><br><span class="line">    std::tuple&lt;int, char&gt; mytuple(10, 'x');</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple(<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">double</span> mydou;</span><br><span class="line">    <span class="keyword">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    <span class="built_in">std</span>::tie(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = <span class="built_in">std</span>::tuple_cat(mytuple, bar);</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> x</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：使用using定义别名</title>
    <url>/2022/06/06/C-11%EF%BC%9A%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p>本文介绍 C++11 中使用 using 定义别名的用法。<a id="more"></a></p>
<h3 id="using简介"><a href="#using简介" class="headerlink" title="using简介"></a>using简介</h3><p>大家都知道，在 C++ 中可以通过 typedef 重定义一个类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure>
<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">uint_t</span>)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>
<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。想象下面这个场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="keyword">map_str_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<p>因此，在 C++98/03 中往往不得不这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="keyword">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p>
<p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">str_map_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">str_map_t</span>&lt;<span class="keyword">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>
<p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p>
<h3 id="using应用"><a href="#using应用" class="headerlink" title="using应用"></a>using应用</h3><h4 id="重定义普通类型"><a href="#重定义普通类型" class="headerlink" title="重定义普通类型"></a>重定义普通类型</h4><p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">map_int_t</span> = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p>
<h4 id="重定义函数指针"><a href="#重定义函数指针" class="headerlink" title="重定义函数指针"></a>重定义函数指针</h4><p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<h4 id="重定义模板"><a href="#重定义模板" class="headerlink" title="重定义模板"></a>重定义模板</h4><p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt;::type xx_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="keyword">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>
<p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。</p>
<p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t\<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</int></p>
<p>因此，下面这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span> (*func_call)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; func_call)</span></span>; <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>
<p>同样是无法实现重载的，func_t\<int> 只是 void(*)(int, int) 类型的等价物。</int></p>
<p>可以发现，using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p>
<p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">type_t</span> = T;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">type_t</span>&lt;<span class="keyword">int</span>&gt; i;</span><br></pre></td></tr></table></figure>
<p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t\<int> 将等价于 int。</int></p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：列表初始化</title>
    <url>/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>在 C++98/03 中，对象初始化方法有很多种，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。<a id="more"></a></p>
<blockquote>
<p>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p>
</blockquote>
<p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98/03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，比如下面的代码：通过初始化列表初始化对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: 'Foo::Foo(const Foo &amp;)' is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。<br>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。<br>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<br>a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p>
<p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在初始化时，<code>{}</code>前面的等于号是否书写对初始化行为没有影响。</p>
</blockquote>
<p>另外，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。<br>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。<br>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p>
<p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span>, <span class="keyword">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p>
<p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：引用限定符</title>
    <url>/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
    <content><![CDATA[<p>C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p>
<a id="more"></a>
<h2 id="1-C-11：引用限定符"><a href="#1-C-11：引用限定符" class="headerlink" title="1. C++11：引用限定符"></a>1. C++11：引用限定符</h2><p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p>
<p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。<strong>所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</strong><br>修改上面程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 17 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。<br>同理，我们再次修改程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p>
<blockquote>
<p>注意：引用限定符不适用于静态成员函数和友元函数。</p>
</blockquote>
<h2 id="2-const和引用限定符"><a href="#2-const和引用限定符" class="headerlink" title="2. const和引用限定符"></a>2. const和引用限定符</h2><p>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 get_num() 就是一个常成员函数。const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。<br>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num,<span class="keyword">int</span> num2) :num(num),num2(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="keyword">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num2() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：右值引用</title>
    <url>/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>右值引用是一种新的 C++ 语法，基于右值引用引申出了 2 种 C++ 编程技巧，分别为移动语义和完美转发。本文主要介绍什么是右值引用以及它的基本用法。</p>
<a id="more"></a>
<h3 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h3><p>右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p>
<blockquote>
<p>左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<p>通常情况下，判断某个表达式是左值还是右值，有以下 2 种方法：</p>
<p>1) 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">// 错误，5 不能为左值</span></span><br></pre></td></tr></table></figure>
<p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。C++ 中的左值也可以当做右值使用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure>
<p>2) 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p>
<blockquote>
<p>注意，以上 2 种判定方法只适用于大部分场景。</p>
</blockquote>
<h3 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h3><p>前面提到，其实 C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  // 右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// a = 100</span></span><br></pre></td></tr></table></figure>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; a = <span class="number">10</span>; <span class="comment">// 编译器不会报错</span></span><br></pre></td></tr></table></figure>
<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
<p>下图给出 C++ 左值引用和右值引用的可以引用的值类型和使用场景：</p>
<p><img src="/2022/06/23/C-11%EF%BC%9A%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/右值引用.jpg" alt></p>
<p>表中，Y 表示支持，N 表示不支持。</p>
<blockquote>
<p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值，而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。当然对于纯右值和将亡值，都属于右值。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：支持函数模板的默认模板参数</title>
    <url>/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>在 C++98/03 标准中，类模板可以有默认的模板参数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是却不支持函数的默认模板参数：<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;  <span class="comment">// error in C++98/03: default template arguments</span></span><br><span class="line"><span class="keyword">void</span> func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
<p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R func(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int；最后 func<double,int>(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</double,int></char></p>
<p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">double</span>&gt;</span><br><span class="line"><span class="keyword">void</span> func(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    func(<span class="string">'c'</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    func();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T=char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。由此不难看出，编译器的自动推导能力并没有想象的那么强大。</p>
<p>总的来说，C++11 支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：返回值类型后置（跟踪返回值类型）</title>
    <url>/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。</p>
<a id="more"></a>
<p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。比如如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure>
<p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p>
<p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) add(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，直接像上面这样写是编译不过的。因为 t、u 在参数列表中，而 C++ 的返回值是前置语法，在返回值定义的时候参数变量还不存在。<br>可行的写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(T() + U()) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。因此，<strong>在 C++11 中增加了返回类型后置（trailing-return-type，又称跟踪返回类型）语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</strong></p>
<p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了进一步说明这个语法，再看另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto func(T&amp; val) -&gt; decltype(foo(val))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果说前一个例子中的 add 使用 C++98/03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：智能指针</title>
    <url>/2022/09/16/C-11%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="一、什么是智能指针"><a href="#一、什么是智能指针" class="headerlink" title="一、什么是智能指针"></a>一、什么是智能指针</h1><p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<a id="more"></a>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。随着C++的发展，有三个解决方案，一个方案对应着一种智能指针。</p>
<ul>
<li>将指针的管理权转移给另外一个对象。对应C++98的auto_ptr。</li>
<li>防止拷贝。对应C++11的unique_ptr。</li>
<li>引用计数。对应C++11的shared_ptr。</li>
</ul>
<p>其实，C++一共提供了四种智能指针：auto_ptr， unique_ptr，shared_ptr，weak_ptr。其中后三个是C++11新增的，第一个由C++98提出，已经被C++11弃用。智能指针都包含在memory库中，要使用智能指针必须包含这个库。</p>
<h1 id="二、auto-ptr"><a href="#二、auto-ptr" class="headerlink" title="二、auto_ptr"></a>二、auto_ptr</h1><p>  auto_ptr的原理是：将资源的管理权由一个对象转移给另外一个对象。但auto_ptr存在下面一些问题：</p>
<h2 id="1、auto-ptr不能共享所有权"><a href="#1、auto-ptr不能共享所有权" class="headerlink" title="1、auto_ptr不能共享所有权"></a>1、auto_ptr不能共享所有权</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p3;</span><br><span class="line">p3 = p1; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>
<p>这样会导致p1，p2，p3同时指向p1内部的原始指针，由于每一个auto_ptr在被销毁的时候都会删除其所指向的对象，原始指针就会被重复删除3次，为了解决这个问题，要么禁用拷贝与赋值运算符，要么设计当auto_ptr拷贝或者赋值的时候对原始指针的所有权转移到新对象去。</p>
<h2 id="2、auto-ptr不能指向数组"><a href="#2、auto-ptr不能指向数组" class="headerlink" title="2、auto_ptr不能指向数组"></a>2、auto_ptr不能指向数组</h2><h2 id="3、auto-ptr不能作为容器成员"><a href="#3、auto-ptr不能作为容器成员" class="headerlink" title="3、auto_ptr不能作为容器成员"></a>3、auto_ptr不能作为容器成员</h2><h2 id="4、auto-ptr不能通过赋值操作来初始化"><a href="#4、auto-ptr不能通过赋值操作来初始化" class="headerlink" title="4、auto_ptr不能通过赋值操作来初始化"></a>4、auto_ptr不能通过赋值操作来初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>) <span class="comment">// 错</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)) <span class="comment">// 对</span></span><br></pre></td></tr></table></figure>
<h1 id="三、unique-ptr"><a href="#三、unique-ptr" class="headerlink" title="三、unique_ptr"></a>三、unique_ptr</h1><p>unique_ptr可以看成是auto_ptr的替代品，用法如下：</p>
<h2 id="1、不支持拷贝构造和赋值运算函数"><a href="#1、不支持拷贝构造和赋值运算函数" class="headerlink" title="1、不支持拷贝构造和赋值运算函数"></a>1、不支持拷贝构造和赋值运算函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> Obj)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span> <span class="title">one</span><span class="params">(ap)</span></span>; <span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">unique_ptr</span> two= one; <span class="comment">// 会出错</span></span><br></pre></td></tr></table></figure>
<h2 id="2、可以移动构造和移动赋值操作"><a href="#2、可以移动构造和移动赋值操作" class="headerlink" title="2、可以移动构造和移动赋值操作"></a>2、可以移动构造和移动赋值操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">Getobj</span><span class="params">()</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Obj)</span></span>;</span><br><span class="line">     <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">unique&lt;Obj&gt; ptr = Getobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Obj())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Obj&gt; <span class="title">ptr2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(ptr1))</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="四、shared-ptr"><a href="#四、shared-ptr" class="headerlink" title="四、shared_ptr"></a>四、shared_ptr</h1><p>如果程序要使用多个指向同一个对象的指针，那么可以使用shared_ptr。基本使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> &lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">5</span>));</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * pint = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//shared_ptr&lt;int&gt;p3 = pint; //error</span></span><br><span class="line"><span class="comment">//p3 = pint; //error</span></span><br><span class="line"></span><br><span class="line">use_count() <span class="comment">//计数数量</span></span><br><span class="line"></span><br><span class="line">unique() <span class="comment">//是否只被一个使用</span></span><br></pre></td></tr></table></figure>
<h1 id="五、weak-ptr"><a href="#五、weak-ptr" class="headerlink" title="五、weak_ptr"></a>五、weak_ptr</h1><p>shared_ptr是一种强引用关系，智能指针直接引用对象，代码会引起循环引用，从而造成内存泄漏。</p>
<p>weak_ptr用于配合shared_ptr使用并不影响对象的生命周期，即存在与否并不影响对象的引用计数器，weak_ptr并没有重载operator-&gt; 和operator* 操作符，因此不可直接通过weak_ptr使用对象。提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象shared_ptr智能指针（对象销毁时，返回空shared_ptr）。</p>
<p>weak_ptr被设计为shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源观测权，但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p>
<p>使用weak_ptr的use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价use_count()==0但更快，表示被观测资源（也就是shared_ptr管理的资源）已经不复存在。</p>
<p>weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源，但当expired==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi2</span><span class="params">(spi1)</span></span>;</span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp1 = spi1; <span class="comment">//观察spi1，不增加引用计数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp1.use_count()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//观察，不能使用 *、-&gt;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp1.expired() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//观察，不能使用 *、-&gt;</span></span><br><span class="line"><span class="keyword">auto</span> spi1 = wp1.lock();</span><br><span class="line"><span class="keyword">if</span>(spi) &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*spi&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL</title>
    <url>/2022/04/25/C-STL/</url>
    <content><![CDATA[<h3 id="什么是-STL"><a href="#什么是-STL" class="headerlink" title="什么是 STL"></a>什么是 STL</h3><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 <a id="more"></a></p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 标准库的重要组成部分。如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装。STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p>
<p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等。</p>
<h3 id="STL-的组成"><a href="#STL-的组成" class="headerlink" title="STL 的组成"></a>STL 的组成</h3><p>通常认为，STL 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">STL的组成</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">容器</td>
<td style="text-align:center">一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td>
</tr>
<tr>
<td style="text-align:left">算法</td>
<td style="text-align:center">STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 \<algorithm> 中，少部分位于头文件 \<numeric> 中。</numeric></algorithm></td>
</tr>
<tr>
<td style="text-align:left">迭代器</td>
<td style="text-align:center">在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td>
</tr>
<tr>
<td style="text-align:left">函数对象</td>
<td style="text-align:center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td>
</tr>
<tr>
<td style="text-align:left">适配器</td>
<td style="text-align:center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td>
</tr>
<tr>
<td style="text-align:left">内存分配器</td>
<td style="text-align:center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td>
</tr>
</tbody>
</table>
</div>
<p>另外，在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++ 标准中，它们被重新组织为 13 个头文件，分别是：\<iterator>、\<functional>、\<vector>、\<deque>、\<list>、\<queue>、\<stack>、\<set>、\<map>、\<algorithm>、\<numeric>、\<memory>和\<utility>。</utility></memory></numeric></algorithm></map></set></stack></queue></list></deque></vector></functional></iterator></p>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：移动构造函数</title>
    <url>/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-拷贝构造函数中的深拷贝问题"><a href="#1-拷贝构造函数中的深拷贝问题" class="headerlink" title="1. 拷贝构造函数中的深拷贝问题"></a>1. 拷贝构造函数中的深拷贝问题</h2><p>在 C++ 98/03 标准中，如果想用其它对象初始化一个同类的新对象，只能借助类中的拷贝构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。<strong>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。</strong></p>
<a id="more"></a>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ~demo()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"class destruct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</p>
<p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
<ol>
<li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</li>
<li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li>
<li>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li>
<li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li>
</ol>
<p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure>
<p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!        &lt;-- 执行 demo()</span><br><span class="line">copy construct!    &lt;-- 执行 <span class="keyword">return</span> demo()</span><br><span class="line">class destruct!     &lt;-- 销毁 demo() 产生的匿名对象</span><br><span class="line">copy construct!    &lt;-- 执行 a = get_demo()</span><br><span class="line">class destruct!     &lt;-- 销毁 get_demo() 返回的临时对象</span><br><span class="line">class destruct!     &lt;-- 销毁 a</span><br></pre></td></tr></table></figure>
<p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p>
<blockquote>
<p>事实上，此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p>
</blockquote>
<p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p>
<h2 id="2-C-移动构造函数（移动语义的具体实现）"><a href="#2-C-移动构造函数（移动语义的具体实现）" class="headerlink" title="2. C++移动构造函数（移动语义的具体实现）"></a>2. C++移动构造函数（移动语义的具体实现）</h2><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p>
<blockquote>
<p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p>
</blockquote>
<p>例如，下面程序对 demo 类进行了修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    demo(demo &amp;&amp;d):num(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"move construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"class destruct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。<strong>和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。</strong>并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="built_in">move</span> construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br><span class="line"><span class="class"><span class="title">move</span> <span class="title">construct</span>!</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">destruct</span>!</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure>
<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>那么，如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：关联容器</title>
    <url>/2022/05/04/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h3><p>顺序容器存储的都是 C++ 基本数据类型，而关联容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。<a id="more"></a></p>
<blockquote>
<p>弃用顺序容器，转而选用关联容器存储元素，往往就是看中了关联容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p>
</blockquote>
<p>也就是说，使用关联容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和顺序容器最大的不同。除此之外，顺序容器中存储的元素默认都是未经过排序的，而使用关联容器存储的元素，默认会根据各元素的键值的大小做升序排序。</key,value></p>
<p>关联容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种数据结构来组织和存储各个键值对。</p>
<h4 id="关联容器种类"><a href="#关联容器种类" class="headerlink" title="关联容器种类"></a>关联容器种类</h4><p>C++ STL 标准库提供了 4 种关联容器，分别为 map、set、multimap、multiset，其各自的特点如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关联式容器名称</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>定义在 \<map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less\<T>）。</T></map></td>
</tr>
<tr>
<td>set</td>
<td>定义在 \<set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less\<T>）。</T></set></td>
</tr>
<tr>
<td>multimap</td>
<td>定义在 \<map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</map></td>
</tr>
<tr>
<td>multiset</td>
<td>定义在 \<set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</set></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但哈希容器底层采用的是哈希表，而不是红黑树。</p>
</blockquote>
<h3 id="pair-用法详解"><a href="#pair-用法详解" class="headerlink" title="pair 用法详解"></a>pair 用法详解</h3><p>我们知道，关联容器存储的是“键值对”形式的数据，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如上所示，每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）。</p>
<blockquote>
<p>注意，基于各个关联容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联容器存储，否则就要选用 map 或者 multimap 关联容器。</p>
</blockquote>
<p>考虑到“键值对”并不是普通类型数据，C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<first, second>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</first,></p>
<p>注意，pair 类模板定义在\<utility>头文件中，所以在使用该类模板之前，需引入此头文件。</utility></p>
<p>1) 在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 默认构造函数，即创建空的 pair 对象</span></span><br><span class="line">pair();</span><br><span class="line"><span class="comment">// 2) 直接使用 2 个元素初始化成 pair 对象</span></span><br><span class="line">pair (<span class="keyword">const</span> first_type&amp; a, <span class="keyword">const</span> second_type&amp; b);</span><br><span class="line"><span class="comment">// 3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span></span><br><span class="line">template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</span><br></pre></td></tr></table></figure>
<p>在 C++ 11 标准中，在引入右值引用的基础上，pair 类模板中又增添了如下 2 个构造函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4) 移动构造函数</span></span><br><span class="line">template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</span><br><span class="line"><span class="comment">// 5) 使用右值引用参数，创建 pair 对象</span></span><br><span class="line">template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</span><br></pre></td></tr></table></figure>
<p>除此之外，C++ 11 标准中 pair 类模板还新增加了如下一种构造函数：<code>pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);</code>，但该构造 pair 类模板的方式很少用到。</p>
<p>下面程序演示了以上几种创建 pair 对象的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair2(<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair3(pair2);</span><br><span class="line">    <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4(make_pair(<span class="string">"C++教程"</span>, <span class="string">"http://c.biancheng.net/cplus/"</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair5(<span class="built_in">string</span>(<span class="string">"Python教程"</span>), <span class="built_in">string</span>(<span class="string">"http://c.biancheng.net/python/"</span>));  </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair3: "</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair4: "</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair5: "</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pair1: <span class="number">0</span></span><br><span class="line">pair2: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair3: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair4: C++教程 http://c.biancheng.net/cplus/</span><br><span class="line">pair5: Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<p>上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 \<utility> 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（是一个临时对象）作为参数传递给 pair() 构造函数时，其调用的是移动构造函数，而不是拷贝构造函数。</utility></p>
<p>在上面程序的基础上，C++ 11 还允许我们手动为 pair1 对象赋值，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair1.first = <span class="string">"Java教程"</span>;</span><br><span class="line">pair1.second = <span class="string">"http://c.biancheng.net/java/"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"new pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new pair1: Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<p>同时，上面程序中 pair4 对象的创建过程，还可以写成如下形式，它们是完全等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4 = make_pair(<span class="string">"C++教程"</span>, <span class="string">"http://c.biancheng.net/cplus/"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pair4: "</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>2) <code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 <code>&lt;、&lt;=、&gt;、&gt;=、==、!=</code> 这 6 个运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。</p>
<blockquote>
<p>注意，对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性，同时编译器提示没有相匹配的运算符，即找不到合适的重载运算符。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">"STL教程"</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">"C++教程"</span>, <span class="number">20</span>);</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3(<span class="string">"C++教程"</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair != pair2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2 != pair3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pair != pair2</span><br><span class="line">pair2 != pair3</span><br></pre></td></tr></table></figure>
<p>3) 最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">"pair"</span>, <span class="number">10</span>);                   </span><br><span class="line">    pair &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">"pair2"</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.swap(pair2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pair1: pair2 <span class="number">20</span></span><br><span class="line">pair2: pair <span class="number">10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11：非受限联合体（union）</title>
    <url>/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/</url>
    <content><![CDATA[<p>在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p>
<a id="more"></a>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> T&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<h2 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h2><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++11 取消了这种限制。</p>
<p>POD 是 C++ 中一个比较重要的概念，POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：<br>1) 没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</p>
<p>2) 不能包含虚函数和虚基类。</p>
<p>3) 非静态成员必须声明为 public。</p>
<p>4) 类中的第一个非静态成员的类型与其基类不同，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p>
<p>5) 在类或者结构体继承时，满足以下两种情况之一：</p>
<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
<p>比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; <span class="keyword">int</span> n1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span> :</span> B2 &#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure>
<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<p>6) 所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p>
<p>7) 此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p>
<h2 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h2><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h2 id="3-非受限联合体的赋值注意事项"><a href="#3-非受限联合体的赋值注意事项" class="headerlink" title="3. 非受限联合体的赋值注意事项"></a>3. 非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。这条规则可能导致对象构造失败，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U() &#123; <span class="keyword">new</span>(&amp;s) <span class="built_in">string</span>; &#125;</span><br><span class="line">    ~U() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h3 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h3><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。placement new 的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) ClassConstruct(...)</span><br></pre></td></tr></table></figure>
<p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h2 id="4-非受限联合体的匿名声明和“枚举式类”"><a href="#4-非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="4. 非受限联合体的匿名声明和“枚举式类”"></a>4. 非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> U&#123;</span><br><span class="line">  <span class="keyword">union</span> &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Type &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    Singer(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : s(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    Singer(<span class="keyword">int</span> i) : id(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, <span class="built_in">size</span>);</span><br><span class="line">        name[s] = <span class="string">'\0'</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singer(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    Singer(<span class="number">310217</span>);</span><br><span class="line">    Singer(<span class="string">"J Michael"</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>
]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：容器与迭代器</title>
    <url>/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。<a id="more"></a>STL 提供有 3 类标准容器，分别是顺序容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">容器种类</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">顺序容器</td>
<td style="text-align:center">主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td>
</tr>
<tr>
<td style="text-align:left">排序容器</td>
<td style="text-align:center">包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以排序容器在查找时具有非常好的性能。</td>
</tr>
<tr>
<td style="text-align:left">哈希容器</td>
<td style="text-align:center">C++ 11 新加入 4 种关联容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是顺序容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p>
<p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p>
<p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p>
<p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p>
<h4 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h4><p>STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p>
<p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。其中，输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。其他3种迭代器的功能如下所示：</p>
<ul>
<li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p>
</li>
<li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有前向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 <code>--p</code> 或者 <code>p--</code> 操作（即一次向后移动一个位置）。</p>
</li>
<li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p+=i：使得 p 往后移动 i 个元素。</span><br><span class="line">p-=i：使得 p 往前移动 i 个元素。</span><br><span class="line">p+i：返回 p 后面第 i 个元素的迭代器。</span><br><span class="line">p-i：返回 p 前面第 i 个元素的迭代器。</span><br><span class="line">p[i]：返回 p 后面第 i 个元素的引用。</span><br></pre></td></tr></table></figure>
<p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减1）。</p>
</li>
</ul>
<p>下表所示，是 C++ 11 标准中不同容器指定使用的迭代器类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">容器</th>
<th style="text-align:left">对应的迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">array</td>
<td style="text-align:left">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:left">vector</td>
<td style="text-align:left">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:left">deque</td>
<td style="text-align:left">随机访问迭代器</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">双向迭代器</td>
</tr>
<tr>
<td style="text-align:left">set / multiset</td>
<td style="text-align:left">双向迭代器</td>
</tr>
<tr>
<td style="text-align:left">map / multimap</td>
<td style="text-align:left">双向迭代器</td>
</tr>
<tr>
<td style="text-align:left">forward_list</td>
<td style="text-align:left">前向迭代器</td>
</tr>
<tr>
<td style="text-align:left">unordered_map / unordered_multimap</td>
<td style="text-align:left">前向迭代器</td>
</tr>
<tr>
<td style="text-align:left">unordered_set / unordered_multiset</td>
<td style="text-align:left">前向迭代器</td>
</tr>
<tr>
<td style="text-align:left">stack</td>
<td style="text-align:left">不支持迭代器</td>
</tr>
<tr>
<td style="text-align:left">queue</td>
<td style="text-align:left">不支持迭代器</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</p>
</blockquote>
<h4 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h4><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>迭代器定义方式</th>
<th>具体格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>正向迭代器</td>
<td>容器类名::iterator  迭代器名;</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>容器类名::const_iterator  迭代器名;</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>容器类名::reverse_iterator  迭代器名;</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>容器类名::const_reverse_iterator  迭代器名;</td>
</tr>
</tbody>
</table>
</div>
<p>值得一提的是，上表中的反向迭代器全称为 “反向迭代器适配器”。</p>
<p>通过定义以上几种迭代器，就可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</p>
<blockquote>
<p>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p>
</blockquote>
<h4 id="迭代器实例"><a href="#迭代器实例" class="headerlink" title="迭代器实例"></a>迭代器实例</h4><p>1) 以上对迭代器做了很详细的介绍，下面就以 vector 容器为例，实际感受迭代器的用法和功能。通过前面的学习，我们知道 vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;; <span class="comment">// 初始化v，有10个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">// 像普通数组一样使用vector容器</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;    <span class="comment">// 创建一个正向迭代器，当然，vector也支持其他3种定义迭代器的方式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第二种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)  <span class="comment">// 用 "!=" 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第三种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 "&lt;" 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第四种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        i += <span class="number">1</span>; <span class="comment">// 随机访问迭代器支持 "+=" 的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第二种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第三种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第四种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>2) 再举一个例子，我们知道，list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个list容器 v</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>
<p>则以下代码是合法的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>
<p>以下代码则不合法，因为双向迭代器不支持用 “&lt;” 进行比较：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>
<p>以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>
<h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p>其实在 C++ 中，数组也是容器，数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器，则 a、a+1、a+2 都是 a 的迭代器。</p>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：顺序容器</title>
    <url>/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-顺序容器概述"><a href="#1-顺序容器概述" class="headerlink" title="1. 顺序容器概述"></a>1. 顺序容器概述</h3><p>所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。<a id="more"></a></p>
<p>顺序容器主要包含以下几类容器：</p>
<ul>
<li>array<T,N>（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值。</T,N></li>
<li>vector\<T>（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）。</T></li>
<li>deque\<T>（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶。</T></li>
<li>list\<T>（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</T></li>
<li>forward_list\<T>（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</T></li>
</ul>
<blockquote>
<p>注意，其实除此之外，stack 和 queue 本质上也属于顺序容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。</p>
</blockquote>
<p>下图说明了各种顺序容器及它们之间的区别：</p>
<p><img src="/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/pic1.jpg" alt></p>
<hr>
<h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. Array</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>Array 容器是 C++ 11 标准中新增的顺序容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p>
<p>array 容器以类模板的形式定义在 \<array> 头文件，并位于命名空间 std 中，如下所示：</array></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，在使用该容器之前，代码中需引入 \<array> 头文件，并默认使用 std 命令空间，如下所示：</array></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>在 array<T,N> 类模板中，T 用于指明容器中存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。</T,N></p>
<p>1) array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure>
<p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p>
<p>2) 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>使用该语句，容器中所有的元素都会被初始化为 0.0。</p>
<p>3) 当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-成员函数"><a href="#2-2-成员函数" class="headerlink" title="2.2 成员函数"></a>2.2 成员函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的随机访问迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>另外，在 \<array> 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</array></p>
<h4 id="2-3-迭代器"><a href="#2-3-迭代器" class="headerlink" title="2.3 迭代器"></a>2.3 迭代器</h4><p>STL 为 array 容器配备了随机访问迭代器，该类迭代器是功能最强大的迭代器。在 array 容器的模板类中，和随机访问迭代器相关的成员函数如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，则该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，则该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，则该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，则该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 标准新增的 begin() 和 end() 函数，当操作对象为 array 容器时，也和迭代器有关，其功能分别和上表中的 begin()、end() 成员函数相同。</p>
<h5 id="2-3-1-begin-end-和-cbegin-cend"><a href="#2-3-1-begin-end-和-cbegin-cend" class="headerlink" title="2.3.1 begin()/end() 和 cbegin()/cend()"></a>2.3.1 begin()/end() 和 cbegin()/cend()</h5><p>1) array 容器模板类中的 begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p>
<p>例如，可以在循环中显式地使用迭代器来初始化 values 容器的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        ++h;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p>
<p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，因为当操作对象为 array 容器时，它们和 begin()/end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure>
<p>这样，容器中的一段元素可以由迭代器指定，这让我们有了对它们使用算法的可能。</p>
<blockquote>
<p>需要注意的是，STL 中不是只有 array 容器，当迭代器指向容器中的一个特定元素时，它们不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，它是指向 array 容器还是指向 vector 容器。</p>
</blockquote>
<p>2) 除此之外，array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。例如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.cend();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 *first 为 const 类型，不能用来修改元素，因此下面的代码错误</span></span><br><span class="line">    <span class="comment">// *first = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="comment">// 可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-rbegin-rend-和-crbegin-crend"><a href="#2-3-2-rbegin-rend-和-crbegin-crend" class="headerlink" title="2.3.2 rbegin()/rend() 和 crbegin()/crend()"></a>2.3.2 rbegin()/rend() 和 crbegin()/crend()</h5><p>array 模板类中还提供了 rbegin()/rend() 和 crbegin()/crend() 成员函数，它们每对都可以分别得到指向最一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。也就是说，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能“互换”了。</p>
<p>反向迭代器用于以逆序的方式处理元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.rend();</span><br><span class="line">    <span class="comment">// 初始化 values 容器为 &#123;5,4,3,2,1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        ++h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序遍历容器，并输出各个元素</span></span><br><span class="line">    first = values.rbegin();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，从最后一个元素开始循环，不仅完成了容器的初始化，还遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p>
<p>当然，在上面程序中，我们也可以使用 for 循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crbegin()/crend() 组合和 rbegin()/rend() 组合的功能唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p>
<h4 id="2-4-访问元素"><a href="#2-4-访问元素" class="headerlink" title="2.4 访问元素"></a>2.4 访问元素</h4><h5 id="2-4-1-访问array容器中单个元素"><a href="#2-4-1-访问array容器中单个元素" class="headerlink" title="2.4.1 访问array容器中单个元素"></a>2.4.1 访问array容器中单个元素</h5><p>1) 首先，可以通过容器名[]的方式直接访问和使用容器中的元素，这和 C++ 标准数组访问元素的方式相同，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这种方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p>
<p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values.at(<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2.</span>O*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码和前一行语句实现的功能相同，但当传给 at() 的索引是一个越界值时，程序会抛出 <code>std::out_of_range</code> 异常。因此当需要访问容器中某个指定元素时，建议使用 at()，除非确定索引没有越界。</p>
<blockquote>
<p>我们可能会有这样一个疑问，即为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单：因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p>
</blockquote>
<p>2) 除此之外，array 容器还提供了 get\<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</n></p>
<p>下面代码展示了如何使用 get\<n> 模板函数：</n></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">string</span>, 5&gt; words&#123; <span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 words[3]，即 "four"</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; endl; // 越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3) 另外，array 容器还提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的指针。通过该指针，我们可以获得容器中的各个元素，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *( words.data()+<span class="number">1</span>); <span class="comment">// 输出结果为：2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4-2-访问array容器中多个元素"><a href="#2-4-2-访问array容器中多个元素" class="headerlink" title="2.4.2 访问array容器中多个元素"></a>2.4.2 访问array容器中多个元素</h5><p>1) 我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has no elements.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has "</span> &lt;&lt; values.<span class="built_in">size</span>() &lt;&lt; <span class="string">" elements.\n"</span>;</span><br></pre></td></tr></table></figure>
<p>然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p>
<blockquote>
<p>array 容器之所以提供 empty() 成员函数的原因是因为：对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p>
</blockquote>
<p>2) 除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：关联容器之map和multimap</title>
    <url>/2022/05/05/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bmap%E5%92%8Cmultimap/</url>
    <content><![CDATA[<h2 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、结构体或类自定义的类型。<a id="more"></a></p>
<blockquote>
<p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。</p>
</blockquote>
<p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 STL 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p>
<p>另外需要注意的是，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p>
<blockquote>
<p>前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair<const k, t> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</const></p>
</blockquote>
<p>map 容器定义在 \<map> 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句：</map></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 map 容器时，需手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>map 容器的模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                     // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,                                       // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                     // 指定排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;    // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">map</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>下表出了 map 容器提供的常用成员方法以及各自的功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 map 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[]</td>
<td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td>
</tr>
<tr>
<td>at(key)</td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 map 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="创建C-map容器的几种方法"><a href="#创建C-map容器的几种方法" class="headerlink" title="创建C++ map容器的几种方法"></a>创建C++ map容器的几种方法</h3><p>map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面介绍几种常用的创建 map 容器的方法。</p>
<p>1) 通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此创建空 map 容器是比较常用的。</p>
<p>2) 当然在创建 map 容器的同时，也可以进行初始化，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>由此，myMap 容器在初始状态下，就包含有 2 个键值对。</p>
<p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123;<span class="built_in">std</span>::make_pair(<span class="string">"C语言教程"</span>,<span class="number">10</span>),<span class="built_in">std</span>::make_pair(<span class="string">"STL教程"</span>,<span class="number">20</span>)&#125;;</span><br></pre></td></tr></table></figure>
<p>3) 除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, int&gt; newMap(myMap);</span><br></pre></td></tr></table></figure>
<p>由此，通过调用 map 容器的拷贝（复制）构造函数，即可成功创建一个和 myMap 完全一样的 newMap 容器。</p>
<p>C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。举个例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个会返回临时 map 对象的函数</span></span><br><span class="line">std::map&lt;std::string,int&gt; disMap() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;tempMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, int&gt; newMap(disMap());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<p>4) map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, int&gt; newMap(++myMap.begin(), myMap.end());</span><br></pre></td></tr></table></figure>
<p>这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {“STL教程”,20} 键值对的容器。</p>
<p>5) 当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less\<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。因此，如下 2 行创建 map 容器的方式，其实是等价的：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>以上 2 中创建方式生成的 myMap 容器，其内部键值对排列的顺序为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">"C语言教程"</span>, <span class="number">10</span>&gt;</span><br><span class="line">&lt;<span class="string">"STL教程"</span>, <span class="number">20</span>&gt;</span><br></pre></td></tr></table></figure>
<p>下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &gt; myMap&#123; &#123;<span class="string">"C语言教程"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"STL教程"</span>,<span class="number">20</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>此时，myMap 容器内部键值对排列的顺序为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">"STL教程"</span>, <span class="number">20</span>&gt;</span><br><span class="line">&lt;<span class="string">"C语言教程"</span>, <span class="number">10</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些特定场景中，我们还需要为 map 容器自定义排序规则。</p>
</blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是前面学习的顺序容器，还是关联容器，要想实现遍历操作，就必须要用到该类型容器的迭代器。当然，map 容器也不例外。</p>
<p>C++ STL 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 <code>++p、p++、--p、p--、*p</code> 操作，并且迭代器之间只能使用 <code>==</code> 或者 <code>!=</code> 运算符进行比较。</p>
<p>值得一提的是，相比顺序容器，map 容器提供了更多的成员方法（如下表所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
</tbody>
</table>
</div>
<p>上表中多数的成员方法，诸如 begin()、end() 等，在学习顺序容器时已经多次使用过，它们的功能如下图所示：</p>
<p><img src="/2022/05/05/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bmap%E5%92%8Cmultimap/map-迭代器.jpg" alt></p>
<blockquote>
<p>注意，图中 Ei 表示的是 pair 类对象，即键值对。对于 map 容器来说，每个键值对的键的值都必须保证是唯一的。</p>
</blockquote>
<p>1) 下面程序以 begin()/end() 组合为例，演示如何遍历 map 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,&#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 调用 begin()/end() 组合，遍历 map 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myMap.<span class="built_in">begin</span>(); iter != myMap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>2) 除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向迭代器；反之，其功能和 end() 方法相同。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 查找键为 "Java教程" 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">find</span>(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="comment">// 从 iter 开始，遍历 map 容器</span></span><br><span class="line">    <span class="keyword">for</span> (; iter != myMap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>此程序中，创建并初始化的 myMap 容器，默认会根据各键值对中键的值，对各键值对做升序排序，其排序的结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&gt;</span><br><span class="line">&lt;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在此基础上，通过调用 find() 方法，我们可以得到一个指向键为 “Java教程” 的键值对的迭代器，由此当使用 for 循环从该迭代器出开始遍历时，就只会遍历到最后 2 个键值对。</p>
<p>3) 同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p>
<ul>
<li>lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；</li>
<li>upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；</li>
</ul>
<p>下面程序演示了它们的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 找到第一个键的值不小于 "Java教程" 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.lower_bound(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lower："</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 找到第一个键的值大于 "Java教程" 的键值对</span></span><br><span class="line">    iter = myMap.upper_bound(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"upper："</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lower：Java教程 http://c.biancheng.net/java/</span><br><span class="line">upper：STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</p>
</blockquote>
<p>4) equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p>
<p>显然，equal_range(key) 成员方法表示的是一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator&gt; myPair = myMap.equal_range(<span class="string">"C语言教程"</span>);</span><br><span class="line">    <span class="comment">// 通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，其返回的范围内最多也只有 1 个键值对。</p>
</blockquote>
<h3 id="map获取键对应值的几种方法"><a href="#map获取键对应值的几种方法" class="headerlink" title="map获取键对应值的几种方法"></a>map获取键对应值的几种方法</h3><p>我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p>
<blockquote>
<p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p>
</blockquote>
<p>庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。</p>
<p>1) map 类模板中对<code>[]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">string</span> cValue = myMap[<span class="string">"C语言教程"</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cValue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure>
<p>可以看到，在第 11 行代码中，通过指定键的值为 “C语言教程”，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。</p>
<p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;myMap;</span><br><span class="line">    <span class="keyword">int</span> cValue = myMap[<span class="string">"C语言教程"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">" "</span>&lt;&lt; i-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C语言教程 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>显然，对于空的 myMap 容器来说，其内部没有以 “C语言教程” 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个<code>&lt;&quot;C语言教程&quot;,0&gt;</code>键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）。</p>
<p>实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;myMap;</span><br><span class="line">    myMap[<span class="string">"STL教程"</span>]=<span class="string">"http://c.biancheng.net/java/"</span>;</span><br><span class="line">    myMap[<span class="string">"Python教程"</span>] = <span class="string">"http://c.biancheng.net/python/"</span>;</span><br><span class="line">    myMap[<span class="string">"STL教程"</span>] = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>注意，程序中第 9 行代码已经为 map 容器添加了一个以 “STL教程” 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。</p>
<p>2) 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMap.at(<span class="string">"C语言教程"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面一行代码会引发 out_of_range 异常</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; myMap.at("Python教程") &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure>
<p>程序第 11 行代码处，通过 myMap 容器调用 at() 成员方法，可以成功找到键为 “C语言教程” 的键值对，并返回该键对应的值；而第 13 行代码，由于当前 myMap 容器中没有以 “Python教程” 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。</p>
<p>3) 除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">map</span>&lt; <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt;::iterator myIter = myMap.<span class="built_in">find</span>(<span class="string">"C语言教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myIter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; myIter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，此程序中如果 find() 查找失败，会导致第 12 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。</p>
</blockquote>
<p>4) 如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;      // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;myMap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myMap.<span class="built_in">begin</span>(); iter != myMap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="comment">// 调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (!iter-&gt;first.compare(<span class="string">"C语言教程"</span>)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，更推荐使用 at() 成员方法，因为该方法既简单又安全。</p>
</blockquote>
<h3 id="map-insert-插入数据的4种方式"><a href="#map-insert-插入数据的4种方式" class="headerlink" title="map insert()插入数据的4种方式"></a>map insert()插入数据的4种方式</h3><p>前面讲过，C++ STL map 类模板中对<code>[]</code>运算符进行了重载，即根据使用场景的不同，借助<code>[]</code>运算符可以实现不同的操作。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 获取已存储键值对中，指定键对应的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymap[<span class="string">"STL教程"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 向 map 容器添加新键值对</span></span><br><span class="line">    mymap[<span class="string">"Python教程"</span>] = <span class="string">"http://c.biancheng.net/python/"</span>;</span><br><span class="line">    <span class="comment">// 修改 map 容器已存储键值对中，指定键对应的值</span></span><br><span class="line">    mymap[<span class="string">"STL教程"</span>] = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>可以看到，当操作对象为 map 容器中已存储的键值对时，则借助 [ ] 运算符，既可以获取指定键对应的值，还能对指定键对应的值进行修改；反之，若 map 容器内部没有存储以 [ ] 运算符内指定数据为键的键值对，则使用 [ ] 运算符会向当前 map 容器中添加一个新的键值对。</p>
<p>实际上，除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p>
<p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</p>
<p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p>
<p>1) 无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、引用传递一个键值对</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">// 2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> (<span class="title">P</span>&amp;&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
<p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li>
<li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li>
</ul>
<blockquote>
<p>以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.insert(STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入失败样例</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">1</span>&gt;</span><br><span class="line">ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, <span class="number">1</span>&gt;</span><br><span class="line">ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：</p>
<ul>
<li>对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量。</li>
<li>对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 “STL教程” 的键值对和值为 0 的 bool 变量。</li>
</ul>
<p>另外，在程序中的第 22 行代码，还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 pair 类模板的构造函数</span></span><br><span class="line">ret = mymap.insert(pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123; <span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span> &#125;);</span><br><span class="line"><span class="comment">// 调用 make_pair() 函数</span></span><br><span class="line">ret = mymap.insert(make_pair(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>));</span><br></pre></td></tr></table></figure>
<p>2) 除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">iterator</span> <span class="title">insert</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">P</span>&amp;&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
<p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p>
<ul>
<li>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</li>
<li>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span> &#125;;</span><br><span class="line">    <span class="comment">// 指定要插入的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.insert(it, STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter1-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.insert(it, <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter2-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.insert(it, <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter3-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</p>
<p>3) insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">insert</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 都是迭代器，它们的组合<code>&lt;first,last&gt;</code>可以表示某 map 容器中的指定区域。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;copymap;</span><br><span class="line">    <span class="comment">// 指定插入区域</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.insert(first, last);</span><br><span class="line">    <span class="comment">// 遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Java教程 http://c.biancheng.net/java/p</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>此程序中，<first,last> 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。</first,last></p>
<p>4) 除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，vali 都表示的是键值对变量。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空的 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap;</span><br><span class="line">    <span class="comment">// 向 mymap 容器中添加 3 个键值对</span></span><br><span class="line">    mymap.insert(&#123; &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">                   &#123; <span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span> &#125;,</span><br><span class="line">                   &#123; <span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span> &#125; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<h3 id="map-emplace-和emplace-hint-方法"><a href="#map-emplace-和emplace-hint-方法" class="headerlink" title="map emplace()和emplace_hint()方法"></a>map emplace()和emplace_hint()方法</h3><p>学习 map insert() 方法时提到，C++ STL map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。</p>
<blockquote>
<p>值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高。</p>
</blockquote>
<p>1) 和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">emplace</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li>
<li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li>
</ul>
<p>下面程序演示 emplace() 方法的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymap;</span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.emplace(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    ret = mymap.emplace(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 失败插入的样例</span></span><br><span class="line">    ret = mymap.emplace(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、ret.iter = &lt;&#123;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">"&#125;, "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">1</span>&gt;</span><br><span class="line"><span class="number">2</span>、ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, <span class="number">1</span>&gt;</span><br><span class="line"><span class="number">3</span>、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p>
<p>2) emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">iterator</span> <span class="title">emplace_hint</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p>
<ol>
<li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li>
<li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li>
</ol>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  // map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymap;</span><br><span class="line">    <span class="comment">// 指定在 map 容器插入键值对</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter = mymap.emplace_hint(mymap.<span class="built_in">begin</span>(),<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    iter = mymap.emplace_hint(mymap.<span class="built_in">begin</span>(), <span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 插入失败样例</span></span><br><span class="line">    iter = mymap.emplace_hint(mymap.<span class="built_in">begin</span>(), <span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p>
<hr>
<h2 id="2-multimap"><a href="#2-multimap" class="headerlink" title="2. multimap"></a>2. multimap</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在掌握 C++ STL map 容器的基础上，本节介绍一个和 map 相似的关联容器，即 multimap 容器。</p>
<p>所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair<const k, t> 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。</const></p>
<p>和 map 容器一样，实现 multimap 容器的类模板也定义在\<map>头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：</map></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<p>multimap 容器类模板的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                                   // 指定键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,                                     // 指定值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;,                   // 指定排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;pair&lt;const Key,T&gt; &gt;  // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">multimap</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，multimap 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。</p>
<h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multimap 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 multimap 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。</td>
</tr>
</tbody>
</table>
</div>
<p>和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p>
<blockquote>
<p>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此上表中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。</p>
</blockquote>
<h3 id="创建C-multimap容器的方法"><a href="#创建C-multimap容器的方法" class="headerlink" title="创建C++ multimap容器的方法"></a>创建C++ multimap容器的方法</h3><p>multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。</p>
<p>1) 通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultimap;</span><br></pre></td></tr></table></figure>
<p>2) 当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化 multimap 容器</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>注意，使用此方式初始化 multimap 容器时，其底层会先将每一个<code>{key, value}</code>创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</p>
<p>实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借助 pair 类模板的构造函数来生成各个pair类型的键值对</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymultimap&#123;</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123; <span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123; <span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用 make_pair() 函数，生成键值对元素</span></span><br><span class="line"><span class="comment">// 创建并初始化 multimap 容器</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymultimap&#123;</span><br><span class="line">    make_pair(<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>),</span><br><span class="line">    make_pair(<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>),</span><br><span class="line">    make_pair(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3) 除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">multimap&lt;string, string&gt; newmultimap(mymultimap);</span><br></pre></td></tr></table></figure>
<p>由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。</p>
<p>在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个会返回临时 multimap 对象的函数</span></span><br><span class="line">multimap&lt;string, string&gt; dismultimap() &#123;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;tempmultimap&#123; &#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,&#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 调用 multimap 类模板的移动构造函数创建 newMultimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt; newmultimap(dismultimap());</span><br></pre></td></tr></table></figure>
<p>上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。</p>
<blockquote>
<p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<p>4) multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化 multimap 容器</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">"C语言教程"</span>, <span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(++mymultimap.<span class="built_in">begin</span>(), mymultimap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器。</p>
<p>5) 前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为<code>std::less&lt;T&gt;</code>，这意味着以下 2 种创建 multimap 容器的方式是等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mymultimap&#123; &#123;<span class="string">'a'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'b'</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">char</span>&gt;&gt; mymultimap&#123; &#123;<span class="string">'a'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'b'</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>mymultimap 容器中键值对的存储顺序为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;a,<span class="number">1</span>&gt;</span><br><span class="line">&lt;b,<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>下面程序利用了 STL 模板库提供的<code>std::greater&lt;T&gt;</code>排序函数，实现令 multimap 容器对存储的键值对做降序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">char</span>&gt;&gt; mymultimap&#123; &#123;<span class="string">'a'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'b'</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>其内部键值对的存储顺序为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;b,<span class="number">2</span>&gt;</span><br><span class="line">&lt;a,<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些特定场景中，我们还可以为 multimap 容器自定义排序规则。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：顺序容器之deque</title>
    <url>/2022/04/29/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>deque 是 double-ended queue 的缩写，又称双端队列容器。<a id="more"></a>deque 容器和 vecotr 容器有很多相似之处，比如：</p>
<ul>
<li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。</li>
<li>deque 容器也可以根据需要修改自身的容量和大小。</li>
</ul>
<p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶O(1)。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p>
<blockquote>
<p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p>
</blockquote>
<p>deque 容器以模板类 deque\<T>（T 为存储元素的类型）的形式在 \<deque> 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</deque></T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-成员函数"><a href="#2-成员函数" class="headerlink" title="2. 成员函数"></a>2. 成员函数</h3><p>基于 deque 双端队列的特点，该容器包含一些 array、vector 容器都没有的成员函数，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，比如 2^32-1，我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的头部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p>
</blockquote>
<p>和 array、vector 相同，C++ 11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2 个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<h3 id="3-创建deque容器的几种方式"><a href="#3-创建deque容器的几种方式" class="headerlink" title="3. 创建deque容器的几种方式"></a>3. 创建deque容器的几种方式</h3><p>创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。</p>
<p>1) 创建一个没有任何元素的空 deque 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br></pre></td></tr></table></figure>
<p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p>
<p>2) 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p>
<p>3) 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p>
<p>4) 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<p>5) 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），也可以创建一个新容器，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建 deque 容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于所有类型的容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(arr.<span class="built_in">begin</span>() + <span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝 arr 容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h3><p>deque 容器迭代器的类型为随机访问迭代器，deque 模板类提供了下表所示这些成员函数，通过调用这些函数，可以获得表示不同含义的随机访问迭代器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody>
</table>
</div>
<p>C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 deque 容器。即当操作对象为 deque 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p>
<p>同样的，这些成员函数通常也是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p>
<blockquote>
<p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<h4 id="deque容器迭代器的基本用法"><a href="#deque容器迭代器的基本用法" class="headerlink" title="deque容器迭代器的基本用法"></a>deque容器迭代器的基本用法</h4><p>deque 容器迭代器常用来遍历容器中存储的各个元素。</p>
<p>1) begin() 和 end() 分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 deque 容器并输出其中的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 从容器首元素，遍历至最后一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i &lt; d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>前面提到，STL 还提供有全局的 begin() 和 end() 函数，当操作对象为容器时，它们的功能是上面的 begin()/end() 成员函数一样。例如，将上面程序中的第 8~10 行代码可以用如下代码替换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">begin</span>(d); i &lt; <span class="built_in">end</span>(d); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译运行程序，会发现输出结果和上面一致。</p>
<p>2) cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = d.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = d.cend();</span><br><span class="line">    <span class="comment">// 常量迭代器不能用来修改容器中的元素值</span></span><br><span class="line">    <span class="comment">//*(first + 1) = 6; // 尝试修改容器中元素 2 的值</span></span><br><span class="line">    <span class="comment">//*(end - 1) = 10; // 尝试修改容器中元素 5 的值</span></span><br><span class="line">    <span class="comment">// 常量迭代器可以用来遍历容器、访问容器中的元素</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>程序中，由于 first 和 end 都是常量迭代器，因此第 10、11 行修改容器内元素值的操作都是非法的。</p>
<p>3) deque 模板类中还提供了 rbegin() 和 rend() 成员函数，它们分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又常称为反向迭代器。</p>
<blockquote>
<p>需要注意的是，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p>
</blockquote>
<p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.rbegin(); i &lt; d.rend(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>4) crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型迭代器，不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p>
<h4 id="deque容器迭代器的使用注意事项"><a href="#deque容器迭代器的使用注意事项" class="headerlink" title="deque容器迭代器的使用注意事项"></a>deque容器迭代器的使用注意事项</h4><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p>
<p>例如，如下代码中注释部分是错误的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//*first = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于空的 deque 容器来说，可以通过 push_back()、push_front() 或者 resize() 成员函数实现向（空）deque 容器中添加元素。</p>
</blockquote>
<p>除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 添加元素，会导致 first 失效</span></span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中第 12 行代码，会导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。</p>
<blockquote>
<p>在对容器做添加元素的操作之后，如果仍需要使用之前以创建好的迭代器，为了保险起见，一定要重新生成。</p>
</blockquote>
<h3 id="5-访问元素"><a href="#5-访问元素" class="headerlink" title="5. 访问元素"></a>5. 访问元素</h3><p>1) 和 array、vector 容器一样，可以采用普通数组访问存储元素的方式，访问 deque 容器中的元素，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改指定下标位置处的元素</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>容器名[n]</code>的这种方式，不仅可以访问容器中的元素，还可以对其进行修改。但需要注意的是，使用此方法需确保下标 n 的值不会超过容器中存储元素的个数，否则会发生越界访问的错误。</p>
<p>如果想有效地避免越界访问，可以使用 deque 模板类提供的 at() 成员函数，由于该函数会返回容器中指定位置处元素的引用形式，因此利用该函数的返回值，既可以访问指定位置处的元素，如果需要还可以对其进行修改。</p>
<p>不仅如此，at() 成员函数会自行判定访问位置是否越界，如果越界则抛出<code>std::out_of_range</code>异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    d.at(<span class="number">1</span>) = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这条语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; d.at(10) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可能会有这样一个疑问，即为什么 deque 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单：因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p>
</blockquote>
<p>2) 除此之外，deque 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回容器中第一个和最后一个元素的引用，通过利用它们的返回值，可以访问（甚至修改）容器中的首尾元素。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    deque&lt;int&gt; d&#123; 1,2,3,4,5 &#125;;</span><br><span class="line">    cout &lt;&lt; &quot;deque 首元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;deque 尾元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 修改首元素</span><br><span class="line">    d.front() &#x3D; 10;</span><br><span class="line">    cout &lt;&lt; &quot;deque 新的首元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 修改尾元素</span><br><span class="line">    d.back() &#x3D; 20;</span><br><span class="line">    cout &lt;&lt; &quot;deque 新的尾元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deque 首元素为：<span class="number">1</span></span><br><span class="line">deque 尾元素为：<span class="number">5</span></span><br><span class="line">deque 新的首元素为：<span class="number">10</span></span><br><span class="line">deque 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>3) 注意，和 vector 容器不同，deque 容器没有提供 data() 成员函数，同时 deque 容器在存储元素时，也无法保证其会将元素存储在连续的内存空间中，因此尝试使用指针去访问 deque 容器中指定位置处的元素，是非常危险的。</p>
<p>4) 另外，结合 deque 模板类中和迭代器相关的成员函数，可以实现遍历 deque 容器中指定区域元素的方法。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 从元素 2 开始遍历</span></span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历至 5 结束（不包括 5）</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = d.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="6-添加和删除元素"><a href="#6-添加和删除元素" class="headerlink" title="6. 添加和删除元素"></a>6. 添加和删除元素</h3><p>deque 容器中，无论是添加元素还是删除元素，都只能借助 deque 模板类提供的成员函数。下表中罗列的是所有和添加或删除容器内元素相关的 deque 模板类中的成员函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>push_back()</td>
<td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的一个元素。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>C++11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置。</td>
</tr>
<tr>
<td>emplace()</td>
<td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或某一区域内的多个元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器中所有的元素。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>在实际应用中，常用 emplace()、emplace_front() 和 emplace_back() 分别代替 insert()、push_front() 和 push_back()。</p>
</blockquote>
<p>以上这些成员函数中，除了 insert() 函数的语法格式比较多，其他函数都只有一种用法（erase() 有 2 种语法格式），下面这段程序演示了它们的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="comment">// 调用push_back()向容器尾部添加数据。</span></span><br><span class="line">    d.push_back(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 调用pop_back()移除容器尾部的一个数据。</span></span><br><span class="line">    d.pop_back(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 调用push_front()向容器头部添加数据。</span></span><br><span class="line">    d.push_front(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 调用pop_front()移除容器头部的一个数据。</span></span><br><span class="line">    d.pop_front(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 调用 emplace 系列函数，向容器中直接生成数据。</span></span><br><span class="line">    d.emplace_back(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    d.emplace_front(<span class="number">3</span>); <span class="comment">// &#123;3,2&#125;</span></span><br><span class="line">    <span class="comment">// emplace() 需要 2 个参数，第一个为指定插入位置的迭代器，第二个是插入的值。</span></span><br><span class="line">    d.emplace(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// &#123;3,4,2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// erase()可以接受一个迭代器表示要删除元素所在位置</span></span><br><span class="line">    <span class="comment">// 也可以接受 2 个迭代器，表示要删除元素所在的区域。</span></span><br><span class="line">    d.erase(d.<span class="built_in">begin</span>()); <span class="comment">// &#123;4,2&#125;</span></span><br><span class="line">    d.erase(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()); <span class="comment">// &#123;&#125;，等同于 d.clear()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>这里重点讲一下 insert() 函数的用法。insert() 函数的功能是在 deque 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody>
</table>
</div>
<p>下面的程序演示了 insert() 函数的这几种用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span></span><br></pre></td></tr></table></figure>
<h4 id="emplace系列函数的优势"><a href="#emplace系列函数的优势" class="headerlink" title="emplace系列函数的优势"></a>emplace系列函数的优势</h4><p>有关 emplace()、emplace_front() 和 emplace_back() 分别和 insert()、push_front() 和 push_back() 在运行效率上的对比，可以通过下面的程序体现出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// emplace和insert</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// emplace_front和push_front</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo3;</span><br><span class="line">    demo3.emplace_front(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo4;</span><br><span class="line">    demo4.push_front(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// emplace_back()和push_back()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo5;</span><br><span class="line">    demo5.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo6;</span><br><span class="line">    demo6.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace_front:</span><br><span class="line">调用构造函数</span><br><span class="line">push_front:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure>
<p>可以看到，相比和它同功能的函数，emplace 系列函数都只调用了构造函数，而没有调用移动构造函数，这无疑提高了代码的运行效率。</p>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：关联容器之set和multiset</title>
    <url>/2022/05/07/C-STL%EF%BC%9A%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bset%E5%92%8Cmultiset/</url>
    <content><![CDATA[<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前面介绍了 map 容器和 multimap 容器，类似地，C++ STL 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联容器。<a id="more"></a></p>
<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。举个例子，如下有 2 组键值对数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;&lt;<span class="string">'a'</span>, <span class="number">1</span>&gt;, &lt;<span class="string">'b'</span>, <span class="number">2</span>&gt;, &lt;<span class="string">'c'</span>, <span class="number">3</span>&gt;&#125;</span><br><span class="line">&#123;&lt;<span class="string">'a'</span>, <span class="string">'a'</span>&gt;, &lt;<span class="string">'b'</span>, <span class="string">'b'</span>&gt;, &lt;<span class="string">'c'</span>, <span class="string">'c'</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p>
<p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。</p>
<p>通过前面的学习我们知道，map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。</p>
<p>另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。</p>
<blockquote>
<p>对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</p>
</blockquote>
<p>set 容器定义于\<set>头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句：</set></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 set 容器时，需手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>set 容器的类模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt;,        // 指定 <span class="title">set</span> 容器内部的排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt;      // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。</p>
</blockquote>
<p>对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>下表列出了 set 容器提供的常用成员方法以及各自的功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="创建C-set容器的几种方法"><a href="#创建C-set容器的几种方法" class="headerlink" title="创建C++ set容器的几种方法"></a>创建C++ set容器的几种方法</h3><p>常见的创建 set 容器的方法，大致有以下 5 种。</p>
<p>1) 调用默认构造函数，创建空的 set 容器。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br></pre></td></tr></table></figure>
<p>由此就创建好了一个 set 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</p>
<p>2) 除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123;<span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/python/"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 <code>std::less&lt;T&gt;</code> 规则，因此其内部存储 string 元素的顺序如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure>
<p>3) set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。</p>
<p>例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure>
<p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p>
<p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> myset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure>
<p>注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。</p>
<blockquote>
<p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<p>4) 在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                    <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                    <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copyset</span><span class="params">(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure>
<p>5) 以上几种方式创建的 set 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt; &gt; myset&#123;</span><br><span class="line">    <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/python/"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>通过选用 std::greater\<string> 降序规则，myset 容器中元素的存储顺序为:</string></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>和 map 容器不同，C++ STL 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</p>
<p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 <code>++p、p++、--p、p--、*p</code> 操作，并且 2 个双向迭代器之间做比较，也只能使用 <code>==</code> 或者 <code>!=</code> 运算符。</p>
<p>在 set 容器类模板提供的所有成员函数中，返回迭代器的成员函数如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p>
</blockquote>
<p>1) 下面程序以 begin()/end() 为例，演示了如何使用相关迭代器遍历 set 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再次强调，正如程序第 15 行代码所示的那样，因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。</p>
</blockquote>
<p>2) 除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p>
<p>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                 <span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = myset.<span class="built_in">find</span>(<span class="string">"http://c.biancheng.net/python/"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;iter != myset.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</p>
</blockquote>
<h3 id="set-insert-方法详解"><a href="#set-insert-方法详解" class="headerlink" title="set insert()方法详解"></a>set insert()方法详解</h3><p>如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。为满足不同场景的需要，C++ 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p>
<p>1) 只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"><span class="comment">// 右值引用方式传参</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</span><br></pre></td></tr></table></figure>
<p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。</p>
<blockquote>
<p>以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式。</p>
</blockquote>
<p>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p>
<ul>
<li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li>
<li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">// 准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">// 采用普通引用传值方式</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    retpair = myset.insert(str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; retpair.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.insert(<span class="string">"http://c.biancheng.net/python/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; retpair.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">iter-&gt;http://c.biancheng.net/stl/ bool = 1</span><br><span class="line">iter-&gt;http://c.biancheng.net/python/ bool = 1</span><br></pre></td></tr></table></figure>
<p>通过观察输出结果不难看出，程序中两次借助 insert() 方法向 set 容器中添加元素，都成功了。</p>
<p>2) insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator <span class="built_in">position</span>, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p>
<ul>
<li>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</li>
<li>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">// 准备接受 insert() 的返回值</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">// 采用普通引用传值方式</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net/stl/"</span>;</span><br><span class="line">    iter = myset.insert(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size ="</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 采用右值引用传值方式</span></span><br><span class="line">    iter = myset.insert(myset.<span class="built_in">end</span>(),<span class="string">"http://c.biancheng.net/python/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size ="</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myset size =<span class="number">1</span></span><br><span class="line">myset size =<span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</p>
</blockquote>
<p>3) insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。insert() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">insert</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset&#123; <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                <span class="string">"http://c.biancheng.net/python/"</span>,</span><br><span class="line">                                <span class="string">"http://c.biancheng.net/java/"</span> &#125;;</span><br><span class="line">    <span class="comment">// 创建一个同类型的空 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; otherset;</span><br><span class="line">    <span class="comment">// 利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.insert(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p>
<p>4) 采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( &#123;E1, E2,...,En&#125; )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，Ei 表示新添加的元素。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">// 向 myset 中添加多个元素</span></span><br><span class="line">    myset.insert(&#123; <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">        <span class="string">"http://c.biancheng.net/python/"</span>,</span><br><span class="line">        <span class="string">"http://c.biancheng.net/java/"</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>以上即为 set 类模板中 insert() 成员方法的全部用法。另外，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。</p>
<h3 id="set-emplace-和emplace-hint-方法详解"><a href="#set-emplace-和emplace-hint-方法详解" class="headerlink" title="set emplace()和emplace_hint()方法详解"></a>set emplace()和emplace_hint()方法详解</h3><p>set 类模板提供的所有成员方法中，能实现向指定 set 容器中添加新元素的，只有 3 个成员方法，分别为 insert()、emplace() 和 emplace_hint()。其中 insert() 成员方法的用法已在上节做了详细的介绍，本节重点介绍剩下的这 2 个成员方法。</p>
<p>emplace() 和 emplace_hint() 是 C++ 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。</p>
<p>1) emplace() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">emplace</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>其中，参数 (Args&amp;&amp;… args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。</p>
<p>另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：</p>
<ul>
<li>当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；</li>
<li>当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。</li>
</ul>
<p>下面程序演示 emplace() 方法的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;myset;</span><br><span class="line">    <span class="comment">// 向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = myset.emplace(<span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;"</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myset size = <span class="number">1</span></span><br><span class="line">ret.iter = &lt;http://c.biancheng.net/stl/, <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>
<p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p>
<p>2) emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">iterator</span> <span class="title">emplace_hint</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>和 emplace() 方法相比，有以下 2 点不同：</p>
<ul>
<li>该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（新元素会添加到该迭代器指向元素的前面）；</li>
<li>返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。</li>
</ul>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;myset;</span><br><span class="line">    <span class="comment">// 在 set 容器的指定位置添加键值对</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = myset.emplace_hint(myset.<span class="built_in">begin</span>(), <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myset size = <span class="number">1</span></span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。</p>
<blockquote>
<p>以上内容介绍了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的。</p>
</blockquote>
<h3 id="set删除数据：erase-和clear-方法"><a href="#set删除数据：erase-和clear-方法" class="headerlink" title="set删除数据：erase()和clear()方法"></a>set删除数据：erase()和clear()方法</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p>
<p>1) set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// 删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="comment">// 删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。</p>
<blockquote>
<p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p>
</blockquote>
<p>下面程序演示了以上 3 种 erase() 方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="keyword">int</span> num = myset.erase(<span class="number">2</span>); <span class="comment">// 删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = myset.erase(myset.<span class="built_in">begin</span>()); <span class="comment">// 删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset.erase(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>()); <span class="comment">// 删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter2-&gt;"</span> &lt;&lt; *iter2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">myset size = <span class="number">5</span></span><br><span class="line"><span class="number">1</span>、myset size = <span class="number">4</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">iter-&gt;3</span><br><span class="line"><span class="number">3</span>、myset size = <span class="number">1</span></span><br><span class="line">iter2-&gt;5</span><br></pre></td></tr></table></figure>
<p>2) 如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然，该方法不需要传入任何参数，也没有任何返回值。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 清空 myset 容器</span></span><br><span class="line">    myset.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、myset size = <span class="number">5</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>前面对 set 容器做了详细的介绍。回忆一下，set 容器具有以下几个特性：</p>
<ul>
<li>不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；</li>
<li>set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；</li>
<li>存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；</li>
<li>set 容器存储的元素必须互不相等。</li>
</ul>
<p>在此基础上，C++ STL 标准库中还提供有一个和 set 容器相似的关联式容器，即 multiset 容器。所谓“相似”，是指 multiset 容器遵循 set 容器的前 3 个特性，仅在第 4 条特性上有差异。和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。</p>
<blockquote>
<p>也就是说，multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。</p>
</blockquote>
<p>和 set 类模板一样，multiset 类模板也定义在\<set>头文件，并位于 std 命名空间中。这意味着，如果想在程序中使用 multiset 容器，该程序代码应包含如下语句：</set></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，如果不用，则后续程序中在使用 multiset容器时，需手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>multiset 容器类模板的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt;,        // 指定容器内部的排序规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;T&gt; &gt;    // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">multiset</span>;</span></span><br></pre></td></tr></table></figure>
<p>显然，multiset 类模板有 3 个参数，其中后 2 个参数自带有默认值。值得一提的是，在实际使用中，我们最多只需要使用前 2 个参数即可，第 3 个参数不会用到。</p>
<h3 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h3><p>multiset 容器提供的成员方法，和 set 容器提供的完全一样，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 multiset 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 multiset 容器中第一个大于或等于 val 的元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 multiset 容器中第一个大于 val 的元素的迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含所有值为 val 的元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multiset 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multiset 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 multiset 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 multiset 容器中存储的指定元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>本质上和 emplace() 在 multiset 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 multiset 容器中，查找值为 val 的元素的个数，并返回。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。</p>
</blockquote>
<h3 id="创建C-multiset容器的方法"><a href="#创建C-multiset容器的方法" class="headerlink" title="创建C++ multiset容器的方法"></a>创建C++ multiset容器的方法</h3><p>创建 multiset 容器，无疑需要调用 multiset 类模板中的构造函数。值得一提的是，multiset 类模板提供的构造函数，和 set 类模板中提供创建 set 容器的构造函数，是完全相同的。这意味着，创建 set 容器的方式，也同样适用于创建 multiset 容器。</p>
<p>multiset 类模板中提供了 5 种构造函数，也就代表有 5 种创建 multiset 容器的方式，分别如下。</p>
<p>1) 调用默认构造函数，创建空的 multiset 容器。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultiset;</span><br></pre></td></tr></table></figure>
<p>由此就创建好了一个 mymultiset 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。</p>
<blockquote>
<p>注意，由于 multiset 容器支持随时向内部添加新的元素，因此创建空 multiset 容器的方法比较常用。</p>
</blockquote>
<p>2)除此之外，multiset 类模板还支持在创建 multiset 容器的同时，对其进行初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultiset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>由此即创建好了包含 3 个 string 元素的 mymultiset 容器。由于其采用默认的<code>std::less&lt;T&gt;</code>规则，因此其内部存储 string 元素的顺序如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure>
<p>3) multiset 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 multiset 容器的同时，将已有 multiset 容器中存储的所有元素全部复制到新 multiset 容器中。</p>
<p>例如，在第 2 种方式创建的 mymultiset 容器的基础上，执行如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copymultiset</span><span class="params">(mymultiset)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//std::multiset&lt;std::string&gt; copymultiset = mymultiset;</span></span><br></pre></td></tr></table></figure>
<p>该行代码在创建 copymultiset 容器的基础上，还会将 mymultiset 容器中存储的所有元素，全部复制给 copymultiset 容器一份。</p>
<p>另外，C++ 11 标准还为 multiset 类模板新增了移动构造函数，其功能是实现创建新 multiset 容器的同时，利用临时的 multiset 容器为其初始化。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; <span class="title">retMultiset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempmultiset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                            <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultiset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copymultiset</span><span class="params">(retMultiset())</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//std::multiset&lt;std::string&gt; copymultiset = retMultiset();</span></span><br></pre></td></tr></table></figure>
<p>注意，由于 retMultiset() 函数的返回值是一个临时 multiset 容器，因此在初始化 copymultiset 容器时，其内部调用的是 multiset 类模板中的移动构造函数，而非拷贝构造函数。</p>
<blockquote>
<p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<p>4) 在第 3 种方式的基础上，multiset 类模板还支持取已有 multiset 容器中的部分元素，来初始化新 multiset 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymultiset&#123; <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">                                       <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">copymultiset</span><span class="params">(++mymultiset.<span class="built_in">begin</span>(), mymultiset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br></pre></td></tr></table></figure>
<p>5) 以上几种方式创建的 multiset 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 multiset 类模板定义中的第 2 个参数，我们完全可以手动修改 multiset 容器中的排序规则。</p>
<p>下面样例中，使用了 STL 标准库提供的 std::greater\<T> 排序方法，作为 multiset 容器内部的排序规则：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt; &gt; mymultiset&#123;</span><br><span class="line">    <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/stl/"</span>,</span><br><span class="line">    <span class="string">"http://c.biancheng.net/python/"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>通过选用<code>std::greater&lt;string&gt;</code>降序规则，mymultiset 容器中元素的存储顺序为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://c.biancheng.net/stl/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/python/"</span></span><br><span class="line"><span class="string">"http://c.biancheng.net/java/"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：顺序容器之forward_list</title>
    <url>/2022/05/03/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bforward-list/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>forward_list 是 C++ 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表。<a id="more"></a>如下图所示：</p>
<p><img src="/2022/05/03/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bforward-list/1-1.gif" alt></p>
<p>上图中，H 表示链表的表头。a) 表示单链表，b) 表示双向链表。不难看出，使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过指针来维持。因此，forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。</p>
<p>另外，由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p>
<p>那么，既然 forward_list 容器具有和 list 容器相同的特性，list 容器还可以提供更多的功能函数，forward_list 容器有什么存在的必要呢？当然有，forward_list 容器底层使用单链表，也不是一无是处。比如，存储相同个数的同类型元素，单链表耗用的内存空间更少，空间利用率更高，并且对于实现某些操作单链表的执行效率也更高。</p>
<blockquote>
<p>效率高是选用 forward_list 而弃用 list 容器最主要的原因，换句话说，只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。</p>
</blockquote>
<h3 id="2-成员函数"><a href="#2-成员函数" class="headerlink" title="2. 成员函数"></a>2. 成员函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>before_begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td>
</tr>
<tr>
<td>begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td>
</tr>
<tr>
<td>end()</td>
<td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，比如 2^32-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td>
</tr>
<tr>
<td>erase_after()</td>
<td>删除容器中某个指定位置或区域内的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice_after()</td>
<td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>forward_list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<p>下面的样例演示了部分成员函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.emplace_front(<span class="number">4</span>); <span class="comment">// &#123;4,1,2,3&#125;</span></span><br><span class="line">    values.emplace_after(values.before_begin(), <span class="number">5</span>); <span class="comment">// &#123;5,4,1,2,3&#125;</span></span><br><span class="line">    values.reverse(); <span class="comment">// &#123;3,2,1,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="和使用forward-list容器相关的函数"><a href="#和使用forward-list容器相关的函数" class="headerlink" title="和使用forward_list容器相关的函数"></a>和使用forward_list容器相关的函数</h4><p>我们知道，forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 \<iterator> 中的 distance() 函数。举个例子：</iterator></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="built_in">std</span>::distance(<span class="built_in">std</span>::<span class="built_in">begin</span>(my_words), <span class="built_in">std</span>::<span class="built_in">end</span>(my_words));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>并且，forward_list 容器迭代器的移动除了使用 <code>++</code> 运算符单步移动，还能使用 advance() 函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.<span class="built_in">begin</span>();</span><br><span class="line">    advance(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-forward-list-容器的创建"><a href="#3-forward-list-容器的创建" class="headerlink" title="3. forward_list 容器的创建"></a>3. forward_list 容器的创建</h3><p>由于 forward_list 容器以模板类 forward_list\<T>（T 为存储元素的类型）的形式被包含在 <forward_list> 头文件中，并定义在 std 命名空间中。因此，在使用该容器之前，代码中需包含下面两行代码：</forward_list></T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>std 命名空间也可以在使用 forward_list 容器时额外注明，两种方式都可以。</p>
</blockquote>
<p>创建 forward_list 容器的方式，大致分为以下 5 种。</p>
<p>1) 创建一个没有任何元素的空 forward_list 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values;</span><br></pre></td></tr></table></figure>
<p>由于 forward_list 容器在创建后也可以添加元素，因此这种创建方式很常见。</p>
<p>2) 创建一个包含 n 个元素的 forward_list 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int类型的默认值为 0）。</p>
<p>3) 创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如此就创建了一个包含 10 个元素并且值都为 5 的 values 容器。</p>
<p>4) 在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<p>5) 通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 forward_list 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建forward_list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 拷贝其它类型的容器，创建forward_list容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(arr.<span class="built_in">begin</span>()+<span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：顺序容器之list</title>
    <url>/2022/05/02/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>STL list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。<a id="more"></a>下图展示了 list 双向链表容器是如何存储元素的：</p>
<p><img src="/2022/05/02/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Blist/pic1.jpg" alt></p>
<p>可以看到，list 容器中各个元素的前后顺序是靠指针来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p>
<p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为O(1)），并且在 list 容器中移动元素，也比其它容器的效率高。</p>
<p>使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持<code>容器对象名[6]</code>这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p>
<blockquote>
<p>实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</p>
</blockquote>
<p>list 容器以模板类 list\<T>（T 为存储元素的类型）的形式在\<list>头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</list></T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h3 id="2-成员函数"><a href="#2-成员函数" class="headerlink" title="2. 成员函数"></a>2. 成员函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器实际包含的元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在容器尾部插入一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert()</td>
<td>在容器中的指定位置插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除容器中一个或某区域内的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice()</td>
<td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<h3 id="3-list容器的创建"><a href="#3-list容器的创建" class="headerlink" title="3. list容器的创建"></a>3. list容器的创建</h3><p>根据不同的使用场景，有以下 5 种创建 list 容器的方式供选择。</p>
<p>1) 创建一个没有任何元素的空 list 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values;</span><br></pre></td></tr></table></figure>
<p>和空 array 容器不同，空的 list 容器在创建之后仍可以添加元素，因此创建 list 容器的方式很常用。</p>
<p>2) 创建一个包含 n 个元素的 list 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建 values 容器，其中包含 10 个元素，每个元素的值都为相应类型的默认值（int 类型的默认值为 0）。</p>
<p>3) 创建一个包含 n 个元素的 list 容器，并为每个元素指定初始值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如此就创建了一个包含 10 个元素并且值都为 5 的 values 容器。</p>
<p>4) 在已有 list 容器的情况下，通过拷贝该容器可以创建新的 list 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<p>5) 通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 list 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 拷贝其它类型的容器，创建 list 容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">alues</span><span class="params">(arr.<span class="built_in">begin</span>()+<span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>;	<span class="comment">// 拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h3><p>只有运用迭代器，才能访问 list 容器中存储的各个元素。list 模板类提供了如下表所示的这些迭代器函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>迭代器函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器（正向迭代器）。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。（正向迭代器）。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，正向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，正向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，反向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，反向迭代器增加了 const 属性，即不能用于修改元素。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 list 容器。即当操作对象为 list 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p>
<p>这些成员函数通常是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p>
<p>前面章节已经详细介绍了 array、vector、deque 容器的迭代器，和它们相比，list 容器迭代器最大的不同在于，其配备的迭代器类型为双向迭代器，而不再是随机访问迭代器。这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 <code>++p1</code>、 <code>p1++</code>、 <code>p1--</code>、 <code>p1++</code>、 <code>*p1</code>、 <code>p1==p2</code> 以及 <code>p1!=p2</code> 运算符，但不支持以下操作（其中 i 为整数）：</p>
<ul>
<li><code>p1[i]</code>：不能通过下标访问 list 容器中指定位置处的元素。</li>
<li><code>p1-=i</code>、<code>p1+=i</code>、<code>p1+i</code>、<code>p1-i</code>：双向迭代器 p1 不支持使用 <code>-=、+=、+、-</code> 运算符。</li>
<li><code>p1&lt;p2</code>、<code>p1&gt;p2</code>、<code>p1&lt;=p2</code>、<code>p1&gt;=p2</code>：双向迭代器 p1、p2 不支持使用 <code>&lt;、 &gt;、 &lt;=、 &gt;=</code> 比较运算符。</li>
</ul>
<p>下面这个程序演示了如何使用迭代器遍历 list 容器中的各个元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>,<span class="string">':'</span>,<span class="string">'/'</span>,<span class="string">'/'</span>,<span class="string">'c'</span>,<span class="string">'.'</span>,<span class="string">'b'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'c'</span>,<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'n'</span>,<span class="string">'g'</span>,<span class="string">'.'</span>,<span class="string">'n'</span>,<span class="string">'e'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用begin()/end()迭代器函数对输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用 rbegin()/rend()迭代器函数输出 lsit 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::reverse_iterator it = values.rbegin(); it != values.rend();++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net</span><br><span class="line">ten.gnehcnaib.c//:ptth</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，程序中比较迭代器之间的关系，用的是 != 运算符，因为它不支持 &lt; 等运算符。另外在实际场景中，所有迭代器函数的返回值都可以传给使用 auto 关键字定义的变量，因为编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<p>值得一提的是，list 容器在进行插入（insert()）、接合（splice()）等操作时，都不会造成原有的 list 迭代器失效，甚至进行删除操作，而只有指向被删除元素的迭代器失效，其他迭代器不受任何影响。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>,<span class="string">':'</span>,<span class="string">'/'</span>,<span class="string">'/'</span>,<span class="string">'c'</span>,<span class="string">'.'</span>,<span class="string">'b'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'c'</span>,<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'n'</span>,<span class="string">'g'</span>,<span class="string">'.'</span>,<span class="string">'n'</span>,<span class="string">'e'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line">    <span class="comment">// 创建 begin 和 end 迭代器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator <span class="built_in">begin</span> = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 头部和尾部插入字符 '1'</span></span><br><span class="line">    values.insert(<span class="built_in">begin</span>, <span class="string">'1'</span>);</span><br><span class="line">    values.insert(<span class="built_in">end</span>, <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span>;</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net1</span><br></pre></td></tr></table></figure>
<p>可以看到，在进行插入操作之后，仍使用先前创建的迭代器遍历容器，虽然程序不会出错，但由于插入位置的不同，可能会遗漏新插入的元素。</p>
<h3 id="5-访问元素"><a href="#5-访问元素" class="headerlink" title="5. 访问元素"></a>5. 访问元素</h3><p>不同于之前学过的 STL 容器，访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。</p>
<blockquote>
<p>list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。</p>
</blockquote>
<p>1) 通过 front() 和 back() 成员函数，可以分别获得 list 容器中第一个元素和最后一个元素的引用形式。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> &amp;first = mylist.front();</span><br><span class="line">    <span class="keyword">int</span> &amp;last = mylist.back();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="string">" "</span> &lt;&lt; last &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    first = <span class="number">10</span>;</span><br><span class="line">    last = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mylist.front() &lt;&lt; <span class="string">" "</span> &lt;&lt; mylist.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过 front() 和 back() 的返回值，我们不仅能分别获取当前 list 容器中的首尾元素，必要时还能修改它们的值。</p>
<p>2) 除此之外，如果想访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">while</span> (it!=mylist.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++it;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>值得一提的是，对于非 const 类型的 list 容器，迭代器不仅可以访问容器中的元素，也可以对指定元素的值进行修改。</p>
<blockquote>
<p>当然，对于修改容器指定元素的值，list 模板类提供有专门的成员函数 assign()。</p>
</blockquote>
<h3 id="6-添加-插入元素"><a href="#6-添加-插入元素" class="headerlink" title="6. 添加/插入元素"></a>6. 添加/插入元素</h3><p>list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：</p>
<ul>
<li>push_front()：向 list 容器首个元素前添加新元素；</li>
<li>push_back()：向 list 容器最后一个元素后添加新元素；</li>
<li>emplace_front()：在容器首个元素前直接生成新的元素；</li>
<li>emplace_back()：在容器最后一个元素后直接生成新的元素；</li>
<li>emplace()：在容器的指定位置直接生成新的元素；</li>
<li>insert()：在指定位置插入新元素；</li>
<li>splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。</li>
</ul>
<p>以上这些成员方法中，除了 insert() 和 splice() 方法有多种语法格式外，其它成员方法都仅有 1 种语法格式。下面程序演示了它们的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.push_front(<span class="number">0</span>);<span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line">    values.push_back(<span class="number">4</span>); <span class="comment">//&#123;0,1,2,3,4&#125;</span></span><br><span class="line">    values.emplace_front(<span class="number">-1</span>);<span class="comment">//&#123;-1,0,1,2,3,4&#125;</span></span><br><span class="line">    values.emplace_back(<span class="number">5</span>);  <span class="comment">//&#123;-1,0,1,2,3,4,5&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// emplace(pos,value),其中 pos 表示指明位置的迭代器，value为要插入的元素值</span></span><br><span class="line">    values.emplace(values.<span class="built_in">end</span>(), <span class="number">6</span>);<span class="comment">//&#123;-1,0,1,2,3,4,5,6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="list-insert-成员方法"><a href="#list-insert-成员方法" class="headerlink" title="list insert()成员方法"></a>list insert()成员方法</h4><p>insert() 成员方法的语法格式有 4 种，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（例如 array、vector、deque 等）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 { } 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody>
</table>
</div>
<p>下面的程序演示了如何使用 insert() 方法向 list 容器中插入元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    values.insert(values.<span class="built_in">begin</span>() , <span class="number">3</span>); <span class="comment">// &#123;3,1,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    values.insert(values.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;3,1,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    values.insert(values.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;3,1,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    values.insert(values.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;3,1,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>同样是实现插入元素的功能，无论是 push_front()、push_back() 还是 insert()，都有以 emplace 为名且功能和前者相同的成员函数。这是因为，后者是 C++ 11 标准新添加的，在大多数场景中，都可以完全替代前者实现同样的功能。更重要的是，实现同样的功能，emplace 系列方法的执行效率更高。</p>
<h4 id="list-splice-成员方法"><a href="#list-splice-成员方法" class="headerlink" title="list splice()成员方法"></a>list splice()成员方法</h4><p>和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。</p>
<p>splice() 成员方法的语法格式有 3 种，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>void splice (iterator position, list&amp; x);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator i);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td>
</tr>
</tbody>
</table>
</div>
<p>我们知道，list 容器底层使用的是链表存储结构，splice() 成员方法移动元素的方式是，将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中。这意味着，当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除。</p>
<p>下面程序演示了 splice() 成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 2 个 list 容器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ++mylist1.<span class="built_in">begin</span>(); <span class="comment">// 指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用第一种语法格式</span></span><br><span class="line">    mylist1.splice(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">// 调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.splice(mylist2.<span class="built_in">begin</span>(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.splice(mylist2.<span class="built_in">begin</span>(), mylist1, mylist1.<span class="built_in">begin</span>(), mylist1.<span class="built_in">end</span>()); <span class="comment">// mylist1:</span></span><br><span class="line">                                                                              <span class="comment">// mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1 包含 "</span> &lt;&lt; mylist1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"个元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2 包含 "</span> &lt;&lt; mylist2.<span class="built_in">size</span>() &lt;&lt; <span class="string">"个元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 mylist2 容器中存储的数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.<span class="built_in">begin</span>(); iter != mylist2.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist1 包含 <span class="number">0</span>个元素</span><br><span class="line">mylist2 包含 <span class="number">7</span>个元素</span><br><span class="line">mylist2:<span class="number">1</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="7-删除元素"><a href="#7-删除元素" class="headerlink" title="7. 删除元素"></a>7. 删除元素</h3><p>对 list 容器存储的元素执行删除操作，需要借助该容器模板类提供的成员函数。幸运的是，相比其它 STL 容器模板类，list 模板类提供了更多用来实现此操作的成员函数，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pop_front()</td>
<td>删除位于 list 容器头部的一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除位于 list 容器尾部的一个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除 list 容器存储的所有元素。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一份。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
</tbody>
</table>
</div>
<p>1) 其中，pop_front()、pop_back() 和 clear() 的用法非常简单，这里仅给出一个样例，不再过多解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 删除当前容器中首个元素</span></span><br><span class="line">    values.pop_front();<span class="comment">//&#123;2,3,4&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 删除当前容器最后一个元素</span></span><br><span class="line">    values.pop_back();<span class="comment">//&#123;2,3&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 清空容器，删除容器中所有的元素</span></span><br><span class="line">    values.<span class="built_in">clear</span>(); <span class="comment">//&#123;&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，可以看到输出结果为“空”。</p>
<p>2) erase() 成员函数有以下 2 种语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>利用第一种语法格式，可实现删除 list 容器中 position 迭代器所指位置处的元素，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 指向元素 1 的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> del = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 迭代器右移，改为指向元素 2</span></span><br><span class="line">    ++del;</span><br><span class="line">    values.erase(del); <span class="comment">// &#123;1,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>利用第二种语法格式，可实现删除 list 容器中 first 迭代器和 last 迭代器限定区域内的所有元素（包括 first 指向的元素，但不包括 last 指向的元素）。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 指定删除区域的左边界</span></span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    ++first; <span class="comment">// 指向元素 2</span></span><br><span class="line">    <span class="comment">// 指向删除区域的右边界</span></span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    --last; <span class="comment">// 指向元素 5</span></span><br><span class="line">    <span class="comment">// 删除 2、3 和 4</span></span><br><span class="line">    values.erase(first, last);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>3) erase() 成员函数是按照被删除元素所在的位置来执行删除操作，如果想根据元素的值来执行删除操作，可以使用 remove() 成员函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125;;</span><br><span class="line">    values.<span class="built_in">remove</span>(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="built_in">begin</span> = values.<span class="built_in">begin</span>(); <span class="built_in">begin</span> != values.<span class="built_in">end</span>(); ++<span class="built_in">begin</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *<span class="built_in">begin</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a b d</span><br></pre></td></tr></table></figure>
<p>4) unique() 函数也有以下 2 种语法格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span></span><br><span class="line">void unique（BinaryPredicate）// 传入一个二元谓词函数</span><br></pre></td></tr></table></figure>
<p>以上 2 种格式都能实现去除 list 容器中相邻重复的元素，仅保留一份。但第 2 种格式的优势在于，我们能自定义去重的规则，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">demo</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>(first) == <span class="keyword">int</span>(second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4.5</span>,<span class="number">4.6</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除相邻重复的元素，仅保留一份</span></span><br><span class="line">    mylist.unique(); <span class="comment">// &#123;1, 1.2, 3, 4, 4.5, 4.6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// demo 为二元谓词函数，是我们自定义的去重规则</span></span><br><span class="line">    mylist.unique(demo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1.2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4.5</span> <span class="number">4.6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，除了以上一定谓词函数的方式，还可以使用 lamba表达式以及函数对象的方式定义。</p>
</blockquote>
<p>可以看到，通过调用无参的 unique()，仅能删除相邻重复（也就是相等）的元素，而通过我们自定义去重的规则，可以更好的满足在不同场景下去重的需求。</p>
<p>5) 除此之外，通过将自定义的谓词函数（不限定参数个数）传给 remove_if() 成员函数，list 容器中能使谓词函数成立的元素都会被删除。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">15</span>, <span class="number">36</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除 mylist 容器中能够使 lamba 表达式成立的所有元素。</span></span><br><span class="line">    mylist.remove_if([](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> (value &lt; <span class="number">10</span>); &#125;); <span class="comment">// &#123;15 36 17 20 39&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">36</span> <span class="number">17</span> <span class="number">20</span> <span class="number">39</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：顺序容器之vector</title>
    <url>/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。<a id="more"></a></p>
<p>vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为O(1)；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶O(n)。</p>
<p>vector 容器以类模板 vector\<T>（ T 表示存储元素的类型）的形式定义在 \<vector> 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：</vector></T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-成员函数"><a href="#2-成员函数" class="headerlink" title="2. 成员函数"></a>2. 成员函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，比如 2^32-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>reserve()</td>
<td>增加容器的容量。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>operator[ ]</td>
<td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的指针。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 vector 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>vector 容器还有一个 std::swap(x , y) 非成员函数（其中 x 和 y 是存储相同类型元素的  vector 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<h3 id="3-创建-vector-容器的几种方式"><a href="#3-创建-vector-容器的几种方式" class="headerlink" title="3. 创建 vector 容器的几种方式"></a>3. 创建 vector 容器的几种方式</h3><p>创建 vector 容器的方式有很多，大致可分为以下几种。</p>
<p>1) 如下代码展示了如何创建存储 double 类型元素的一个 vector 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure>
<p>注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。</p>
<p>在创建好空容器的基础上，还可以像下面这样通过调用 reserve() 成员函数来增加容器的容量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values.reserve(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素。</p>
<blockquote>
<p>还需注意的是，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector\<T> 容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。</T></p>
</blockquote>
<p>2) 除了创建空 vector 容器外，还可以在创建的同时指定初始值以及元素个数，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就创建了一个含有 8 个素数的 vector 容器。</p>
<p>3) 在创建 vector 容器时，也可以指定元素个数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如此，values 容器开始时就有 20 个元素，它们的默认初始值都为 0。</p>
<blockquote>
<p>注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。</p>
</blockquote>
<p>如果不想用 0 作为默认值，也可以指定一个其它值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。</p>
<p>值得一提的是，圆括号 () 中的 2 个参数，既可以是常量，也可以用变量来表示，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>4) 通过存储元素类型相同的其它 vector 容器，也可以创建新的 vector 容器，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">5</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此，value2 容器中也具有 5 个字符 ‘c’。在此基础上，如果不想复制其它容器中所有的元素，可以用一对指针或者迭代器来指定初始值的范围，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>)</span></span>; <span class="comment">// values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">begin</span>(value1),<span class="built_in">std</span>::<span class="built_in">begin</span>(value1)+<span class="number">3</span>)</span></span>; <span class="comment">// value2 将保存&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h3><p>vector 支持迭代器的成员函数和功能如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 vector 容器。即当操作对象为 vector 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p>
<p>这些成员函数的具体功能如下图所示：</p>
<p><img src="/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/pic1.jpg" alt></p>
<p>从上图可以看出，这些成员函数通常是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p>
<blockquote>
<p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p>
</blockquote>
<h4 id="vector容器迭代器的基本用法"><a href="#vector容器迭代器的基本用法" class="headerlink" title="vector容器迭代器的基本用法"></a>vector容器迭代器的基本用法</h4><p>vector 容器迭代器最常用的功能就是遍历访问容器中存储的元素。</p>
<p>1) 首先来看 begin() 和 end() 成员函数，它们分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 vector 容器并输出其中的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，迭代器对象是由 vector 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样使用它们。比如代码中，在保存了元素值后，使用前缀<code>++</code>运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p>
<p>当然，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，比如将上面代码中第 7、8 行代码用如下代码替换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure>
<p>2) cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。比如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.cend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*first = 10;不能修改元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序第 12 行，由于 first 是 const 类型的迭代器，因此不能用于修改容器中元素的值。</p>
<p>3) vector 模板类中还提供了 rbegin() 和 rend() 成员函数，分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。也就是说，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p>
<p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.rend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：5 4 3 2 1</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，从最后一个元素开始循环，遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p>
<p>当然，在上面程序中，我们也可以使用 for 循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4) crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p>
<h4 id="vector容器迭代器的独特之处"><a href="#vector容器迭代器的独特之处" class="headerlink" title="vector容器迭代器的独特之处"></a>vector容器迭代器的独特之处</h4><p>和 array 容器不同，vector 容器可以随着存储元素的增加，自行申请更多的存储空间。因此，在创建 vector 对象时，我们可以直接创建一个空的 vector 容器，并不会影响后续使用该容器。</p>
<p>但这会产生一个问题，即在初始化空的 vector 容器时，不能使用迭代器。也就是说，如下初始化 vector 容器的方法是不行的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="comment">// 初始化的同时输出值</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序可以看到，什么也没有输出。这是因为，对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。</p>
<blockquote>
<p>所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。</p>
</blockquote>
<p>除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，显示如下信息并崩溃：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0096</span>DFE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">00965560</span></span><br></pre></td></tr></table></figure>
<p>可以看到，values 容器在增加容量之后，首个元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的。因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0164</span>DBE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">01645560</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="5-访问元素"><a href="#5-访问元素" class="headerlink" title="5. 访问元素"></a>5. 访问元素</h3><h4 id="5-1-访问vector容器中单个元素"><a href="#5-1-访问vector容器中单个元素" class="headerlink" title="5.1 访问vector容器中单个元素"></a>5.1 访问vector容器中单个元素</h4><p>1) 首先，vector 容器可以向普通数组那样访问存储的元素，甚至对指定下标处的元素进行修改，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values[<span class="number">0</span>] = values[<span class="number">1</span>] + values[<span class="number">2</span>] + values[<span class="number">3</span>] + values[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>显然，vector 的索引从 0 开始，这和普通数组一样。通过使用索引，总是可以访问到 vector 容器中现有的元素。</p>
<p>值得一提的是，<code>容器名[n]</code>这种获取元素的方式，需要确保下标 n 的值不会超过容器的容量（可以通过 capacity() 成员函数获取），否则会发生越界访问的错误。幸运的是，和 array 容器一样，vector 容器也提供了 at() 成员函数，当传给 at() 的索引会造成越界时，会抛出<code>std::out_of_range</code>异常。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values.at(<span class="number">0</span>) = values.at(<span class="number">1</span>) + values.at(<span class="number">2</span>) + values.at(<span class="number">3</span>) + values.at(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这条语句会发生 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; values.at(5) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可能会有这样一个疑问，即为什么 vector 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单：因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p>
</blockquote>
<p>2) 除此之外，vector 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改首元素</span></span><br><span class="line">    values.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改尾元素</span></span><br><span class="line">    values.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values 首元素为：<span class="number">1</span></span><br><span class="line">values 尾元素为：<span class="number">5</span></span><br><span class="line">values 新的首元素为：<span class="number">10</span></span><br><span class="line">values 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>3) 另外，vector 容器还提供了 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 输出容器中第 3 个元素的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中第 2 个元素的值</span></span><br><span class="line">    *(values.data() + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-访问vector容器中多个元素"><a href="#5-2-访问vector容器中多个元素" class="headerlink" title="5.2 访问vector容器中多个元素"></a>5.2 访问vector容器中多个元素</h4><p>如果想访问 vector 容器中多个元素，可以借助 size() 成员函数，该函数可以返回 vector 容器中实际存储的元素个数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里不要使用 capacity() 成员函数，因为它返回的是 vector 容器的容量，而不是实际存储元素的个数，这两者是有差别的。</p>
<p>或者也可以使用基于范围的循环，此方式将会逐个遍历容器中的元素。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以使用 vector 迭代器遍历 vector 容器，这里以 begin()/end() 为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这里也可以使用 rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 以及全局函数 begin()/end() ，它们都可以实现对容器中元素的访问。</p>
<h3 id="6-添加元素"><a href="#6-添加元素" class="headerlink" title="6. 添加元素"></a>6. 添加元素</h3><h4 id="6-1-push-back"><a href="#6-1-push-back" class="headerlink" title="6.1 push_back()"></a>6.1 push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中，第 7 行代码表示向 values 容器尾部添加一个元素，但由于当前 values 容器是空的，因此新添加的元素 1 无疑成为了容器中首个元素；第 8 行代码实现的功能是在现有元素 1 的后面，添加元素 2。</p>
<p>运行程序，输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="6-2-emplace-back"><a href="#6-2-emplace-back" class="headerlink" title="6.2 emplace_back()"></a>6.2 emplace_back()</h4><p>该函数是 C++ 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。emplace_back() 成员函数的用法也很简单，这里直接举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.emplace_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们可能会发现，以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？</p>
<h4 id="6-3-emplace-back-和push-back-的区别"><a href="#6-3-emplace-back-和push-back-的区别" class="headerlink" title="6.3 emplace_back()和push_back()的区别"></a>6.3 emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
<p>为了清楚的了解它们之间的区别，创建一个包含类对象的 vector 容器，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace_back(<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.push_back(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure>
<p>在此基础上，我们可以尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p>
<p>显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议优先选用 emplace_back()。</p>
<blockquote>
<p>注意：由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</p>
</blockquote>
<h3 id="7-插入元素"><a href="#7-插入元素" class="headerlink" title="7. 插入元素"></a>7. 插入元素</h3><h4 id="7-1-insert"><a href="#7-1-insert" class="headerlink" title="7.1 insert()"></a>7.1 insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody>
</table>
</div>
<p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>
<h4 id="7-2-emplace"><a href="#7-2-emplace" class="headerlink" title="7.2 emplace()"></a>7.2 emplace()</h4><p>emplace() 是 C++ 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p>
<blockquote>
<p>强调：emplace() 每次只能插入一个元素，而不是多个。</p>
</blockquote>
<p>该函数的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator pos, args...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p>
<p>简单的理解 args…，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是：emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), testDemo(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</p>
</blockquote>
<p>可以看到，通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。</p>
<p>简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐优先使用 emplace()。</p>
<h3 id="8-删除元素"><a href="#8-删除元素" class="headerlink" title="8. 删除元素"></a>8. 删除元素</h3><p>前面提到，无论是向现有 vector 容器中访问元素、添加元素还是插入元素，都只能借助 vector 模板类提供的成员函数，但删除 vector 容器的元素例外，完成此操作除了可以借助本身提供的成员函数，还可以借助一些全局函数。</p>
<p>基于不同场景的需要，删除 vecotr 容器的元素，可以使用下表中所示的函数（或者函数组合）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pop_back()</td>
<td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td>
</tr>
<tr>
<td>erase(pos)</td>
<td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td>
</tr>
<tr>
<td>swap(beg)、pop_back()</td>
<td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td>
</tr>
<tr>
<td>erase(beg,end)</td>
<td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td>
</tr>
<tr>
<td>remove()</td>
<td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td>
</tr>
</tbody>
</table>
</div>
<p>1) pop_back() 成员函数的用法非常简单，它不需要传入任何的参数，也没有返回值。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="comment">// 输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>可以发现，相比原 demo 容器，新的 demo 容器删除了最后一个元素 5，容器的大小减了 1，但容量没变。</p>
<p>2) 如果想删除 vector 容器中指定位置处的元素，可以使用 erase() 成员函数，该函数的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(pos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，pos 为指定被删除元素位置的迭代器，同时该函数会返回一个指向删除元素所在位置下一个位置的迭代器。</p>
<p>下面的例子演示了 erase() 函数的具体用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除元素 2</span></span><br><span class="line">    <span class="comment">// 输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// iter迭代器指向元素 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>通过结果不能看出，erase() 函数在删除元素时，会将删除位置后续的元素陆续前移，并将容器的大小减 1。</p>
<p>3) 另外，如果不在意容器中元素的排列顺序，可以结合 swap() 和 pop_back() 函数，同样可以实现删除容器中指定位置元素的目的。</p>
<blockquote>
<p>注意，swap() 函数在头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;utility&gt;</code> 中都有定义，使用时引入其中一个即可。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    swap(*(<span class="built_in">std</span>::<span class="built_in">begin</span>(demo)+<span class="number">1</span>),*(<span class="built_in">std</span>::<span class="built_in">end</span>(demo)<span class="number">-1</span>));<span class="comment">//等同于 swap(demo[1],demo[4])</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 交换位置后的demo容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出demo 容器中剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>4) 当然，除了删除容器中单个元素，还可以删除容器中某个指定区域内的所有元素，同样可以使用 erase() 成员函数实现。该函数有 2 种基本格式，前面介绍了一种，这里使用另一种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 是指定被删除元素区域的迭代器，同时该函数会返回指向此区域之后一个位置的迭代器。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>可以看到，和删除单个元素一样，删除指定区域内的元素时，也会将该区域后续的元素前移，并缩小容器的大小。</p>
<p>5) 如果要删除容器中和指定元素值相同的所有元素，可以使用 remove() 函数，该函数定义在 <code>&lt;algorithm&gt;</code> 头文件中。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = demo.<span class="built_in">begin</span>(); first &lt; iter;++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>注意，在对容器执行完 remove() 函数之后，由于该函数并没有改变容器原来的大小和容量，因此无法使用之前的方法遍历容器，而是需要向程序中那样，借助 remove() 返回的迭代器完成正确的遍历。</p>
<blockquote>
<p>remove() 的实现原理是，在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，直到找到一个非目标元素，即用此元素将最先做标记的位置覆盖掉，同时将此非目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。因此，如果将上面程序中 demo 容器的元素全部输出，得到的结果为 <code>1 4 5 4 3 5</code>。</p>
</blockquote>
<p>另外还可以看到，既然通过 remove() 函数删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以使用 erase() 成员函数删掉这些 “无用” 的元素。</p>
<p>比如，修改上面的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    demo.erase(iter, demo.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用。</p>
</blockquote>
<p>6) 如果想删除容器中所有的元素，则可以使用 clear() 成员函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">0</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：引用计数</title>
    <url>/2022/01/11/C-%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="什么是引用计数"><a href="#什么是引用计数" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h3><p>引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：</p>
<ul>
<li><p>简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。</p>
</li>
<li><p>节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中<strong>string</strong>类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。<a id="more"></a></p>
</li>
</ul>
<h3 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h3><p>使用引用计数实现智能指针的关键是，引用计数应该存在哪里。引用计数应该是某个类对象和其复制对象共享的， 而指针成员恰好有这样的特性， 故可以在类中多声明一个size_t* 的成员，用来表示引用计数。</p>
<ul>
<li>构造函数中创建类的新对象时，初始化引用计数为1；</li>
<li>拷贝构造函数复制指针，并使相应的引用计数增加1；</li>
<li>赋值操作减少左操作数所指对象的引用计数，增加右操作数所指对象的引用计数；</li>
<li>析构函数使引用计数减少1，并且当引用计数为1时，释放指针所指向的对象；</li>
</ul>
<p><img src="/2022/01/11/C-%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/引用计数.png" alt></p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>; <span class="keyword">using</span> <span class="built_in">std</span>::ostream; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// string()：构造空的string类对象，既空字符串</span></span><br><span class="line">	HasPtr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125; <span class="comment">// constructor</span></span><br><span class="line">	~HasPtr(); <span class="comment">// 析构函数</span></span><br><span class="line">	HasPtr(<span class="keyword">const</span> HasPtr&amp; rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++* use; &#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;); <span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span>* ps; <span class="comment">// ps是一个指针，指向string类型</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">size_t</span>* use; <span class="comment">// use是一个指针，指向size_t类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数的定义</span></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;	<span class="comment">// 如果引用计数为变0</span></span><br><span class="line">		<span class="keyword">delete</span> ps;			<span class="comment">// 释放string内存</span></span><br><span class="line">		<span class="keyword">delete</span> use;			<span class="comment">// 释放计数器内存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载的定义</span></span><br><span class="line">HasPtr&amp;</span><br><span class="line">HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	++* rhs.use;			<span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;	<span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line">		<span class="keyword">delete</span> ps;			<span class="comment">// 如果没有其他用户</span></span><br><span class="line">		<span class="keyword">delete</span> use;			<span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;			<span class="comment">// 将数据从rhs拷贝到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;			<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的定义</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.use;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HasPtr temp;</span><br><span class="line">	temp = p;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, p) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"temp: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, temp) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr str1(\"copy me\"), str2;\n"</span>;</span><br><span class="line">	HasPtr str1("copy me"), str2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr2 = str1;\n"</span>;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nfunc(str1);\n"</span>;</span><br><span class="line">	func(str1);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr1: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HasPtr str1(<span class="string">"copy me"</span>), str2;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">1</span></span><br><span class="line">str2: <span class="number">011654E8</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">str2 = str1;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line"></span><br><span class="line">func(str1);</span><br><span class="line">p: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line">temp: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line"></span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：深拷贝和浅拷贝</title>
    <url>/2023/01/05/C-%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="1-什么是浅拷贝和深拷贝"><a href="#1-什么是浅拷贝和深拷贝" class="headerlink" title="1. 什么是浅拷贝和深拷贝"></a>1. 什么是浅拷贝和深拷贝</h2><p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是<strong>浅拷贝</strong>，这和调用 memcpy() 函数的效果非常类似。<a id="more"></a></p>
<p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p>
<p>下面通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。</p>
<p><strong>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。</strong></p>
<p>深拷贝的例子比比皆是，除了上面的变长数组类，动态数组类也需要深拷贝；此外，标准模板库STL中的 string、vector、stack、set、map 等也都必须使用深拷贝。</p>
<p>如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>可以发现，更改 arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，导致 arr2.m_p 和 arr1.m_p 指向了同一块内存，所以会相互影响。</p>
<p>另外需要注意的是，printArray() 函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了 const 限制，以使得语义更加明确。</p>
<h2 id="2-到底是浅拷贝还是深拷贝"><a href="#2-到底是浅拷贝还是深拷贝" class="headerlink" title="2. 到底是浅拷贝还是深拷贝"></a>2. 到底是浅拷贝还是深拷贝</h2><p>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</p>
<p>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">obj1: count = <span class="number">1</span>, time = <span class="number">1488344372</span></span><br><span class="line">obj2: count = <span class="number">2</span>, time = <span class="number">1488344375</span></span><br></pre></td></tr></table></figure>
<p>运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.6下corosync+pacemaker+pcs高可用集群环境安装</title>
    <url>/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>在容灾备份领域，有多种高可用方案，corosync+pacemaker无疑是开源方案中的佼佼者。</strong></p>
<h2 id="什么是corosync、pacemaker、pcs？"><a href="#什么是corosync、pacemaker、pcs？" class="headerlink" title="什么是corosync、pacemaker、pcs？"></a>什么是corosync、pacemaker、pcs？</h2><blockquote>
<ul>
<li><p>Corosync是集群管理套件的一部分，通常会与其他资源管理器一起组合，使用它在传递信息的时候可以通过一个简单的配置文件来定义信息传递的方式和协议等。它是一个新兴的软件，2008年推出，但其实它并不是一个真正意义上的新软件，在2002年的时候有一个项目Openais，它由于过大，分裂为两个子项目，其中可以实现HA心跳信息传输的功能就是Corosync ，它的代码60%左右来源于Openais。Corosync可以提供一个完整的HA功能，但是要实现更多，更复杂的功能，那就需要使用Openais了。Corosync是未来的发展方向，在以后的新项目里，一般采用Corosync，而hb_gui可以提供很好的HA管理功能，可以实现图形化的管理。另外相关的图形化有RHCS的套件luci+ricci，当然还有基于java开发的LCMC集群管理工具。</p>
</li>
<li><p>Pacemaker是一个集群资源管理器。它利用集群基础构件（OpenAIS、heartbeat或corosync）提供的消息和成员管理能力来探测并从节点或资源级别的故障中恢复，以实现群集服务（亦称资源）的最大可用性。</p>
</li>
<li><p>Pcs是一种常用的集群配置及管理指令集，其他类似命令有crmsh。</p>
</li>
</ul>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h2><p>1、保证两个节点上的/etc/hosts文件均添加了下面的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span> g0001210030<span class="number">-00</span>-server01</span><br><span class="line"><span class="number">10.10</span><span class="number">.4</span><span class="number">.177</span> g0001210030<span class="number">-00</span>-server02</span><br></pre></td></tr></table></figure>
<p>2、关闭防火墙（每个节点都需执行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setenforce <span class="number">0</span></span><br><span class="line">sed -i.bak <span class="string">"s/SELINUX=enforcing/SELINUX=permissive/g"</span> /etc/selinux/config</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">iptables --flush</span><br></pre></td></tr></table></figure>
<p>3、查看主备机是否安装ntp服务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemctl status ntpd.service</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic1.png" alt></p>
<p>若未安装ntp服务，先安装，确认安装ntp服务后，主机执行以下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cp /etc/ntp.conf /etc/ntp.conf.bak</span><br><span class="line">rm -f /etc/ntp.conf</span><br><span class="line">vi /etc/ntp.conf</span><br></pre></td></tr></table></figure>
<p>在/etc/ntp.conf文件输入以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">restrict default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict <span class="number">-6</span> default kod nomodify notrap nopper noquery</span><br><span class="line">restrict <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">restrict <span class="number">-6</span>::<span class="number">1</span></span><br><span class="line">restrict <span class="number">10.10</span><span class="number">.1</span><span class="number">.0</span> mask <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span> nomodify notrap</span><br><span class="line">server <span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span></span><br><span class="line">server <span class="number">127.127</span><span class="number">.1</span><span class="number">.0</span></span><br><span class="line">fudge <span class="number">127.127</span><span class="number">.1</span><span class="number">.0</span> stratum <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>启动主机ntp服务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#systemctl start ntpd.service</span></span><br></pre></td></tr></table></figure>
<p>备机执行以下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ntpdate <span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span></span><br></pre></td></tr></table></figure>
<p>如果出现下面提示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span> Sep <span class="number">18</span>:<span class="number">01</span>:<span class="number">41</span> ntpdate[<span class="number">2604</span>]: no server suitable <span class="keyword">for</span> synchronization found</span><br></pre></td></tr></table></figure>
<p>稍等片刻再执行一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ntpdate <span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="安装集群软件"><a href="#安装集群软件" class="headerlink" title="安装集群软件"></a><strong>安装集群软件</strong></h2><p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic2.png" alt></p>
<p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic3.png" alt></p>
<p>安装完毕，输入pcs status查询集群状态为下图所示，表示集群安装成功</p>
<p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic4.png" alt></p>
<hr>
<h2 id="集群资源配置"><a href="#集群资源配置" class="headerlink" title="集群资源配置"></a><strong>集群资源配置</strong></h2><p>1、注意：配置集群资源时，为防止资源启动的节点不一致，需要暂时将备节点的集群服务停止。在任意节点输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs cluster stop G0001210030<span class="number">-00</span>-SERVER02</span><br></pre></td></tr></table></figure>
<p>即可关闭备节点集群服务。</p>
<p>2、配置浮动IP和ha服务高可用（ip需根据实际情况修改、在任意节点配置即可）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs resource create vip ocf:heartbeat:IPaddr2 ip=<span class="number">192.168</span><span class="number">.8</span><span class="number">.53</span> cidr_netmask=<span class="number">16</span> op monitor interval=<span class="number">30</span>s</span><br><span class="line">pcs resource create ha systemd:ha op monitor interval=<span class="number">60</span>s timeout=<span class="number">60</span>s on-fail=restart</span><br></pre></td></tr></table></figure>
<p>配置资源关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs constraint colocation add vip ha INFINITY</span><br></pre></td></tr></table></figure>
<p>设置启动顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs constraint order vip  then ha</span><br></pre></td></tr></table></figure>
<p>3、配置其他资源，如mariadb数据库服务（在任意节点配置即可，需要注意的是：配置mariadb服务高可用需要将mariadb服务设置为开机不自启）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs resource create mysql-s systemd:mariadb op monitor interval=<span class="number">60</span>s timeout=<span class="number">60</span>s on-fail=restart</span><br></pre></td></tr></table></figure>
<p>配置资源关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs constraint colocation add ha mysql-s INFINITY</span><br></pre></td></tr></table></figure>
<p>设置启动顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcs constraint order ha then mysql-s</span><br></pre></td></tr></table></figure>
<p><strong>至此整个搭建过程完毕。</strong></p>
]]></content>
      <categories>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：拷贝构造函数</title>
    <url>/2023/01/02/C-%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-拷贝和拷贝构造函数"><a href="#1-拷贝和拷贝构造函数" class="headerlink" title="1. 拷贝和拷贝构造函数"></a>1. 拷贝和拷贝构造函数</h2><p>拷贝和复制是一个意思，对应的英文单词都是<code>copy</code>。对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。<a id="more"></a></p>
<p>在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化：</p>
<ol>
<li>分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li>
<li>初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。</li>
</ol>
<p>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net http://c.biancheng.net</span></span><br></pre></td></tr></table></figure>
<p>s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。</p>
<blockquote>
<p>对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的，这其实涉及到C++转换构造函数的知识。s4 也是类似的道理。</p>
</blockquote>
<p>对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p>
<p>对于 func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 func() 时，才会将其它对象的数据拷贝给 str 以完成初始化。</p>
<p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。</p>
<p>下面的例子演示了拷贝构造函数的定义和使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.<span class="built_in">display</span>();</span><br><span class="line">    stu2.<span class="built_in">display</span>();</span><br><span class="line">    stu3.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line">Copy constructor was called.</span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br></pre></td></tr></table></figure>
<p>第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p>
<h3 id="1-1-为什么必须是当前类的引用呢？"><a href="#1-1-为什么必须是当前类的引用呢？" class="headerlink" title="1.1 为什么必须是当前类的引用呢？"></a>1.1 为什么必须是当前类的引用呢？</h3><p>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p>
<p>只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p>
<h3 id="1-2-为什么是-const-引用呢？"><a href="#1-2-为什么是-const-引用呢？" class="headerlink" title="1.2 为什么是 const 引用呢？"></a>1.2 为什么是 const 引用呢？</h3><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p>
<p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p>
<p>以上面的 Student 类为例，将 const 去掉后，拷贝构造函数的原型变为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student::Student(Student &amp;stu);</span><br></pre></td></tr></table></figure>
<p>此时，下面的代码就会发生错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用<code>Student::Student(const Student &amp;stu)</code>，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用<code>Student::Student(Student &amp;stu)</code>，所以最终调用失败了。</p>
<p>当然，也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。</p>
<h2 id="2-默认拷贝构造函数"><a href="#2-默认拷贝构造函数" class="headerlink" title="2. 默认拷贝构造函数"></a>2. 默认拷贝构造函数</h2><p>其实，即使我们没学习过拷贝构造函数，实际上却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。</p>
<p>对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.x系统中Docker安装及简单使用</title>
    <url>/2020/12/30/Centos7-x%E7%B3%BB%E7%BB%9F%E4%B8%ADDocker%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器或Windows 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</li>
<li>一个完整的Docker由四个部分组成：Docker Client（客户端）、Docker Daemon（守护进程）、Docker Image（镜像）和Docker Container（容器）。</li>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><pre><code>1、只能是64位的系统;
2、要求centos7以上系统的内核版本不低于3.10。
</code></pre><hr>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>1、移除旧版本的docker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine</span><br></pre></td></tr></table></figure>
<p>2、安装依赖包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>3、添加yum软件源<br>非官方源(比如阿里云)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>官方源</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>4、更新yum软件源缓存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>
<p>5、安装docker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum  -y install  docker-ce</span><br></pre></td></tr></table></figure>
<p>安装时，如果报错出现rpm包无法找到，先手动通过wget下载该rpm包，然后重新执行安装命令即可。 </p>
<hr>
<h2 id="Docker镜像和容器的简单使用命令"><a href="#Docker镜像和容器的简单使用命令" class="headerlink" title="Docker镜像和容器的简单使用命令"></a>Docker镜像和容器的简单使用命令</h2><p>1、查看docker版本： docker  version<br>2、查询镜像： docker  search  imageName[镜像名称：如  centos]<br>3、获取镜像：docker  pull  imageName[镜像名称：如  centos]<br>4、列出镜像:  docker  image  ls<br>5、查询镜像体积：docker system df<br>6、删除镜像:docker  image rm  imagesID<br>7、启动容器： docker  run —name <em>*</em>  -p  port:port  -d  [镜像名] 或者 docker start [containerID/containerName]<br>8、退出容器：exit/docker  stop containerID<br>9、进入容器：docker  attach  containerID 或者 docker   exec  -it   containerID<br>10、删除容器：<br>1）删除处于终止状态的：docker  container  rm  [ID]<br>2）删除处于运行状态的：docker  container  rm  -f  [ID]<br>3）删除所有处于终止状态的：docker container prune </p>
<hr>
<h2 id="Docker安装Tomcat实例"><a href="#Docker安装Tomcat实例" class="headerlink" title="Docker安装Tomcat实例"></a>Docker安装Tomcat实例</h2><p>1、获取tomcat镜像: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker  pull  tomcat</span><br></pre></td></tr></table></figure>
<p>2、新建并运行tomcat容器:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run  --name  tomcat  -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>:<span class="number">8080</span>    -d  tomcat</span><br><span class="line">docker run  --name  tomcat  -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>:<span class="number">8080</span>    -d  tomcat --restart=always</span><br></pre></td></tr></table></figure>
<pre><code>--name：容器名 
-p：后面接IP地址(可以不设)：接宿主机端口：容器端口  
-d：后台运行
</code></pre><p>3、进入容器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker   <span class="keyword">exec</span>/attach  -it  tomcat  bash</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span>进入容器后使用exit命令退出容器，只会退出容器，让容器在后台继续运行</span><br><span class="line">attach进入容器后使用exit命令退出容器，会直接关闭容器</span><br><span class="line">-it：交互模式进入容器</span><br></pre></td></tr></table></figure>
<p>4、退出tomcat容器：exit<br>5、停止tomcat容器：docker   stop   tomcat<br>6、启动tomcat容器：docker   start   tomcat<br>7、删除tomcat容器：docker   container    rm  -f  tomcat</p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM</title>
    <url>/2021/01/02/KVM/</url>
    <content><![CDATA[<h2 id="KVM简介"><a href="#KVM简介" class="headerlink" title="KVM简介"></a>KVM简介</h2><p>Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux2.6.20之后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于Xen，其核心源码很少。KVM目前已成为学术界的主流VMM之一。</p>
<a id="more"></a>
<hr>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ol>
<li><p>Kvm的安装，需要一定的硬件和软件支持：</p>
<p>​    1.需要宿主机CPU支持完全虚拟化（如Intel VT技术或者AMD V技术）。<br>​    2.宿主机系统为64位的Linux系统且内核版本高于2.6.20，内核版本过低，需要进行升级。 </p>
</li>
<li><p>查看CPU是否支持完全虚拟化，在宿主机输入：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">egrep <span class="string">'vmx|svm'</span> /proc/cpuinfo</span><br><span class="line">...</span><br><span class="line">flags  : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm dca sse4_1 sse4_2 popcnt aes lahf_lm ida arat dts tpr_shadow vnmi flexpriority ept vpid</span><br></pre></td></tr></table></figure>
<p>​       回车后，出现以上结果，说明CPU支持虚拟化且已经开启。Vmx是intel cpu，svm为AMD cpu。另外在选择宿主机系统的时候，尽量不要使用Centos6.3和6.4版本，经验证，这两个版本安装kvm后，会出现图像界面闪烁情况，推荐使用Centos 6.5 64bit。对于宿主机的配置，官方建议为64位x86架构且支持虚拟化指令集的CPU，4G内存，以便发挥kvm最大性能。</p>
<hr>
<h2 id="KVM安装"><a href="#KVM安装" class="headerlink" title="KVM安装"></a>KVM安装</h2><ol>
<li>关闭selinux<br>设置selinux=disable。</li>
<li>使用yum安装命令进行安装相关软件包</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install kvm qemu-kvm virt-viewer virt-manager libvirt libvirt-python python-virtinst bridge-utils tunctl</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>kvm是属于内核模块；</p>
</li>
<li><p>qemu-kvm是kvm的一个管理工具的引擎；</p>
</li>
<li><p>libvirt和libvirt-client提供访问和控制虚拟客户端的接口；</p>
</li>
<li><p>python-virtinst中有很多用于安装虚拟机的程序，如virt-install，virt-clone等；</p>
</li>
<li><p>bridge-utils是一个和网桥有关的程序。</p>
</li>
</ul>
</blockquote>
<ol>
<li>安装完毕后，Reboot机器</li>
</ol>
<hr>
<h2 id="KVM启用"><a href="#KVM启用" class="headerlink" title="KVM启用"></a>KVM启用</h2><ol>
<li><p>查看虚拟机安装情况，安装正常会出现如下情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lsmod | grep kvm  </span><br><span class="line">kvm_intel    <span class="number">69416</span>  <span class="number">0</span></span><br><span class="line">kvm           <span class="number">226208</span>  <span class="number">1</span> kvm_amd</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 libvirtd </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">service libvirtd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看虚拟机状态命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virsh  list   --all</span><br><span class="line">Id    Name                    status</span><br><span class="line">----------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>这样就表明kvm安装成功且已经能正常工作了。</p>
</li>
</ol>
<hr>
<h2 id="虚拟机安装和设置"><a href="#虚拟机安装和设置" class="headerlink" title="虚拟机安装和设置"></a>虚拟机安装和设置</h2><ol>
<li>virt-manager图形工具<br>安装kvm成功后，会在system tools中有一个virtual machine manager。Kvm虚拟机的安装维护，主要通过此工具。</li>
</ol>
<p><img src="/2021/01/02/KVM/1.png" alt></p>
<ol>
<li>新建kvm虚拟机<br>virtual machine manager 在首次登陆后，会自动创建一个本地的kvm连接。右击选择“new”即可新建虚拟机。</li>
</ol>
<p><img src="/2021/01/02/KVM/2.png" alt></p>
<ol>
<li>源文件选择<br>Kvm的源文件安装方式有四种，我们主要熟知第一种和第四种。第一种为选择本地的镜像文件安装，第四种为选择从其他虚拟机（vmware）迁移过来的虚拟机文件，选择后点击“Forward”。</li>
</ol>
<p><img src="/2021/01/02/KVM/3.png" alt></p>
<ol>
<li><p>选择源文件路径OS type 和Version可以默认，选择路径后点击“Forward”。</p>
<p><img src="/2021/01/02/KVM/4.png" alt></p>
</li>
<li><p>Cpu和内存设置</p>
<p>设置虚拟机内存大小和cpu个数，选择后点击“Forword”。</p>
</li>
</ol>
<p><img src="/2021/01/02/KVM/5.png" alt></p>
<ol>
<li><p>设置和网络<br>勾选“customize……install”，这样在点击Finish后，我们可以再具体配置虚拟机的其他选项。<br>Advancde options 下可以设置虚拟机的网络连接类型和MAC地址。</p>
<p><img src="/2021/01/02/KVM/6.png" alt></p>
</li>
<li><p>具体设置<br>在安装前可以具体设置kvm的各个参数。</p>
</li>
</ol>
<p><img src="/2021/01/02/KVM/7.png" alt></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM之virsh管理命令</title>
    <url>/2021/01/03/KVM%E4%B9%8Bvirsh%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Virsh简介"><a href="#Virsh简介" class="headerlink" title="Virsh简介"></a>Virsh简介</h2><ul>
<li>virsh 是用来管理客户端及其管理程序的命令行界面工具。</li>
<li>virsh 工具是构建在 libvirt 管理 API 上，可作为 xm 命令和图形客户端管理程序（virt-manager）的替代工具。非特权用户只能以只读模式使用 virsh。您可使用 virsh 为客户端机器执行脚本。</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h2><ol>
<li>安装虚拟化相关组件<br>安装qemu-kvm（用户态管理工具）<br>安装libvirt（命令行管理工具）<br>安装virt-install（安装kvm工具）<br>安装bridge-utils（桥接设备管理工具）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install -y qemu-kvm libvirt virt-install bridge-utils</span><br></pre></td></tr></table></figure></li>
<li>启动libvirtd服务<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemctl enable libvirtd</span><br><span class="line">systemctl start  libvirtd</span><br><span class="line">systemctl status  libvirtd</span><br></pre></td></tr></table></figure></li>
<li>安装virt-manager<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum -y install virt-manager</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用可视化创建的虚拟机xml文件位置：/etc/libvirt/qemu/</p>
<hr>
<h2 id="常用的虚拟机管理命令"><a href="#常用的虚拟机管理命令" class="headerlink" title="常用的虚拟机管理命令"></a>常用的虚拟机管理命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有的虚拟机</span></span><br><span class="line">virsh list --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示虚拟机信息</span></span><br><span class="line">virsh dominfo *	( *为虚拟机名称 )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义虚拟机</span></span><br><span class="line">virsh define *.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动虚拟机</span></span><br><span class="line">virsh start *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制关闭虚拟机/关闭虚拟机</span></span><br><span class="line">virsh destroy */virsh shutdown *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除虚拟机</span></span><br><span class="line">virsh undefine *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂起虚拟机</span></span><br><span class="line">virsh suspend *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复被挂起的虚拟机</span></span><br><span class="line">virsh resume *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看虚拟机网卡信息</span></span><br><span class="line">virsh domiflist *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加网卡</span></span><br><span class="line">virsh attach-interface * --type * --source * --model * --live --config</span><br><span class="line">（第一个*为虚拟机名称，后三个*依次为Type Source Model）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除网卡</span></span><br><span class="line">virsh detach-interface * --type  * --mac  *  --live --config</span><br><span class="line">（第一个*为虚拟机名称，后两个*依次为Type MAC）</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="通过xml文件创建虚拟机"><a href="#通过xml文件创建虚拟机" class="headerlink" title="通过xml文件创建虚拟机"></a>通过xml文件创建虚拟机</h2><ol>
<li>创建空镜像<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2  *.qcow2  <span class="number">100</span>G	（*为虚拟机名称，大小自定义）</span><br></pre></td></tr></table></figure></li>
<li>配置xml并启动虚拟机，xml文件配置可通过可视化创建虚拟机生成的xml文件作为模板。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virsh define *.xml</span><br><span class="line">virsh start  *</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="通过存储池iSCSI创建虚拟机"><a href="#通过存储池iSCSI创建虚拟机" class="headerlink" title="通过存储池iSCSI创建虚拟机"></a>通过存储池iSCSI创建虚拟机</h2><ol>
<li>定义存储池<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virsh pool-define-<span class="keyword">as</span> --name unary --type iscsi --source-host <span class="number">10.10</span><span class="number">.4</span><span class="number">.75</span> --source-dev iqn<span class="number">.2020</span><span class="number">-01.</span>com.unary:<span class="number">208450552</span>df3636922c9fbb0b0c71f45.d41d8cd98f00b204e9800998ecf8427e.v<span class="number">.4</span>a2a26d3.st<span class="number">.20200102193701</span> --target /dev/disk/by-path</span><br></pre></td></tr></table></figure></li>
<li>创建存储池<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virsh pool-build unary</span><br></pre></td></tr></table></figure></li>
<li>激活存储池<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virsh pool-start unary</span><br></pre></td></tr></table></figure></li>
<li>查看存储池<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">virsh pool-list –all</span><br></pre></td></tr></table></figure></li>
<li>创建空镜像</li>
<li>配置xml并启动虚拟机</li>
</ol>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>ESXi上修改虚拟机磁盘扇区大小为32的简易方法</title>
    <url>/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>本文介绍ESXi服务器上修改虚拟机磁盘扇区大小为32的两种方法。</strong></p>
<a id="more"></a>
<hr>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>1、登陆ESXi，进入虚拟机所在的datastore目录，每个目录为一个虚拟机</p>
<p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/3.png" alt></p>
<p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/4.png" alt></p>
<p>2、找到对应的vmdk文件</p>
<p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/5.png" alt></p>
<p>3、进入修改</p>
<p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/6.png" alt></p>
<p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/7.png" alt></p>
<p>4、保存退出即可</p>
<hr>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>1、ESXi上创建需要安装版本的虚拟机，暂不安装系统</p>
<p>2、将虚拟机的vmdk文件下载到本地进行以下修改</p>
<p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/8.png" alt></p>
<p>3、将修改后的vmdk文件上传到ESXi后开始系统安装</p>
<p>4、安装完成后使用winhex工具查看磁盘扇区数是否为32扇区</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>ESXi</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下修改mysql数据库密码的几种方法</title>
    <url>/2021/01/05/Linux%E4%B8%8B%E4%BF%AE%E6%94%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>本文介绍几种常见情况下mysql数据库的密码修改方法。</strong></p>
<a id="more"></a>
<hr>
<h2 id="未设置密码，可以通过mysql直接登录数据库"><a href="#未设置密码，可以通过mysql直接登录数据库" class="headerlink" title="未设置密码，可以通过mysql直接登录数据库"></a>未设置密码，可以通过mysql直接登录数据库</h2><h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set password=password(<span class="string">"111111"</span>) where user=<span class="string">'root'</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure></h2><h2 id="若已知密码，需要修改密码"><a href="#若已知密码，需要修改密码" class="headerlink" title="若已知密码，需要修改密码"></a>若已知密码，需要修改密码</h2><p>除了上述方法，也可以在mysql系统外，使用mysqladmin。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password <span class="string">"111111"</span></span><br><span class="line">Enter password: 【输入原来的密码】</span><br></pre></td></tr></table></figure></h2><h2 id="若忘记数据库密码，需要修改密码"><a href="#若忘记数据库密码，需要修改密码" class="headerlink" title="若忘记数据库密码，需要修改密码"></a>若忘记数据库密码，需要修改密码</h2><p>1、先停止数据库服务，修改/etc/my.cnf文件，在[mysqld]末尾添加skip-grant-tables；<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><br>2、重新启动数据库，可以通过mysql直接登录数据库；<br>3、修改密码完成后，删除skip-grant-tables。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-21.合并两个有序链表</title>
    <url>/2023/01/29/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表（Merge-Two-Sorted-Lists）"><a href="#21-合并两个有序链表（Merge-Two-Sorted-Lists）" class="headerlink" title="21. 合并两个有序链表（Merge Two Sorted Lists）"></a>21. 合并两个有序链表（Merge Two Sorted Lists）</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<a id="more"></a>
<h2 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h2><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p>
<p><img src="/2023/01/29/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/递归公式.png" alt></p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况。如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="/2023/01/29/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/复杂度分析1.png" alt></p>
<h3 id="C-解法一"><a href="#C-解法一" class="headerlink" title="C++ 解法一"></a>C++ 解法一</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next; <span class="comment">// 节点存储的next节点地址</span></span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(<span class="literal">nullptr</span>) &#123;&#125;   <span class="comment">// 无参构造函数：节点值为0，next节点地址为空</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;  <span class="comment">// 有参构造函数：节点值为x，next节点地址为空</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode *next) : val(x), next(next) &#123;&#125; <span class="comment">// 有参构造函数：节点值为x，next节点地址为next</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="comment">// 使用&amp;：因为无需拷贝nums；使用const：因为无需改变nums中元素的值</span></span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 定义哑结点（方式一）：在栈上开辟空间，由系统自动分配内存并销毁</span></span><br><span class="line">    <span class="comment">//ListNode* dummy = new ListNode(); // 定义哑结点（方式二）：在堆上开辟空间，手动分配内存并需要手动销毁</span></span><br><span class="line">    <span class="comment">// 为什么在这里要采用方式一：因为后面在销毁链表时，并没有处理哑结点。如果采用方式二，需要在后面处理哑结点。</span></span><br><span class="line">    ListNode* node = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; n: nums) &#123;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; head-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ListNode* delNode = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> delNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    ListNode* l1 = createList(nums1);</span><br><span class="line">    printList(l1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    ListNode* l2 = createList(nums2);</span><br><span class="line">    printList(l2);</span><br><span class="line"></span><br><span class="line">    Solution s;</span><br><span class="line">    printList(s.mergeTwoLists(l1, l2));</span><br><span class="line"></span><br><span class="line">    destroyList(l1);</span><br><span class="line">    destroyList(l2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法2：迭代"><a href="#方法2：迭代" class="headerlink" title="方法2：迭代"></a>方法2：迭代</h2><h3 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p>
<p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="/2023/01/29/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/复杂度分析2.png" alt></p>
<h3 id="C-解法二"><a href="#C-解法二" class="headerlink" title="C++ 解法二"></a>C++ 解法二</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next; <span class="comment">// 节点存储的next节点地址</span></span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(<span class="literal">nullptr</span>) &#123;&#125;   <span class="comment">// 无参构造函数：节点值为0，next节点地址为空</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;  <span class="comment">// 有参构造函数：节点值为x，next节点地址为空</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode *next) : val(x), next(next) &#123;&#125; <span class="comment">// 有参构造函数：节点值为x，next节点地址为next</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="comment">// 使用&amp;：因为无需拷贝nums；使用const：因为无需改变nums中元素的值</span></span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 定义哑结点（方式一）：在栈上开辟空间，由系统自动分配内存并销毁</span></span><br><span class="line">    <span class="comment">//ListNode* dummy = new ListNode(); // 定义哑结点（方式二）：在堆上开辟空间，手动分配内存并需要手动销毁</span></span><br><span class="line">    <span class="comment">// 为什么在这里要采用方式一：因为后面在销毁链表时，并没有处理哑结点。如果采用方式二，需要在后面处理哑结点。</span></span><br><span class="line">    ListNode* node = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; n: nums) &#123;</span><br><span class="line">        node-&gt;next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; head-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ListNode* delNode = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> delNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    ListNode* l1 = createList(nums1);</span><br><span class="line">    printList(l1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    ListNode* l2 = createList(nums2);</span><br><span class="line">    printList(l2);</span><br><span class="line"></span><br><span class="line">    Solution s;</span><br><span class="line">    printList(s.mergeTwoLists(l1, l2));</span><br><span class="line"></span><br><span class="line">    destroyList(l1);</span><br><span class="line">    destroyList(l2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LU分解法求解线性方程组</title>
    <url>/2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p><strong>利用LU分解法求解线性方程组，基于C++语言实现。</strong></p>
<a id="more"></a>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵的ALU分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALU</span><span class="params">(<span class="keyword">double</span> a[n][n], <span class="keyword">double</span> b[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> u[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行U的第一行的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[<span class="number">0</span>][i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行L的第一列的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i][<span class="number">0</span>] = a[i][<span class="number">0</span>] / u[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算U的剩下的行数和L的剩下的列数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 计算U的行</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum1 += l[i][k] * u[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            u[i][j] = a[i][j] - sum1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算L的列</span></span><br><span class="line">        <span class="keyword">if</span>(i!=n)</span><br><span class="line">			<span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">double</span> sum2 = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					sum2 += l[j][k] * u[k][i];</span><br><span class="line">				&#125;</span><br><span class="line">				l[j][i] = (a[j][i] - sum2) / u[i][i];</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出L和U</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵L为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)			</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; l[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵U为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)			</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; u[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 求y</span></span><br><span class="line">    <span class="keyword">double</span> y[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    y[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            sum3 += l[i][j] * y[j];</span><br><span class="line">        y[i] = b[i] - sum3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 求x</span></span><br><span class="line">    <span class="keyword">double</span> x[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    x[n - <span class="number">1</span>] = y[n - <span class="number">1</span>] / u[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            sum4 += u[i][j] * x[j];</span><br><span class="line">        x[i] = (y[i] - sum4) / u[i][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"该线性方程组的解为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x["</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"]="</span> &lt;&lt; x[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[<span class="number">3</span>] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    ALU(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">矩阵L为：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">-0.333333</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0.333333</span> <span class="number">-0.357143</span> <span class="number">0</span></span><br><span class="line">矩阵U为：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">4.66667</span> <span class="number">4.66667</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">x[<span class="number">1</span>]=<span class="number">0.5</span></span><br><span class="line">x[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">x[<span class="number">3</span>]=<span class="number">0.5</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下通过python的pymysql模块向mysql数据库持续插入图片数据</title>
    <url>/2021/01/05/Linux%E4%B8%8B%E9%80%9A%E8%BF%87python%E7%9A%84pymysql%E6%A8%A1%E5%9D%97%E5%90%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%81%E7%BB%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p><strong>在灾备软件的压力测试中，需要向客户服务器的数据库持续输入数据，来验证大量IO情况下服务器及灾备软件能否正常工作。本文介绍一种向mysql数据库持续插入图片数据的简单方法。</strong></p>
<a id="more"></a>
<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装pymysql模块</p>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure></h2><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#图片路径（根据实际情况修改）示例如下：</span></span><br><span class="line">picUrl = <span class="string">"/test/index.jpg"</span></span><br><span class="line"><span class="comment">#连接的数据库服务器主机名（根据实际情况修改）示例如下：</span></span><br><span class="line"><span class="comment">#conhost="127.0.0.1"</span></span><br><span class="line">conhost=<span class="string">"localhost"</span></span><br><span class="line"><span class="comment">#连接的数据库端口号（根据实际情况修改）示例如下：</span></span><br><span class="line">conport=<span class="number">3306</span></span><br><span class="line"><span class="comment">#连接的数据库的用户名（根据实际情况修改）示例如下：</span></span><br><span class="line">conuser=<span class="string">"root"</span></span><br><span class="line"><span class="comment">#连接的数据库密码（根据实际情况修改）示例如下：</span></span><br><span class="line">conpasswd=<span class="string">"111111"</span></span><br><span class="line"><span class="comment">#连接的数据库名（根据实际情况修改）示例如下：</span></span><br><span class="line">condb=<span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobDataTestor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#连接数据库</span></span><br><span class="line">        self.conn = pymysql.connect(host=conhost,port=conport, user=conuser,passwd=conpasswd,db=condb)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.conn.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self)</span>:</span></span><br><span class="line">        cursor = self.conn.cursor()</span><br><span class="line">        cursor.execute(<span class="string">"""  </span></span><br><span class="line"><span class="string">            CREATE TABLE IF NOT EXISTS `Dem_Picture` (  </span></span><br><span class="line"><span class="string">            `ID` int(11) NOT NULL auto_increment,</span></span><br><span class="line"><span class="string">            `time` timestamp  ,</span></span><br><span class="line"><span class="string">            `PicData` mediumblob,</span></span><br><span class="line"><span class="string">            `RandomNum` varchar(20),</span></span><br><span class="line"><span class="string">            PRIMARY KEY (`ID`)  </span></span><br><span class="line"><span class="string">            ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;  </span></span><br><span class="line"><span class="string">            """</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#删除表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown</span><span class="params">(self)</span>:</span></span><br><span class="line">        cursor = self.conn.cursor()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(<span class="string">"Drop Table Dem_Picture"</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># self.conn.commit()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testRWBlobData</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 读取源图片数据</span></span><br><span class="line">        f = open(picUrl, <span class="string">"rb"</span>)</span><br><span class="line">        b = f.read()</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成随机数</span></span><br><span class="line">        s = <span class="string">''</span>.join(random.choice(string.ascii_uppercase + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据写入表</span></span><br><span class="line">        cursor = self.conn.cursor()</span><br><span class="line">        cursor.execute(<span class="string">"INSERT INTO Dem_Picture (time,PicData,RandomNum) VALUES (current_timestamp,%s,%s)"</span>,((pymysql.Binary(b)),s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    test = BlobDataTestor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#创建表</span></span><br><span class="line">        test.setup()</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            test.testRWBlobData()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"insert success"</span></span><br><span class="line">            <span class="comment">#time.sleep(1)	#根据需要设置插入时间间隔</span></span><br><span class="line">        <span class="comment">#删除表</span></span><br><span class="line">        <span class="comment">#test.teardown()</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        test.closedb()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Rsync简介</title>
    <url>/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><strong>Rsync是一个远程数据同步工具，可以实现Windows系统间、Linux系统间以及Windows和Linux系统间的数据同步。</strong><br><strong>本文具体介绍Windows to Windows的使用。</strong></p>
<a id="more"></a>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>服务端：win2008R2 64bit<br>ip：10.10.4.175<br>数据库：mysql</li>
<li>客户端：win2008R2 64bit<br>ip：10.10.4.75<br>数据库：mysql</li>
</ul>
<p><strong>注意：关闭防火墙，保证服务端和客户端网络相通。</strong></p>
<hr>
<h2 id="软件安装及配置"><a href="#软件安装及配置" class="headerlink" title="软件安装及配置"></a>软件安装及配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol>
<li>解压服务端软件cwRsyncServer_4.0.5_Installe.zip安装，安装过程选择默认即可。</li>
<li>打开cwRsyncServer安装路径C:\Program Files(x86)\ICW，其中rsyncd.conf是cwRsyncServer配置文件。修改文件内容如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">use chroot = false</span><br><span class="line">strict modes = false</span><br><span class="line">hosts allow = <span class="number">10.10</span><span class="number">.4</span><span class="number">.75</span> <span class="comment">#限制了只允许10.10.4.75进行连接</span></span><br><span class="line">uid = <span class="number">0</span></span><br><span class="line">gid = <span class="number">0</span></span><br><span class="line">max connections = <span class="number">10</span></span><br><span class="line">strict modes = false</span><br><span class="line">log file = rsyncd.log</span><br><span class="line">lock file = rsyncd.lock</span><br><span class="line">[test] <span class="comment">#模块名称，可自定义</span></span><br><span class="line">path = /cygdrive/e/MySQL Server <span class="number">5.1</span>/data <span class="comment">#需要同步的文件目录</span></span><br><span class="line">read only = false</span><br><span class="line">transfer logging = yes</span><br><span class="line">auth users = test <span class="comment">#用户名</span></span><br><span class="line">secrets file = /cygdrive/c/Program Files (x86)/ICW/rsyncd.secrets <span class="comment">#用户和密码文件，内容为：test:111111</span></span><br><span class="line">comment = test</span><br></pre></td></tr></table></figure>
<strong>注意：默认rsync使用873端口，自行开启windows 873端口，如果想使用其他端口自行添加port参数。</strong></li>
<li><p>在服务中找到RsyncServer，更改成自动启动，然后确认即可。</p>
<p><img src="/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/1.png" alt></p>
</li>
</ol>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>将客户端软件cwRsyncClient.rar解压到E盘cwRsync目录下。</li>
<li>在E:\cwRsync目录下创建一个密码文件password.txt，内容为111111。</li>
<li>在E:\cwRsync目录下创建一个bat文件rsync.bat。批处理文件内容如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd E:\cwRsync</span><br><span class="line">rsync -artzvP --delete --password-file=/cygdrive/e/cwRsync/password.txt unary@<span class="number">10.10</span><span class="number">.4</span><span class="number">.175</span>::test <span class="string">"/cygdrive/e/MySQL Server 5.1/data"</span></span><br></pre></td></tr></table></figure>
bat脚本命令说明：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd 客户端软件解压目录</span><br><span class="line">rsync -artzvP --delete --password-file=客户端密码文件路径 用户名@服务端ip::模块名称 客户端数据同步目录</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="执行同步"><a href="#执行同步" class="headerlink" title="执行同步"></a>执行同步</h2><p>执行rsync.bat即可执行同步任务。</p>
<p><img src="/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/2.png" alt></p>
<p>同步完成后，客户端目录下即可看到服务端同步过来的数据。</p>
]]></content>
      <categories>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>python+selenium实现自动刷新网页</title>
    <url>/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p><strong>Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。</strong></p>
<a id="more"></a>
<hr>
<p>一、安装 selenium</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
<p>二、下载并导入浏览器驱动</p>
<p>1、查看Chrome浏览器版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chrome://version</span><br></pre></td></tr></table></figure>
<p>2、根据版本下载对应浏览器驱动</p>
<p>下载网址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p>
<p>3、将下载的驱动放入python安装目录Scripts文件夹下。</p>
<p>三、示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    driver.refresh()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>selenium</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>redhat7.6配置163yum源</title>
    <url>/2021/01/05/redhat7-6%E9%85%8D%E7%BD%AE163yum%E6%BA%90/</url>
    <content><![CDATA[<p><strong>本文介绍redhat7.6服务器上配置163yum源的方法。</strong></p>
<hr>
<h2 id="yum源简介"><a href="#yum源简介" class="headerlink" title="yum源简介"></a>yum源简介</h2><ul>
<li>yum需要一个yum库，也就是yum源。默认情况下，CentOS就有一个yum源，其配置文件在/etc/yum.repos.d/目录下。</li>
<li>当使用yum下载安装rpm包时，首先要找一个yum库（源），然后确保本地有一个客户端（yum这个命令就是客户端），由yum程序去连接服务器。连接的方式是由配置文件决定的。通过编辑/etc/yum.repos.d/CentOS-Base.repo文件，可以修改设置。</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="确认版本"><a href="#确认版本" class="headerlink" title="确认版本"></a>确认版本</h2><h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@promote ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">Red Hat Enterprise Linux Server release <span class="number">7.6</span> (Maipo)</span><br></pre></td></tr></table></figure></h2><h2 id="卸载本地yum"><a href="#卸载本地yum" class="headerlink" title="卸载本地yum"></a>卸载本地yum</h2><h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep yum　　<span class="comment">#查看本地yum</span></span><br><span class="line">rpm -qa|grep yum|xargs rpm -e --nodeps　　<span class="comment">#卸载本地yum，不检查依赖性，卸载yum程序</span></span><br><span class="line">rpm -qa|grep yum    <span class="comment">#再次查看是否正确卸载</span></span><br></pre></td></tr></table></figure></h2><h2 id="下载yum相关程序"><a href="#下载yum相关程序" class="headerlink" title="下载yum相关程序"></a>下载yum相关程序</h2><h2 id="-2"><a href="#-2" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/python-urlgrabber<span class="number">-3.10</span><span class="number">-10.</span>el7.noarch.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/rpm<span class="number">-4.11</span><span class="number">.3</span><span class="number">-45.</span>el7.x86_64.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum<span class="number">-3.4</span><span class="number">.3</span><span class="number">-168.</span>el7.centos.noarch.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum-metadata-parser<span class="number">-1.1</span><span class="number">.4</span><span class="number">-10.</span>el7.x86_64.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum-plugin-fastestmirror<span class="number">-1.1</span><span class="number">.31</span><span class="number">-54.</span>el7_8.noarch.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum-utils<span class="number">-1.1</span><span class="number">.31</span><span class="number">-54.</span>el7_8.noarch.rpm</span><br></pre></td></tr></table></figure></h2><h2 id="安装yum程序"><a href="#安装yum程序" class="headerlink" title="安装yum程序"></a>安装yum程序</h2><p>若提示依赖检测失败，执行以下命令强制安装。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rpm -ivh * --force --nodeps <span class="comment">#--force 强制安装，--nodeps 不检查依赖</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="修改repo文件"><a href="#修改repo文件" class="headerlink" title="修改repo文件"></a>修改repo文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/　　<span class="comment">#进入到yum配置文件目录</span></span><br><span class="line">mkdir repo_backup   <span class="comment">#创建yum备份目录</span></span><br><span class="line">mv *.repo repo_backup   <span class="comment">#备份</span></span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/.help/CentOS7-Base<span class="number">-163.</span>repo　　<span class="comment">#下载CentOS配置文件</span></span><br></pre></td></tr></table></figure>
<p>修改CentOS7-Base-163.repo文件</p>
<h2 id="-3"><a href="#-3" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vi CentOS7-Base<span class="number">-163.</span>repo</span><br><span class="line">:%s/$releasever/<span class="number">7</span>/ge</span><br></pre></td></tr></table></figure></h2><h2 id="清除并更新yum缓存"><a href="#清除并更新yum缓存" class="headerlink" title="清除并更新yum缓存"></a>清除并更新yum缓存</h2><h2 id="-4"><a href="#-4" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum clean all&amp;yum makecache</span><br><span class="line">yum update</span><br><span class="line">yum repolist <span class="comment">#验证结果</span></span><br></pre></td></tr></table></figure></h2><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>当发现仍无需要的软件时，CentOS还有一个源叫做EPEL(Extra Packages for Enterprise)，可尝试安装epel yum源<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>redhat</category>
      </categories>
      <tags>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>《信》-东野圭吾</title>
    <url>/2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/</url>
    <content><![CDATA[<p>看完了东野圭吾的《信》，这不是一部推理题材的小说，只是讲述了一个关于人性的故事。故事围绕“犯罪者的家属该不该受到歧视”展开，主人公的哥哥犯下了盗窃杀人罪，留下他独自一人，没有钱上大学只能去打工，却在被老板知道自己的哥哥是罪犯后遭遇辞退，一次次想隐瞒却又终究暴露，连自己的女朋友也因此分手，好不容易结婚生了孩子，竟连孩子也要饱受歧视。于是，他的心理也在这一件件事中发生改变，甚至扭曲，终于无法忍受，写信告诉自己的哥哥要断绝关系，不再相见……<a id="more"></a></p>
<p>以前，我只觉得犯罪者的家属因犯罪者而受到歧视似乎有失公允，至少不能一概而论，但大家的做法也无可厚非，因为没有人愿意跟犯罪扯上关系。现在看来，这里面还有一层含义，那就是这些家属所受的歧视其实也是犯罪成本的一部分，以此来警告那些试图犯罪者，犯罪的结果不只牵涉本人，也会给亲人带来麻烦。可是，我又有了一个疑问。犯罪者在犯罪时可能会想到这么多吗？即使像这篇小说中，主人公的哥哥是为了替他凑够上大学的学费才去盗窃，也不是一开始就计划杀人，他也没能想到由此可能带给弟弟的痛苦，更不必说那些穷凶极恶之徒了。所以，这种警告跟欲犯罪者自身素养和对犯罪后果的了解有很大关系，但总的来说，这并不是一件可以讨论谁对谁错的事。</p>
<p>至于主人公，让我想起了一部电视剧《琅琊榜：风起长林》中的反派人物萧元启。他作为犯罪者的儿子，遭遇了人间冷暖，世态炎凉，本来是一个可怜之人，却最终一步步跌入仇恨的深渊。在他完全黑化前，与长林老王爷的一段对话让我记忆犹新，这也是曾经可能挽救他的良药。</p>
<blockquote>
<p>萧元启：境遇冷暖，自然会影响人的性情。性情若是变了，本心会变吗？</p>
<p>老王爷：如果你觉得这世态炎凉，那是因为你还没有经历过真正的地狱，一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p>
</blockquote>
<p>但萧元启终究没能找回他的赤子之心。现实中也是如此，一个人无疑是容易被周遭环境所影响的，特别是在如今的社会，复杂的人际关系，各种各样的诱惑，我们也许在不知不觉中就已经走在背离本心的路上，或是在某些情况下，我们不得不做出违背初心的行为，所以，我们应该时常问问自己是否还坚持着初心，这也许很难，但应该坚守。若是真的做出了违背初心的事，是否就一定会堕入深渊呢？也许会，也许不会。人世间的很多事很难得出对与错的结论，毕竟我们中的大多数都是普通人，我们常常站在道德的制高点趾高气昂，评头论足，却没有深入探究事件本身的勇气与能力。那么，我们究竟应该怎么做呢？还是那句话：一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>void*的用法</title>
    <url>/2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><strong>void*是一种特殊的指针类型，可用于存放任意对象的地址。</strong></p>
<a id="more"></a>
<h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> obj = <span class="number">3.14</span>, * pd = &amp;obj;</span><br><span class="line">	<span class="keyword">void</span>* pv = pd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*pd 的值为："</span> &lt;&lt; *pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "*pv 的值为：" &lt;&lt; *pv &lt;&lt; endl; // 错误，不能直接操作 void* 所指的对象，因为我们并不知道这个对象到底是什么类型</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*pd 的值为：<span class="number">3.14</span></span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br></pre></td></tr></table></figure>
<h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h2><p>2.1 void *常用在函数参数、函数返回值中需要兼容不同指针类型的地方。我们可以将别的类型的指针无需强制类型转换的赋值给void *类型，也可以将void *强制类型转换成任何别的指针类型，至于强转的类型是否合理，就需要我们程序员自己控制了。<br>请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, *p = &amp;a;</span><br><span class="line">    <span class="keyword">void</span> *q = p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2:"</span> &lt;&lt;  p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3:"</span> &lt;&lt;  q &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************************"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">void</span> *q1;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">3.0</span>, *p2 = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">":::::::"</span> &lt;&lt;  q1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">":::::::"</span> &lt;&lt;  *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">":::::::"</span> &lt;&lt;  p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p2 = (<span class="keyword">double</span> *)q1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4:"</span> &lt;&lt;  q1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5:"</span> &lt;&lt;  b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6:"</span> &lt;&lt;  p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"7:"</span> &lt;&lt;  *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="number">3</span></span><br><span class="line"><span class="number">2</span>:<span class="number">0x9b8f1ffbfc</span></span><br><span class="line"><span class="number">3</span>:<span class="number">0x9b8f1ffbfc</span></span><br><span class="line">***********************************</span><br><span class="line">:::::::<span class="number">0x8</span></span><br><span class="line">:::::::<span class="number">3</span></span><br><span class="line">:::::::<span class="number">0x9b8f1ffbf0</span></span><br><span class="line"><span class="number">4</span>:<span class="number">0x8</span></span><br><span class="line"><span class="number">5</span>:<span class="number">3</span></span><br><span class="line"><span class="number">6</span>:<span class="number">0x8</span></span><br><span class="line"><span class="number">7</span>:</span><br></pre></td></tr></table></figure>
<p>输出结果的第 11 行：因为 void * 类型指针 q1 被赋值给 double 类型指针 p2，因此 p2 此时的地址从<code>0x9b8f1ffbf0</code>变成<code>0x8</code>，该地址没有指向的对象，所以执行代码第 19 行报错，无输出。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>不知如何起标题的2022</title>
    <url>/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/</url>
    <content><![CDATA[<p>想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）<a id="more"></a></p>
<p>翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成，庆幸的是总还是有一点进展的，虽然只是一点点。</p>
<p>无论如何，还是认识了一些新朋友，新老师，还有新网友。从他们那里，学到了很多东西，说明走出去，多见见世面，总归是好的。学习上，上课、看论文、做实验，有条不紊。虽然没怎么用功，但还是获得了奖学金，还是很开心的。科研上，还没有什么实质性成果，但是研究方向和目标已经明确和清晰，接下来就是一步步向前迈进和解决问题。生活上，没什么特别高兴的事，但比起糟糕的2021年，已经是很大的进步了。</p>
<p>这么看，今年倒是不错的一年，但还是有很多遗憾。因为疫情，上半年一直在家上网课，下半年被封在学校，始终没能出去走走看看。马上2023年了，还是一个人，今晚的跨年又是一个人，什么时候我才能和那个她一起跨年啊？可笑~可笑~</p>
<p>3年的疫情终于迎来了转机，虽然我在放开后第一波就感染了，过程还很难受，好在很快就恢复了。身边越来越多的亲戚朋友都感染了，倒是没有听说有严重的，但是现实中肯定还是有很多重症。身处时代的漩涡中，作为普通人，我们无可奈何，只能尽力而为，保护好自己和所爱的人。</p>
<p>可是，阴霾总会过去的！我不是天生的乐观派，但我依旧相信希望，人总得有点希望。虽然这世间的一切本来不属于某个人，也终将不属于某个人。虽然我们可能经历苦难，面对疾病，遭遇挫折，背负谩骂，可是那又怎么样呢？宇宙那么大，我们何其渺小，就让我们做颗遥远恒星，隐约在茫茫天际，闪烁着微光足矣。</p>
<p>愿我所爱，万事胜意！愿爱我的人，永远幸福！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《热风·随感录四十一》</title>
    <url>/2021/01/04/%E3%80%8A%E7%83%AD%E9%A3%8E%C2%B7%E9%9A%8F%E6%84%9F%E5%BD%95%E5%9B%9B%E5%8D%81%E4%B8%80%E3%80%8B/</url>
    <content><![CDATA[<p>从一封匿名信里看见一句话，是“数麻石片”(原注江苏方言)，大约是没有本领便不必提倡改革，不如去数石片的好的意思。因此又记起了本志通信栏内所载四川方言的“洗煤炭”。想来别省方言中，相类的话还多；守着这专劝人自暴自弃的格言的人，也怕并不少。</p>
 <a id="more"></a>
<p>凡中国人说一句话，做一件事，倘与传来的积习有若干抵触，须一个斤斗便告成功，才有立足的处所；而且被恭维得烙铁一般热。否则免不了标新立异的罪名，不许说话；或者竟成了大逆不道，为天地所不容。这一种人，从前本可以夷到九族，连累邻居；现在却不过是几封匿名信罢了。但意志略略薄弱的人便不免因此萎缩，不知不觉的也入了“数麻石片”党。 </p>
<p>所以现在的中国，社会上毫无改革，学术上没有发明，美术上也没有创作；至于多人继续的研究，前仆后继的探险，那更不必提了。国人的事业，大抵是专谋时式的成功的经营，以及对于一切的冷笑。 </p>
<p>但冷笑的人，虽然反对改革，却又未必有保守的能力：即如文字一面，白话固然看不上眼，古文也不甚提得起笔。照他的学说，本该去“数麻石片”了；他却又不然，只是莫名其妙的冷笑。 </p>
<p>中国的人，大抵在如此空气里成功，在如此空气里萎缩腐败，以至老死。 </p>
<p>我想，人猿同源的学说，大约可以毫无疑义了。但我不懂，何以从前的古猴子，不都努力变人，却到现在还留着子孙，变把戏给人看。还是那时竟没有一匹想站起来学说人话呢?还是虽然有了几匹，却终被猴子社会攻击他标新立异，都咬死了；所以终于不能进化呢? </p>
<p>尼采式的超人，虽然太觉渺茫，但就世界观有人种的事实看来，却可以确信将来总有尤为高尚尤近圆满的人类出现。到那时候，类人猿上面，怕要添出“类猿人”这一个名词。 </p>
<p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。 </p>
<p>此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。 </p>
<p>我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。尼采说：“真的，人是一个浊流。应该是海了，能容这浊流使他干净。 </p>
<p>“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”(《札拉图如是说》的《序言》第三节)<br>　　<br>纵令不过一洼浅水，也可以学学大海；横坚都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。 </p>
<p>这还算不到“大侮蔑”——因为大侮蔑也须有胆力。</p>
<p>​                                                                                                                                                                                                                  ——鲁迅</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《小王子》语录</title>
    <url>/2022/05/03/%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E8%AF%AD%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li>也许世界上也有五千朵和你一模一样的花，但只有你是我独一无二的玫瑰。</li>
<li>当你真的喜欢一个人的时候，就会想很多，会很容易办蠢事，说傻话。</li>
<li>我始终认为一个人可以很天真简单的活下去，必是身边无数人，用更大的代价守护而来的。</li>
<li>If you want to  make a bond, you are to  take the risk of tearing.（如果你想要与别人制造羁绊，就要承担流泪的风险。）</li>
<li>爱就是，我想到你的时候，你是你，风吹麦浪是你，忽远忽近的脚步声是你，星星上的话也是你。</li>
<li>有一天，我看了四十四次日落。你知道的，人在难过的时候就会爱上看日落。</li>
<li>你在你的玫瑰花上耗费的时间，使得你的玫瑰花变得如此重要。</li>
<li>如果不去遍历世界，我们就不知道什么是我们精神和情感的寄托。但我们一旦遍历了世界，却发现我们再也无法回到那美好的地方去了。当我们开始寻求，我们就已经失去。而我们不开始寻求，我们根本无法知道这一切是如此可贵。</li>
<li>爱是能力，被爱亦是能力。</li>
<li>我和你的相遇，怎么说呢，就像是一颗耀眼的星星通亮了一片荒芜的小宇宙。</li>
<li>只有用心灵才能看得清事物本质，真正重要的东西是肉眼无法看见的。</li>
<li>星星发亮是为了让每一个人有一天都能找到属于自己的星星。</li>
<li>因为是心甘情愿地沉溺，即使死亡也无须被拯救。</li>
<li>所有的大人都曾经是小孩，虽然，只有少数人记得。</li>
<li>忘记朋友是一件令人伤心的事情，并不是人人都有朋友的。</li>
<li>你必须永远对自己所驯服的东西负责。</li>
<li>如果你驯养了我，我们就会彼此需要。对我来说，你就是我的世界里独一无二的了；我对你来说，也是你的世界里的唯一了。</li>
</ol>
<p><img src="/2022/05/03/%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E8%AF%AD%E5%BD%95/小王子.jpg" alt></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的实现及应用-改进1</title>
    <url>/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/</url>
    <content><![CDATA[<p>本文是对 <a href="https://crossoverpptx.github.io/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener"><strong>二叉树的实现及应用</strong></a> 的改进，源程序被拆分为四个子程序：Status.h（状态码头文件）、BiTree.h（二叉树数据结构及函数声明头文件）、BiTree.c（函数定义）、BiTree-main.c（主程序）。</p>
<a id="more"></a>
<hr>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Status.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STATUS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OVERFLOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW    -2  <span class="comment">//堆栈上溢</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BiTree.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BITREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树元素类型定义，这里假设其元素类型为char */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树结点定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    TElemType data;             <span class="comment">// 结点元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>;</span>     <span class="comment">// 左孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">rchild</span>;</span>     <span class="comment">// 右孩子指针</span></span><br><span class="line">&#125; BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向二叉树结点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BiTNode* BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************声明部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span>;		<span class="comment">//初始化，构造空二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span>;		<span class="comment">//若二叉树T为空，则返回TRUE，否则FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span>;		<span class="comment">//返回二叉树T的深度</span></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span>;			<span class="comment">//返回T的根</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span>;		<span class="comment">//按先序输入二叉树中结点的值（一个字符），‘#’字符表示空树</span></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span>;			<span class="comment">//对数据元素操作的应用函数</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;		<span class="comment">//先序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;		<span class="comment">//中序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;		<span class="comment">//后序递归遍历二叉树T的递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************函数部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        L = BiTreeDepth(T-&gt;lchild);</span><br><span class="line">        R = BiTreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span>(L &gt; R ? L:R)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">	<span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span>(!(*T))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\t"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">            <span class="keyword">if</span>(PreOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(PreOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(InOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                <span class="keyword">if</span>(InOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PostOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(PostOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BiTree-main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"InitBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始化空二叉树 T。\n"</span>);</span><br><span class="line">        InitBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CreateBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"按先序序列创建二叉树 T："</span>);</span><br><span class="line">        CreateBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PreOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树 T："</span>);</span><br><span class="line">        PreOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nInOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树 T："</span>);</span><br><span class="line">        InOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nPostOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树 T："</span>);</span><br><span class="line">        PostOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">InitBiTree</span><br><span class="line">初始化空二叉树 T。</span><br><span class="line">CreateBiTree</span><br><span class="line">按先序序列创建二叉树 T：ABD<span class="comment">###C#F##</span></span><br><span class="line">PreOrderTraverse</span><br><span class="line">前序遍历二叉树 T：A     B       D       C       F</span><br><span class="line">InOrderTraverse</span><br><span class="line">中序遍历二叉树 T：D     B       A       C       F</span><br><span class="line">PostOrderTraverse</span><br><span class="line">后序遍历二叉树 T：D     B       F       C       A</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>假如猫从世界上消失了</title>
    <url>/2020/07/14/%E5%81%87%E5%A6%82%E7%8C%AB%E4%BB%8E%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B6%88%E5%A4%B1%E4%BA%86/</url>
    <content><![CDATA[<p>假如猫从世界上消失了<br>那这个世界会有如何的变化呢<br>假如我从世界上消失了<br>那究竟会有谁为我悲伤呢<br>假如我从世界上消失了<br>那些未实现的梦想和思绪<br>那些在我存活时未能完成的事情<br>对此我一定会抱有许多遗憾吧<br>然而，这个世界我在与不在<br>相信一定会有所不同<br>也许真的只是些小小的不同<br>然而正是它们<br>是我存在过的证明<br>是我挣扎着，烦恼着，生活过的证明</p>
<p><img src="/2020/07/14/%E5%81%87%E5%A6%82%E7%8C%AB%E4%BB%8E%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B6%88%E5%A4%B1%E4%BA%86/假如猫从世界上消失了.jpg" alt></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>信仰</title>
    <url>/2020/12/29/%E4%BF%A1%E4%BB%B0/</url>
    <content><![CDATA[<p>在这个怀疑的时代，我们依然需要信仰。</p>
<p>无论中国怎样，请记得：</p>
<p>你所站立的地方，就是你的中国；</p>
<p>你怎么样，中国便怎么样；</p>
<p>你是什么，中国便是什么；</p>
<p>你有光明，中国便不再黑暗。</p>
<p>——摘自原北京日报评论部主任卢新宁《2012年北京大学中文系毕业典礼上的讲话》</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的实现及应用</title>
    <url>/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>本文记录二叉树的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li>
<li>采用C语言实现。</li>
</ul>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>)&#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraversal (T-&gt;lchild);</span><br><span class="line">        PreOrderTraversal (T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InOrderTraversal( T-&gt;lchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        InOrderTraversal( T-&gt;rchild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        PostOrderTraversal( T-&gt;lchild );</span><br><span class="line">        PostOrderTraversal( T-&gt;rchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create  Binary Tree:"</span>);</span><br><span class="line">	CreatBiTree(&amp;T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PreOrder:"</span>);</span><br><span class="line">	PreOrderTraversal(T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"InOrder:"</span>);</span><br><span class="line">	InOrderTraversal(T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PostOrder:"</span>);</span><br><span class="line">	PostOrderTraversal(T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Create  Binary Tree:ABD<span class="comment">###C#F##</span></span><br><span class="line"></span><br><span class="line">PreOrder:ABDCF</span><br><span class="line"></span><br><span class="line">InOrder:DBACF</span><br><span class="line"></span><br><span class="line">PostOrder:DBFCA</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶变换</title>
    <url>/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>在计算机视觉中，有一个经典的变换被广泛使用——傅里叶变换。傅里叶变换是将时间域上的信号转变为频率域上的信号，进而进行图像去噪、图像增强等处理。</p>
<a id="more"></a>
<h1 id="时域与频域"><a href="#时域与频域" class="headerlink" title="时域与频域"></a>时域与频域</h1><p>什么是时域（Time domain）？从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。</p>
<p>什么是频域（Frequency domain）？频域是描述信号在频率方面特性时用到的一种坐标系。用线性代数的语言就是装着正弦函数的空间。频域最重要的性质是：它不是真实的，而是一个数学构造。频域是一个遵循特定规则的数学范畴。正弦波是频域中唯一存在的波形，这是频域中最重要的规则，即正弦波是对频域的描述，因为时域中的任何波形都可用正弦波合成。</p>
<p>对于一个信号来说，信号强度随时间的变化规律就是时域特性，信号是由哪些单一频率的信号合成的就是频域特性。</p>
<p>时域分析与频域分析是对信号的两个观察面。时域分析是以时间轴为坐标表示动态信号的关系；频域分析是把信号变为以频率轴为坐标表示出来。一般来说，时域的表示较为形象与直观，频域分析则更为简练，剖析问题更为深刻和方便。目前，信号分析的趋势是从时域向频域发展。然而，它们是互相联系，缺一不可，相辅相成的。贯穿时域与频域的方法之一，就是传说中的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)。</p>
<h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><p>傅里叶级数是一种对周期信号进行分解的方式。</p>
<p>如下图所示，左上角为正弦方波，余下为通过不同的正弦谐波数可以去拟合这个方波结果。</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换01.jpg" alt></p>
<p>可以看到，叠加的谐波信号越多时，越接近于方波信号。</p>
<p>傅里叶级数由法国数学家傅里叶提出，即满足条件（狄利克雷条件）的任何周期函数可以由一系列不同频率的正弦（余弦）函数叠加而成。这种相加形式又称为级数，所以也称为傅里叶级数。</p>
<h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><p>那么对信号的不同频率进行分解有什么好处呢？</p>
<p>如下图所示，从时域上看，最下方叠加得到的信号是很难分析出里面蕴含的频率信息的。</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换02.jpg" alt></p>
<p>而通过傅里叶分解后，如下图右图所示，可以很容易地观察到频率的有无和幅度的大小（相位也有对应的相位谱，这里没有列出）。</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换03.jpg" alt></p>
<p>因此，通过傅里叶变换将某一信号分解为不同频率的信号，可以很容易地对信号中的某一段频段进行观察和操作。</p>
<h2 id="傅里叶变换分类"><a href="#傅里叶变换分类" class="headerlink" title="傅里叶变换分类"></a>傅里叶变换分类</h2><p>根据原信号的不同类型，我们可以把傅立叶变换分为四种类别：</p>
<ul>
<li>非周期性连续信号（傅立叶变换（Fourier Transform））</li>
<li>周期性连续信号（傅立叶级数(Fourier Series)）</li>
<li>非周期性离散信号（离散时域傅立叶变换（Discrete Time Fourier Transform））</li>
<li>周期性离散信号（离散傅立叶变换(Discrete Fourier Transform)）</li>
</ul>
<p>这四种傅立叶变换都是针对正无穷大和负无穷大的信号，即信号的的长度是无穷大的，我们知道这对于计算机处理来说是不可能的，那么有没有针对长度有限的傅立叶变换呢？没有。因为正余弦波被定义成从负无穷小到正无穷大，我们无法把一个长度无限的信号组合成长度有限的信号。</p>
<p>面对这种困难，方法是把长度有限的信号表示成长度无限的信号，可以把信号无限地从左右进行延伸，延伸的部分用零来表示，这样，这个信号就可以被看成是非周期性离散信号，我们就可以用到离散时域傅立叶变换的方法。还有，也可以把信号用复制的方法进行延伸，这样信号就变成了周期性离散信号，这时我们就可以用离散傅立叶变换方法进行变换。</p>
<p>但是对于非周期性的信号，我们需要用无穷多不同频率的正弦曲线来表示，这对于计算机来说是不可能实现的，因为在计算机中只有离散的和有限长度的数据才能被处理。所以对于离散信号的变换只有离散傅立叶变换（DFT）才能被适用，对于其它的变换类型只有在数学演算中才能用到，在计算机中我们只能用DFT方法。</p>
<h2 id="一维傅里叶公式"><a href="#一维傅里叶公式" class="headerlink" title="一维傅里叶公式"></a>一维傅里叶公式</h2><p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换04.jpg" alt></p>
<p>其中，ω 表示频率, t 表示时间, 它将频率域的函数表示为时间域函数 f(t) 的积分。</p>
<h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>我们知道，灰度图像是由二维的离散的点构成的。二维离散傅里叶变换（Two-Dimensional Discrete Fourier Transform）常用于图像处理中，对图像进行傅里叶变换后得到其频谱图。频谱图中频率高低表征图像中灰度变化的剧烈程度。图像中边缘和噪声往往是高频信号，而图像背景往往是低频信号。我们在频率域内可以很方便地对图像的高频或低频信息进行操作，完成图像去噪，图像增强，图像边缘提取等操作。</p>
<p>对二维图像进行傅里叶变换公式如下：</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换05.jpg" alt></p>
<p>其中，图像长 M，高 N。F(u,v)表示频域图像，f(x,y)表示时域图像。u 的范围为[0,M-1]，v 的范围为[0,N-1]。</p>
<p> 对二维图像进行傅里叶逆变换公式如下：</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换06.jpg" alt></p>
<p>其中，图像长 M，高 N。f(x,y)表示时域图像，F(u,v)表示频域图像。x 的范围为[0,M-1]，y 的范围为[0,N-1]。</p>
<h1 id="OpenCV中傅里叶变换的应用"><a href="#OpenCV中傅里叶变换的应用" class="headerlink" title="OpenCV中傅里叶变换的应用"></a>OpenCV中傅里叶变换的应用</h1><h2 id="傅里叶变换-1"><a href="#傅里叶变换-1" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将频谱低频从左上角移动至中心位置</span></span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 频谱图像双通道复数转换为0-255区间</span></span><br><span class="line">result = <span class="number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Original Image'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(result, cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Magnitude Spectrum'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换07.jpg" alt></p>
<h2 id="傅里叶逆变换"><a href="#傅里叶逆变换" class="headerlink" title="傅里叶逆变换"></a>傅里叶逆变换</h2><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(np.float32(img), flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dftshift = np.fft.fftshift(dft)</span><br><span class="line">res1= <span class="number">20</span>*np.log(cv2.magnitude(dftshift[:,:,<span class="number">0</span>], dftshift[:,:,<span class="number">1</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 傅里叶逆变换</span></span><br><span class="line">ishift = np.fft.ifftshift(dftshift)</span><br><span class="line">iimg = cv2.idft(ishift)</span><br><span class="line">res2 = cv2.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">131</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'Original Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>), plt.imshow(res1, <span class="string">'gray'</span>), plt.title(<span class="string">'Fourier Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>), plt.imshow(res2, <span class="string">'gray'</span>), plt.title(<span class="string">'Inverse Fourier Image'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2022/08/16/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/傅里叶变换08.jpg" alt></p>
<h1 id="源码仓库地址"><a href="#源码仓库地址" class="headerlink" title="源码仓库地址"></a>源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>初见辽东</title>
    <url>/2022/09/29/%E5%88%9D%E8%A7%81%E4%B8%B9%E4%B8%9C/</url>
    <content><![CDATA[<p>时隔整整9个月，再一次来到学校，不过和上次不同的是，学校不在沈阳，而在丹东。作为学校和丹东首批的联合培养学生，刚被录取时得知这个消息我是有点担心的，感觉就像是“被抛弃了”。不过，后来我慢慢发现，这未尝不是一次不一样的人生旅程，毕竟到哪都是学习。</p>
<p>于是，我怀着一丝憧憬，当然还有半分担忧（科研？论文？），踏上了开往丹东的动车。一个半小时的动车很快，中间我还小睡了一会。刚出站就看到了学校的迎新队伍，于是作为一个“新生”，混在了开往学校的大巴里。一切都很顺利，被志愿者领着来到宿舍，环境比想象的好得多，另一个室友还没来，现在是一个人独占两人寝。</p>
<p>时间很快，转眼已是研二，一年半的联培时间相信也很快，我必须抓紧起来，学习，科研，还有生活。人们总是在熟悉了某个环境后就安于现状，或者说“被迫”安于现状。所以，我们必须时常审视自身，把眼光放长远，这样才不会落入时间的陷阱。</p>
<p>人生就是一场奇遇，我永远也不曾想过会来到这样的边境城市，一个距离我的家乡几千公里的地方。可是这样的事情偏偏发生了，这就是命运吧！在这里，我还会遇到各种各样的人，发生各种各样的事，也许两三年后离开东北，我再也不会踏足这片土地，但我一定会记得我曾经在这里生活过，记得初见这里时的画面。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>图像二值化</title>
    <url>/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-图像二值化"><a href="#1-图像二值化" class="headerlink" title="1. 图像二值化"></a>1. 图像二值化</h1><p>图像二值化就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。</p>
<p>要得到二值化图像，首先要把图像灰度化，然后将256个亮度等级的灰度图像通过适当的阈值选取而获得仍然可以反映图像整体和局部特征的二值化图像。所有灰度大于或等于阈值的像素被判定为属于特定物体，其灰度值为255，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。</p>
<a id="more"></a>
<h1 id="2-图像二值化方法及Python实现"><a href="#2-图像二值化方法及Python实现" class="headerlink" title="2. 图像二值化方法及Python实现"></a>2. 图像二值化方法及Python实现</h1><p>比较常用的二值化方法有：简单二值法，平均值法，双峰法和OTSU法等。</p>
<h2 id="2-1-简单二值法"><a href="#2-1-简单二值法" class="headerlink" title="2.1 简单二值法"></a>2.1 简单二值法</h2><p>将图像灰度化后，我们选择127(灰度值范围的一半)作为阈值，即将像素值大于127的像素值全部设为255，小于127的全部设为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Easy_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    img_gray[img_gray&gt;<span class="number">127</span>] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=<span class="number">127</span>] = <span class="number">0</span></span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Easy_Binarization'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.1.png" alt></p>
<h2 id="2-2-平均值法"><a href="#2-2-平均值法" class="headerlink" title="2.2 平均值法"></a>2.2 平均值法</h2><p>为了应对每张图片的灰度值大不相同，阈值取为图像本身的平均值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mean_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    threshold = np.mean(img_gray)</span><br><span class="line">    print(threshold)</span><br><span class="line">    img_gray[img_gray&gt;threshold] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=threshold] = <span class="number">0</span></span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Mean_Binarization'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.2.png" alt></p>
<p>实验中该方法计算的阈值为123。</p>
<h2 id="2-3-双峰法"><a href="#2-3-双峰法" class="headerlink" title="2.3 双峰法"></a>2.3 双峰法</h2><p>直方图是图像的重要特质，它可以帮助我们分析图像中的灰度变化。因此，如果物体与背景的灰度值对比明显，直方图就会包含双峰，它们分别为图像的前景和背景，而它们之间的谷底即为边缘附近相对较少数目的像素点，一般来讲，这个最小值就为最优二值化的分界点，通过这个点可以把前景和背景很好地分开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hist_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    hist = img_gray.flatten()</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.hist(hist,<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    cnt_hist = Counter(hist)</span><br><span class="line">    print(cnt_hist)</span><br><span class="line">    begin,end = cnt_hist.most_common(<span class="number">2</span>)[<span class="number">0</span>][<span class="number">0</span>],cnt_hist.most_common(<span class="number">2</span>)[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> begin &gt; end:</span><br><span class="line">        begin, end = end, begin</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;begin&#125;</span>: <span class="subst">&#123;end&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    cnt = np.iinfo(np.int16).max</span><br><span class="line">    threshold = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin,end+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> cnt_hist[i]&lt;cnt:</span><br><span class="line">            cnt = cnt_hist[i]</span><br><span class="line">            threshold = i</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;threshold&#125;</span>: <span class="subst">&#123;cnt&#125;</span>'</span>)</span><br><span class="line">    img_gray[img_gray&gt;threshold] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=threshold] = <span class="number">0</span></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.3.png" alt></p>
<p>实验中该方法得到的双峰为(145,154)，阈值为150。</p>
<h2 id="2-4-OTSU法"><a href="#2-4-OTSU法" class="headerlink" title="2.4 OTSU法"></a>2.4 OTSU法</h2><p>双峰法具有明显的缺陷，因为直方图是不连续的，有非常多尖峰和抖动，要找到准确的极值点十分困难。日本工程师大津展之为这个波谷找到了一个合适的数学表达，并于1979年发表。这个二值化方法称为大津算法（Otsu’s method）。</p>
<p>OTSU法也称作最大类间方差法，因为按照大津法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大。它被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致类间差别变小。因此,使类间方差最大的分割意味着错分概率最小。</p>
<p>具体计算阈值方法如下：<br>设阈值为t, 将原图转化成灰度图后，将其高与宽存于h,w，并将小于阈值的灰度值存储在前景front中，大于等于阈值的存在背景back中。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 阈值：t</span></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">front = img[img &lt; t]</span><br><span class="line">back = img[img &gt;= t]</span><br></pre></td></tr></table></figure>
<p> 显然，前景与背景的长度和应与h, w的乘积相等，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">len(front) + len(back) == h * w.</span><br></pre></td></tr></table></figure>
<p>设前景像素数量占总像素数量的比重为frontP，背景像素数量占总像素数量的比重为backP，前景和背景的灰度平均值分别为frontMean和backMean，总平均灰度值为m，则方差公式可写成：</p>
<script type="math/tex; mode=display">
v=frontP*(frontMean-m)^2+backP*(backMean-m)^2</script><p>又因为：</p>
<script type="math/tex; mode=display">
m=frontP*frontMean+backP*backMean</script><p>上式可化简为：</p>
<script type="math/tex; mode=display">
v=frontP*backP*(frontMean-backMean)^2</script><p>实验代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Otsu</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    threshold_t = <span class="number">0</span></span><br><span class="line">    max_g = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">        front = img[img &lt; t]</span><br><span class="line">        back = img[img &gt;= t]</span><br><span class="line">        front_p = len(front) / (h * w)</span><br><span class="line">        back_p = len(back) / (h * w)</span><br><span class="line">        front_mean = np.mean(front) <span class="keyword">if</span> len(front) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.</span></span><br><span class="line">        back_mean = np.mean(back) <span class="keyword">if</span> len(back) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.</span></span><br><span class="line">        </span><br><span class="line">        g = front_p * back_p * ((front_mean - back_mean)**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> g &gt; max_g:</span><br><span class="line">            max_g = g</span><br><span class="line">            threshold_t = t</span><br><span class="line">    print(<span class="string">f"threshold = <span class="subst">&#123;threshold_t&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    img[img &lt; threshold_t] = <span class="number">0</span></span><br><span class="line">    img[img &gt;= threshold_t] = <span class="number">255</span></span><br><span class="line">    plt.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Otsu'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>二值化图像如下：</p>
<p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.4.png" alt></p>
<p><strong>对比以上四种方法可以发现，Otsu方法得到的二值化图像细节更多，图像更细腻。</strong></p>
<h1 id="3-opencv-python中二值化方法的应用"><a href="#3-opencv-python中二值化方法的应用" class="headerlink" title="3. opencv-python中二值化方法的应用"></a>3. opencv-python中二值化方法的应用</h1><p>在OpenCV中，分为简单的阈值分割与自适应阈值分割。</p>
<h2 id="3-1-简单阈值分割（Simple-Thresholding）"><a href="#3-1-简单阈值分割（Simple-Thresholding）" class="headerlink" title="3.1 简单阈值分割（Simple Thresholding）"></a>3.1 简单阈值分割（Simple Thresholding）</h2><p>函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">retval, dst = cv.threshold(src, thresh, maxval, type[, dst])</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一个参数src为原图，需要注意的是输入的图像需为灰度图。</span><br><span class="line">第二个参数thresh即为阈值，用于对像素值的分类(一般定义为<span class="number">127</span>)。</span><br><span class="line">第三个参数maxval是最大值，即超过阈值后所定义的值(<span class="number">255</span>)。</span><br><span class="line">第四个参数type，在Simple Thresholding中一共有五种不同的方式：</span><br><span class="line">cv.THRESH_BINARY</span><br><span class="line">cv.THRESH_BINARY_INV</span><br><span class="line">cv.THRESH_TRUNC</span><br><span class="line">cv.THRESH_TOZERO</span><br><span class="line">cv.THRESH_TOZERO_INV</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)</span><br><span class="line">ret,thresh1 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>下图是5种方式的实际效果：</p>
<p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/3.1.png" alt></p>
<h2 id="3-2-自适应阈值分割（Adaptive-Thresholding）"><a href="#3-2-自适应阈值分割（Adaptive-Thresholding）" class="headerlink" title="3.2 自适应阈值分割（Adaptive Thresholding）"></a>3.2 自适应阈值分割（Adaptive Thresholding）</h2><p>函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])</span><br></pre></td></tr></table></figure>
<p>其中src, maxValue和thresholdType与Simple Thresholding相同。</p>
<p>在自适应阈值分割中，adaptive method(阈值的计算方式)有两种：<br>cv.ADAPTIVE_THRESH_MEAN_C: 邻域面积(blockSize * blockSize)的平均值并减去C.<br>cv.ADAPTIVE_THRESH_GAUSSIAN_C: 邻域面积的高斯加权总和然后减去C.</p>
<p>下面是它们的实际效果(对于thresholdType在这里选择cv.THRESH_BINARY），测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)</span><br><span class="line">ret,th1 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,\</span><br><span class="line">            cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,\</span><br><span class="line">            cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>, <span class="string">'Simple Thresholding'</span>,</span><br><span class="line">            <span class="string">'Adaptive Mean Thresholding'</span>, <span class="string">'Adaptive Gaussian Thresholding'</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/3.2.png" alt></p>
<p>发现没有像之前otsu那样输出一张类似的图片，但是，它将图像中的边框描绘了出来，实际应用中这样的方式更适合处理文字形式的图片。</p>
<h1 id="4-源码仓库地址"><a href="#4-源码仓库地址" class="headerlink" title="4. 源码仓库地址"></a>4. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像归一化</title>
    <url>/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-图像归一化"><a href="#1-图像归一化" class="headerlink" title="1. 图像归一化"></a>1. 图像归一化</h2><p>图像归一化是指对图像进行了一系列标准的处理变换，使之变换为一固定标准形式的过程，该标准图像称作归一化图像。</p>
<p>在机器学习中，不同评价指标（即特征向量中的不同特征，就是所述的不同评价指标）往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果。为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。其中，最典型的就是数据的归一化处理。简而言之，归一化的目的就是使得预处理的数据被限定在一定的范围内（比如[0,1]或者[-1,1]），从而消除奇异样本数据导致的不良影响。</p>
<p>在深度学习中，通常在模型训练前都会对图像进行归一化处理，而对图像进行归一化处理是将特征值大小调整到相近的范围，不归一化处理时，如果特征值较大时，梯度值也会较大，特征值较小时，梯度值也会较小。在模型反向传播时，梯度值更新与学习率一样，当学习率较小时，梯度值较小会导致更新缓慢，当学习率较大时，梯度值较大会导致模型不易收敛，因此为了使模型训练收敛平稳，对图像进行归一化操作，把不同维度的特征值调整到相近的范围内，就可以采用统一的学习率加速模型训练。<a id="more"></a></p>
<h2 id="2-图像归一化的常用方法及Python应用"><a href="#2-图像归一化的常用方法及Python应用" class="headerlink" title="2. 图像归一化的常用方法及Python应用"></a>2. 图像归一化的常用方法及Python应用</h2><h3 id="2-1-Min-Max归一化"><a href="#2-1-Min-Max归一化" class="headerlink" title="2.1 Min-Max归一化"></a>2.1 Min-Max归一化</h3><p>通过遍历图像矩阵中的每一个像素，设定max和min，进行数据的归一化处理，公式如下：</p>
<script type="math/tex; mode=display">
x'=(x-min⁡(x))/(max⁡(x)-min⁡(x))</script><p>（1）线性函数将原始数据用线性化的方法转换到[0,1]的范围，计算结果x’为归一化后的数据，x为原始数据。（2）Min-Max归一化方法比较适用在数值比较集中的情况。<br>（3）缺点：如果max和min不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。实际使用中可以用经验常量来替代max和min。</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">mn = np.min(gray)</span><br><span class="line">mx = np.max(gray)</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">       norm[i,j] = (gray[i,j] - mn) / (mx - mn)</span><br><span class="line">       <span class="comment">#norm[i,j] = gray[i,j] / 255</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>归一化前后灰度图像矩阵如下所示：</p>
<p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-1.png" alt></p>
<p>归一化前后灰度图像对比如下所示：</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-2.png" alt></p>
<h3 id="2-2-z-score标准化"><a href="#2-2-z-score标准化" class="headerlink" title="2.2 z-score标准化"></a>2.2 z-score标准化</h3><p>z-score标准化公式如下：</p>
<script type="math/tex; mode=display">
x'=(x-μ)/σ</script><p>其中，μ、σ分别为原始数据集的均值和方法。<br>（1）将原始数据集归一化为均值为0、方差1的数据集。<br>（2）该种归一化方式要求原始数据的分布可以近似为高斯分布，否则归一化的效果会变得很糟糕。<br>（3）应用场景：在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，z-score standardization表现更好。</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">x_mean = np.mean(gray)</span><br><span class="line">vari = np.sqrt((np.sum((gray-x_mean)**<span class="number">2</span>))/(h*w))</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">       norm[i,j] = (gray[i,j] - x_mean) / vari</span><br><span class="line">       <span class="comment">#norm[i,j] = gray[i,j] / 127.5 - 1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>归一化前后灰度图像矩阵如下所示：</p>
<p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-3.png" alt></p>
<p>归一化前后灰度图像对比如下所示：</p>
<p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-4.png" alt></p>
<h3 id="2-3-神经网络归一化"><a href="#2-3-神经网络归一化" class="headerlink" title="2.3 神经网络归一化"></a>2.3 神经网络归一化</h3><p>该归一化方法经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括log，反正切等，需要根据数据分布的情况，决定非线性函数的曲线。</p>
<h4 id="2-3-1-log对数函数归一化"><a href="#2-3-1-log对数函数归一化" class="headerlink" title="2.3.1 log对数函数归一化"></a>2.3.1 log对数函数归一化</h4><p>y = log10(x)，即以10为底的对数转换函数，对应的归一化方法为：</p>
<script type="math/tex; mode=display">
x' = log10(x)/log10(max)</script><p>其中max表示样本数据的最大值，并且所有样本数据均要大于等于1。</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line">norm = np.log10(gray) / np.log10(gray.max())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>归一化前后灰度图像矩阵如下所示：</p>
<p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-5.png" alt></p>
<p>归一化前后灰度图像对比如下所示：</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-6.png" alt></p>
<h4 id="2-3-2-反正切函数归一化"><a href="#2-3-2-反正切函数归一化" class="headerlink" title="2.3.2 反正切函数归一化"></a>2.3.2 反正切函数归一化</h4><p>对应的归一化方法为：x’ = atan(x)*(2/pi)</p>
<p>使用这个方法需要注意的是如果想映射的区间为[0,1]，则数据都应该大于等于0，小于0的数据将被映射到[－1,0]区间上。</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line">norm = np.arctan(gray) * (<span class="number">2</span> / np.pi)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>归一化前后灰度图像矩阵如下所示：</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-7.png" alt></p>
<p>归一化前后灰度图像对比如下所示：</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-8.png" alt></p>
<h3 id="2-4-L2范数归一化"><a href="#2-4-L2范数归一化" class="headerlink" title="2.4 L2范数归一化"></a>2.4 L2范数归一化</h3><p>定义：特征向量中每个元素均除以向量的范数，即如下公式：</p>
<script type="math/tex; mode=display">
x_i'=x_i/(norm(x))</script><p>向量x(x1,x2,…,xn)的L2范数定义为：</p>
<script type="math/tex; mode=display">
norm(x)=\sqrt(x_1^2+x_2^2+⋯+x_n^2)</script><p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">       norm_x = <span class="number">0.0</span> + gray[i,j]**<span class="number">2</span></span><br><span class="line">norm_x = np.sqrt(norm_x)</span><br><span class="line">norm = gray / norm_x</span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>归一化前后灰度图像矩阵如下所示：</p>
<p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-9.png" alt></p>
<p>归一化前后灰度图像对比如下所示：</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-10.png" alt></p>
<h2 id="3-opencv-python中归一化方法的应用"><a href="#3-opencv-python中归一化方法的应用" class="headerlink" title="3. opencv-python中归一化方法的应用"></a>3. opencv-python中归一化方法的应用</h2><p>opencv-python中使用cv2.normalize()函数实现归一化，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.normalize(src[, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]]) → dst</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>src：输入数组；<br>dst：输出数组，数组的大小和原数组一致；<br>alpha：1.用来规范值。2.规范范围，并且是下限；<br>beta：只用来规范范围并且是上限；<br>norm_type：归一化选择的数学公式类型；<br>dtype：当为负，输出在大小深度通道数都等于输入，当为正，输出只在深度与输入不同，不同的地方由dtype决定；<br>mark：掩码。选择感兴趣区域，选定后只能对该区域进行操作。</p>
<p>归一化选择的数学公式类型有如下几种：<br>NORM_MINMAX：数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用；<br>NORM_INF：矩阵中绝对值的最大值；<br>NORM_L1：归一化数组的L1-范数(绝对值的和)；<br>NORM_L2：归一化数组的(欧几里德)L2-范数。</p>
<p>测试代码如下（以NORM_MINMAX为例）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">h,w = gray.shape</span><br><span class="line">norm = np.zeros((h,w),dtype=np.float32) <span class="comment"># 自定义空白单通道图像，用于存放归一化图像</span></span><br><span class="line">cv.normalize(gray, norm, alpha=<span class="number">0</span>, beta=<span class="number">1</span>, norm_type=cv.NORM_MINMAX, dtype=cv.CV_32F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># norm = np.uint8(norm*255.0)</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'归一化前：'</span>)</span><br><span class="line">print(gray)</span><br><span class="line">print(<span class="string">'归一化后：'</span>)</span><br><span class="line">print(norm)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'gray'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(norm, <span class="string">'gray'</span>), plt.title(<span class="string">'normalization'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>归一化前后灰度图像矩阵如下所示，可以发现与2.1节Min-Max归一化处理结果一致：</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-11.png" alt></p>
<p>归一化前后灰度图像对比如下所示：</p>
<p> <img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E5%BD%92%E4%B8%80%E5%8C%96/2-12.png" alt></p>
<h2 id="4-源码仓库地址"><a href="#4-源码仓库地址" class="headerlink" title="4. 源码仓库地址"></a>4. 源码仓库地址</h2><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像滤波</title>
    <url>/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="1-图像滤波"><a href="#1-图像滤波" class="headerlink" title="1. 图像滤波"></a>1. 图像滤波</h1><p>图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</p>
<p>图像滤波按图像域可分为两种类型：</p>
<p>邻域滤波(Spatial Domain Filter)，其本质是数字窗口上的数学运算。一般用于图像平滑、图像锐化、特征提取(如纹理测量、边缘检测)等，邻域滤波使用邻域算子——利用给定像素周围像素值以决定此像素最终输出的一种算子。邻域滤波方式又分为线性滤波和非线性滤波，其中线性滤波包括均值滤波、方框滤波和高斯滤波等，非线性滤波包括中值滤波和双边滤波等。</p>
<p>频域滤波(Frequency Domain Filter)，其本质是对像素频率的修改。一般用于降噪、重采样、图像压缩等。按图像频率滤除效果主要分为两种类型：低通滤波（滤除原图像的高频成分，即模糊图像边缘与细节）和高通滤波（滤除原图像的低频成分，即图像锐化）。</p>
<a id="more"></a>
<h1 id="2-图像滤波的常用方法"><a href="#2-图像滤波的常用方法" class="headerlink" title="2. 图像滤波的常用方法"></a>2. 图像滤波的常用方法</h1><h2 id="2-1-均值滤波"><a href="#2-1-均值滤波" class="headerlink" title="2.1 均值滤波"></a>2.1 均值滤波</h2><p>均值滤波采用多次测量取平均值的思想，用每一个像素周围的像素的平均值代替自身。均值滤波是方框滤波归一化后的特殊情况。</p>
<p>取卷积核（Kernel）区域下所有像素的平均值并替换中心元素，如下公式：</p>
<p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.1.png" alt></p>
<p>优点：能够将受到噪声影响的像素使用该噪声周围的像素值进行修复，对椒盐噪声的滤除比较好。<br>缺点：不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊。</p>
<h2 id="2-2-方框滤波"><a href="#2-2-方框滤波" class="headerlink" title="2.2 方框滤波"></a>2.2 方框滤波</h2><p>与均值滤波不同的是，方框滤波不会计算像素的均值。在均值滤波中，滤波结果的像素值是任意一个点的邻域平均值，等于各邻域像素值之和除以邻域面积。而在方框滤波中，可以自由选择是否对均值滤波的结果进行归一化，即可以自由选择滤波结果是邻域像素值之和的平均值，还是邻域像素值之和。</p>
<p>公式如下：</p>
<p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.2.png" alt></p>
<p>当normalize=True时，与均值滤波结果相同；<br>当normalize=False时，表示对加和后的结果不进行平均操作，大于255的使用255表示。</p>
<h2 id="2-3-高斯滤波"><a href="#2-3-高斯滤波" class="headerlink" title="2.3 高斯滤波"></a>2.3 高斯滤波</h2><p>高斯滤波(Gauss Filter)基于二维高斯核函数。用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。高斯滤波主要用来去除高斯噪声。</p>
<p>高斯滤波具有在保持细节的条件下进行噪声滤波的能力，因此广泛应用于图像降噪中，但其效率比均值滤波低。</p>
<h2 id="2-4-中值滤波"><a href="#2-4-中值滤波" class="headerlink" title="2.4 中值滤波"></a>2.4 中值滤波</h2><p>中值滤波将待处理的像素周围像素从小到大排序，取中值代替该像素。</p>
<p>优点：去除脉冲噪声、椒盐噪声的同时又能保留图像边缘细节。<br>缺点：当卷积核较大时，仍然使得图像变得模糊，而且计算量很大。</p>
<h2 id="2-5-双边滤波"><a href="#2-5-双边滤波" class="headerlink" title="2.5 双边滤波"></a>2.5 双边滤波</h2><p>因为高斯滤波把距离设为权重，设计滤波模板作为滤波系数，并且只考虑像素之间的空间位置关系，所以滤波结果丢失了边缘信息。</p>
<p>双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。</p>
<h2 id="2-6-低通滤波"><a href="#2-6-低通滤波" class="headerlink" title="2.6 低通滤波"></a>2.6 低通滤波</h2><p>规则为低频信息能正常通过，而超过设定临界值的高频信息则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序（目的）而改变。</p>
<p>低通滤波，通过了低频信息，保留了图像背景和基本内容，图像边缘被阻挡，图像变模糊。</p>
<h2 id="2-7-高通滤波"><a href="#2-7-高通滤波" class="headerlink" title="2.7 高通滤波"></a>2.7 高通滤波</h2><p>规则为高频信息能正常通过，而低于设定临界值的低频信息则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序(目的)而改变。</p>
<p>高通滤波，通过了高频信息，提取了图像边缘和噪声。</p>
<h1 id="3-opencv-python中各种滤波方法的应用"><a href="#3-opencv-python中各种滤波方法的应用" class="headerlink" title="3. opencv-python中各种滤波方法的应用"></a>3. opencv-python中各种滤波方法的应用</h1><p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line">img_blur = cv.blur(img, (<span class="number">3</span>,<span class="number">3</span>)) <span class="comment"># (3,3)代表卷积核尺寸，随着尺寸变大，图像会越来越模糊</span></span><br><span class="line">img_blur = cv.cvtColor(img_blur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方框滤波</span></span><br><span class="line">img_boxFilter1 = cv.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>,<span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment"># 当 normalize=True 时，与均值滤波结果相同</span></span><br><span class="line">img_boxFilter1 = cv.cvtColor(img_boxFilter1, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line">img_boxFilter2 = cv.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>,<span class="number">3</span>), normalize=<span class="literal">False</span>)</span><br><span class="line">img_boxFilter2 = cv.cvtColor(img_boxFilter2, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line">img_GaussianBlur= cv.GaussianBlur(img, (<span class="number">3</span>,<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 参数说明：(源图像，核大小，x方向的标准差，y方向的标准差)</span></span><br><span class="line">img_GaussianBlur = cv.cvtColor(img_GaussianBlur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line">img_medianBlur = cv.medianBlur(img, <span class="number">3</span>)</span><br><span class="line">img_medianBlur = cv.cvtColor(img_medianBlur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双边滤波</span></span><br><span class="line"><span class="comment"># 参数说明：(源图像，核大小，sigmaColor，sigmaSpace)</span></span><br><span class="line">img_bilateralFilter=cv.bilateralFilter(img, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">img_bilateralFilter = cv.cvtColor(img_bilateralFilter, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'img_blur'</span>, <span class="string">'img_boxFilter1'</span>, <span class="string">'img_boxFilter2'</span>,</span><br><span class="line">          <span class="string">'img_GaussianBlur'</span>, <span class="string">'img_medianBlur'</span>, <span class="string">'img_bilateralFilter'</span>]</span><br><span class="line">images = [img_blur, img_boxFilter1, img_boxFilter2, img_GaussianBlur, img_medianBlur, img_bilateralFilter]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i+<span class="number">1</span>), plt.imshow(images[i]), plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通滤波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Low_Pass_Filter</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    <span class="comment">#img = cv.imread('srcImg_path', 0)</span></span><br><span class="line">    img = np.array(Image.open(srcImg_path))</span><br><span class="line">    img = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶变换</span></span><br><span class="line">    dft = cv.dft(np.float32(img), flags = cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    fshift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置低通滤波器</span></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment"># 中心位置</span></span><br><span class="line">    mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 掩膜图像和频谱图像乘积</span></span><br><span class="line">    f = fshift * mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶逆变换</span></span><br><span class="line">    ishift = np.fft.ifftshift(f)</span><br><span class="line">    iimg = cv.idft(ishift)</span><br><span class="line">    res = cv.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">High_Pass_Filter</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    <span class="comment">#img = cv.imread(srcImg_path, 0)</span></span><br><span class="line">    img = np.array(Image.open(srcImg_path))</span><br><span class="line">    img = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶变换</span></span><br><span class="line">    dft = cv.dft(np.float32(img), flags = cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    fshift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置高通滤波器</span></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment"># 中心位置</span></span><br><span class="line">    mask = np.ones((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 掩膜图像和频谱图像乘积</span></span><br><span class="line">    f = fshift * mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶逆变换</span></span><br><span class="line">    ishift = np.fft.ifftshift(f)</span><br><span class="line">    iimg = cv.idft(ishift)</span><br><span class="line">    res = cv.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">img_Low_Pass_Filter = Low_Pass_Filter(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img_Low_Pass_Filter, <span class="string">'gray'</span>), plt.title(<span class="string">'img_Low_Pass_Filter'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">img_High_Pass_Filter = High_Pass_Filter(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(img_High_Pass_Filter, <span class="string">'gray'</span>), plt.title(<span class="string">'img_High_Pass_Filter'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>滤波图像如下：</p>
<p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.8.1.png" alt></p>
<p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.8.2.png" alt></p>
<h1 id="4-源码仓库地址"><a href="#4-源码仓库地址" class="headerlink" title="4. 源码仓库地址"></a>4. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像灰度化处理</title>
    <url>/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-图像灰度化"><a href="#1-图像灰度化" class="headerlink" title="1. 图像灰度化"></a>1. 图像灰度化</h1><p>在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255，当灰度为255的时候，表示最亮（纯白）；当灰度为0的时候，表示最暗（纯黑）。</p>
<p>灰度化的好处是：相较于彩色图像灰度图像占内存更小，运行速度更快；灰度图像后可以在视觉上增加对比，突出目标区域。</p>
<a id="more"></a>
<h1 id="2-图像灰度化处理方法"><a href="#2-图像灰度化处理方法" class="headerlink" title="2. 图像灰度化处理方法"></a>2. 图像灰度化处理方法</h1><p>图像灰度化处理有三种常用方法：最大值法、平均值法和加权平均法。</p>
<h2 id="2-1-最大值法"><a href="#2-1-最大值法" class="headerlink" title="2.1 最大值法"></a>2.1 最大值法</h2><p>最大值法，即直接取R,B,G三个分量中数值最大的分量的数值（0视为最小，255视为最大）。公式为：R=G=B=max(R,G,B)。</p>
<h2 id="2-2-平均值法"><a href="#2-2-平均值法" class="headerlink" title="2.2 平均值法"></a>2.2 平均值法</h2><p>平均值法，即取R,B,G三个分量中数值的均值。公式为：R=G=B=(R+G+B)/3。</p>
<h2 id="2-3-加权平均法"><a href="#2-3-加权平均法" class="headerlink" title="2.3 加权平均法"></a>2.3 加权平均法</h2><p>根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度图像：</p>
<script type="math/tex; mode=display">
Gray(i,j)=0.299*R(i,j)+0.578*G(i,j)+0.114*B(i,j)</script><h1 id="3-图像灰度化处理方法的Python实现"><a href="#3-图像灰度化处理方法的Python实现" class="headerlink" title="3. 图像灰度化处理方法的Python实现"></a>3. 图像灰度化处理方法的Python实现</h1><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">'lenna.png'</span>)</span><br><span class="line">img1 = cv.cvtColor(img, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(<span class="string">'Src_img'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>图像如下：</p>
<p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.0.1.png" alt></p>
<h2 id="3-1-最大值法"><a href="#3-1-最大值法" class="headerlink" title="3.1 最大值法"></a>3.1 最大值法</h2><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Max_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = max(img[i,j,<span class="number">0</span>],img[i,j,<span class="number">1</span>],img[i,j,<span class="number">2</span>]) <span class="comment"># 求3通道中最大值</span></span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'Max_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>图像如下：</p>
<p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.1.1.png" alt></p>
<h2 id="3-2-平均值法"><a href="#3-2-平均值法" class="headerlink" title="3.2 平均值法"></a>3.2 平均值法</h2><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Avrage_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = (int(img[i,j,<span class="number">0</span>])+int(img[i,j,<span class="number">1</span>])+int(img[i,j,<span class="number">2</span>]))/<span class="number">3</span> <span class="comment"># 求3通道像素的平均值作为灰度值</span></span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'Avrage_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>图像如下：</p>
<p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.2.1.png" alt></p>
<h2 id="3-3-加权平均法"><a href="#3-3-加权平均法" class="headerlink" title="3.3 加权平均法"></a>3.3 加权平均法</h2><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WeightedAvrage_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = <span class="number">0.114</span>*int(img[i,j,<span class="number">0</span>])+<span class="number">0.578</span>*int(img[i,j,<span class="number">1</span>])+<span class="number">0.299</span>*int(img[i,j,<span class="number">2</span>])</span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'WeightedAvrage_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>图像如下：</p>
<p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.3.1.png" alt></p>
<h2 id="3-4-最大值法、平均值法和加权平均法的比较"><a href="#3-4-最大值法、平均值法和加权平均法的比较" class="headerlink" title="3.4 最大值法、平均值法和加权平均法的比较"></a>3.4 最大值法、平均值法和加权平均法的比较</h2><p>综上，3种方法的灰度处理图像如下所示：</p>
<p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.4.png" alt></p>
<p>可以发现，最大值法转换的灰度图亮度最高，平均值法产生的灰度图像较暗，加权平均法得到的灰度图像明暗介于两者之间。</p>
<h2 id="3-5-opencv-python中灰度处理方法的应用"><a href="#3-5-opencv-python中灰度处理方法的应用" class="headerlink" title="3.5 opencv-python中灰度处理方法的应用"></a>3.5 opencv-python中灰度处理方法的应用</h2><p>opencv-python中有图像灰度处理的接口，直接调用即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.png'</span>)</span><br><span class="line">img1 = cv.cvtColor(img, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(<span class="string">'Src_img'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度转换</span></span><br><span class="line">image2 = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(image2, plt.cm.gray)</span><br><span class="line">plt.title(<span class="string">'Gray_img'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p> 图像如下：</p>
<p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.5.png" alt></p>
<h1 id="4-源码仓库地址"><a href="#4-源码仓库地址" class="headerlink" title="4. 源码仓库地址"></a>4. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像缩放、旋转、翻转、平移</title>
    <url>/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/</url>
    <content><![CDATA[<p>本文介绍几种常见的图像几何变换方法。<a id="more"></a></p>
<h1 id="1-图像缩放"><a href="#1-图像缩放" class="headerlink" title="1. 图像缩放"></a>1. 图像缩放</h1><p>图像缩放就是将源图像中的像素点经过算法映射到目标图像的像素点的过程，即找出目标图像中的像素点Pd(Xd，Yd)对应的源图像的像素点Ps(Xs，Ys)，然后将源图像像素点填充到对应目标图像的像素点，最终形成目标图像。常见的图像缩放算法有最邻近点插值法、双线性插值法和BiCubic卷积插值法等。</p>
<p>在OpenCV中提供函数cv2.resize()实现对图像的缩放，该函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv2.resize( src, dsize[, fx[, fy[, interpolation]]] )</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>dst：输出的目标图像，其类型与src相同，大小为dsize（当该值非零时），或者可以通过src.size()、fx、fy计算得到；<br>src：需要进行缩放的原始图像；<br>dsize：输出图像的大小；<br>x：水平方向的缩放比例；<br>y：垂直方向的缩放比例；<br>interpolation：插值方式。</p>
<p>插值是指图像在进行几何处理时，给无法直接通过映射得到的值的像素点赋值。比如，将原始图像放大为原来的2倍，必然会多出一些无法被直接映射值的像素点，对于这些像素点，插值方式决定了如何确定它们的值。当缩小图像时，使用区域插值方式（INTER_AREA）能够得到最好的效果；当放大图像时，使用三次样条插值（INTER_CUBIC）方式和双线性插值（INTER_LINEAR）方式都能够取得较好的效果。三次样条插值方式速度较慢，双线性插值方式速度相对较快且效果并不逊色。</p>
<p> 测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"lenna.jpg"</span>)</span><br><span class="line">height, width = img.shape[:<span class="number">2</span>]  <span class="comment"># 获取图像的高度和宽度</span></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩放到原来的二分之一</span></span><br><span class="line">img_test1 = cv2.resize(img, (int(height / <span class="number">2</span>), int(width / <span class="number">2</span>)))</span><br><span class="line">cv2.imshow(<span class="string">'resize1'</span>, img_test1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近邻插值法缩放，缩放到原来的四分之一</span></span><br><span class="line">img_test2 = cv2.resize(img, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.25</span>, fy=<span class="number">0.25</span>, interpolation=cv2.INTER_NEAREST)</span><br><span class="line">cv2.imshow(<span class="string">'resize2'</span>, img_test2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/1.png" alt></p>
<h1 id="2-图像旋转"><a href="#2-图像旋转" class="headerlink" title="2. 图像旋转"></a>2. 图像旋转</h1><p>图像旋转是指将图像绕某个中心点旋转一定角度后，得到一幅新的图像。</p>
<p>Python中imutils工具包提供了如下函数实现图像旋转：<br>imutils.rotate：实现了在旋转完成图分辨率不调整的情况下，对原图像内容旋转，可能局部丢失，缺失部分用黑色填充。<br>imutils.rotate_bound：保持原图完整，旋转完成图分辨率会改变。</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> imutils</span><br><span class="line">img = cv2.imread(<span class="string">"lenna.jpg"</span>)</span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转45度，可能局部丢失，缺失部分用黑色填充</span></span><br><span class="line"></span><br><span class="line">rot1 = imutils.rotate(img, angle=<span class="number">45</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rotated1"</span>, rot1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转45度，保持原图完整，旋转完成图分辨率会改变</span></span><br><span class="line"></span><br><span class="line">rot2 = imutils.rotate_bound(img, angle=<span class="number">45</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Rotated2"</span>, rot2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/2.png" alt></p>
<h1 id="3-图像翻转"><a href="#3-图像翻转" class="headerlink" title="3. 图像翻转"></a>3. 图像翻转</h1><p>翻转也称镜像，是指将图像沿轴线进行轴对称变换。水平镜像是将图像沿垂直中轴线进行左右翻转，垂直镜像是将图像沿水平中轴线进行上下翻转，水平垂直镜像是水平镜像和垂直镜像的叠加。</p>
<p>OpenCV提供了cv2.flip函数，可以将图像沿水平方向、垂直方向、或水平/垂直方向同时进行翻转。其函数原型如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">cv2.flip(src, flipCode[, dst]) -&gt; dst</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>scr：变换操作的输入图像；<br>flipCode：控制参数，整型（int），flipCode&gt;0 水平翻转，flipCode=0 垂直翻转，flipCode&lt;0 水平和垂直翻转；<br>dst：变换操作的输出图像，可选项。</p>
<p> 测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"lenna.jpg"</span>)  <span class="comment"># 读取彩色图像(BGR)</span></span><br><span class="line"></span><br><span class="line">imgFlip1 = cv2.flip(img, <span class="number">0</span>)  <span class="comment"># 垂直翻转</span></span><br><span class="line">imgFlip2 = cv2.flip(img, <span class="number">1</span>)  <span class="comment"># 水平翻转</span></span><br><span class="line">imgFlip3 = cv2.flip(img, <span class="number">-1</span>)  <span class="comment"># 水平和垂直翻转</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Original"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))  <span class="comment"># 原始图像</span></span><br><span class="line">plt.subplot(<span class="number">222</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Flipped Horizontally"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(imgFlip2, cv2.COLOR_BGR2RGB))  <span class="comment"># 水平翻转</span></span><br><span class="line">plt.subplot(<span class="number">223</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Flipped Vertically"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(imgFlip1, cv2.COLOR_BGR2RGB))  <span class="comment"># 垂直翻转</span></span><br><span class="line">plt.subplot(<span class="number">224</span>), plt.axis(<span class="string">'off'</span>), plt.title(<span class="string">"Flipped Horizontally &amp; Vertically"</span>)</span><br><span class="line">plt.imshow(cv2.cvtColor(imgFlip3, cv2.COLOR_BGR2RGB))  <span class="comment"># 水平垂直翻转</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/3.png" alt></p>
<h2 id="4-图像平移"><a href="#4-图像平移" class="headerlink" title="4. 图像平移"></a>4. 图像平移</h2><p>图像的平移就是将图像上的像素点整体移动。图像平移首先定义平移矩阵M，再调用warpAffine()函数实现平移，函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, x], [<span class="number">0</span>, <span class="number">1</span>, y]])</span><br><span class="line">shifted = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p> 测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">image = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像下、上、右、左平移</span></span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>]])</span><br><span class="line">img1 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-100</span>]])</span><br><span class="line">img2 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">img3 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">-100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">img4 = cv2.warpAffine(image, M, (image.shape[<span class="number">1</span>], image.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line"></span><br><span class="line">titles = [ <span class="string">'Image-down'</span>, <span class="string">'Image-up'</span>, <span class="string">'Image-right'</span>, <span class="string">'Image-left'</span>]  </span><br><span class="line">images = [img1, img2, img3, img4]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):  </span><br><span class="line">   plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>), plt.imshow(images[i]), plt.title(titles[i])  </span><br><span class="line">   plt.xticks([]),plt.yticks([])  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p> 效果如下：</p>
<p> <img src="/2023/01/07/%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BF%BB%E8%BD%AC%E3%80%81%E5%B9%B3%E7%A7%BB/4.png" alt></p>
<h1 id="4-源码仓库地址"><a href="#4-源码仓库地址" class="headerlink" title="4. 源码仓库地址"></a>4. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像轮廓提取</title>
    <url>/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="1、轮廓提取"><a href="#1、轮廓提取" class="headerlink" title="1、轮廓提取"></a>1、轮廓提取</h2><p>轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。<a id="more"></a></p>
<h2 id="2、轮廓提取方法及Python实现"><a href="#2、轮廓提取方法及Python实现" class="headerlink" title="2、轮廓提取方法及Python实现"></a>2、轮廓提取方法及Python实现</h2><h3 id="2-1-掏空内部点法"><a href="#2-1-掏空内部点法" class="headerlink" title="2.1 掏空内部点法"></a>2.1 掏空内部点法</h3><p>掏空内部点法的原理非常简单：如果原图中有一点为黑，且它的8个相邻点皆为黑色，则将该点删除，否则认为该点在图像的边缘，需要保留。依次处理图像中每一个像素，则最后留下来的就是图像的轮廓。对于非二值图像，需要先进行二值化处理。<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_contour</span><span class="params">(bin_img)</span>:</span></span><br><span class="line">    contour_img = np.zeros(shape=(bin_img.shape),dtype=np.uint8)</span><br><span class="line">    contour_img += <span class="number">255</span></span><br><span class="line">    h = bin_img.shape[<span class="number">0</span>]</span><br><span class="line">    w = bin_img.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,h<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,w<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span>(bin_img[i][j]==<span class="number">0</span>):</span><br><span class="line">                contour_img[i][j] = <span class="number">0</span></span><br><span class="line">                sum = <span class="number">0</span></span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> sum ==  <span class="number">0</span>:</span><br><span class="line">                    contour_img[i][j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contour_img</span><br></pre></td></tr></table></figure>
<p>效果如下（左侧是Otsu二值化图像；右侧是轮廓图像）：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/1.png" alt></p>
<h3 id="2-2-opencv-python中轮廓提取方法的应用"><a href="#2-2-opencv-python中轮廓提取方法的应用" class="headerlink" title="2.2 opencv-python中轮廓提取方法的应用"></a>2.2 opencv-python中轮廓提取方法的应用</h3><p>（1）opencv-python中使用cv2.findContours函数来检测图像的边缘，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</span><br></pre></td></tr></table></figure>
<p><strong>参数说明如下：</strong><br>image：输入图像；<br>mode：轮廓检索模式；<br>method：轮廓逼近方法；<br>contours：返回的轮廓；<br>hierachy：每条轮廓对应的属性；<br>offset：每个轮廓点移动的可选偏移量。<br>备注：image参数需要是二值图，而不是灰度图，返回结果是等高线和层次结构。</p>
<p><strong>轮廓检索模式：</strong><br>cv2.RETR_EXTERNAL：表示只检测外轮廓；<br>cv2.RETR_LIST：检测的轮廓，不建立等级关系；<br>cv2.RETR_CCOMP：建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层；<br>cv2.RETR_TREE：建立一个等级树结构的轮廓。</p>
<p><strong>轮廓逼近方法：</strong><br>cv2.CHAIN_APPROX_NONE：存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即 max(abs(x1-x2),abs(y2-y1))==1，一般不会用到；<br>cv2.CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息；<br>cv2.CHAIN_APPROX_TC89_L1，cv2.CV_CHAIN_APPROX_TC89_KCOS：使用teh-Chinl chain近似算法。</p>
<p>（2）轮廓发现之后，还要通过cv2.drawContours函数绘制轮廓，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])</span><br></pre></td></tr></table></figure>
<p><strong>参数说明如下：</strong><br>image：输入图像；<br>contours：轮廓，在Python中是一个list，就是cv2.findContours函数找出来的点集，一个列表；<br>contourIdx：轮廓的索引，指定绘制轮廓list中的哪条轮廓，要绘制所有轮廓，传递-1；<br>color：颜色；<br>thickness：厚度，如果是-1，表示填充；<br>lineType：线型；<br>hierarchy：层次结构的可选信息；<br>maxLevel：绘制轮廓的最大级别，0：仅绘制指定的轮廓，1：绘制轮廓和所有嵌套轮廓，2：绘制轮廓，所有嵌套轮廓，所有嵌套到嵌套的轮廓；<br>offset：轮廓偏移参数。</p>
<p>根据上面两个函数，测试代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步：读入图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：对图像做灰度处理</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：对图像做二值化处理</span></span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：获得图像的轮廓值</span></span><br><span class="line">contours, heriachy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步：绘制图像轮廓</span></span><br><span class="line">img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">res = cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(res, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'contour'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/2.png" alt></p>
<h2 id="3-源码仓库地址"><a href="#3-源码仓库地址" class="headerlink" title="3. 源码仓库地址"></a>3. 源码仓库地址</h2><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
        <tag>轮廓提取</tag>
      </tags>
  </entry>
  <entry>
    <title>大顶堆和小顶堆</title>
    <url>/2023/02/21/%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%92%8C%E5%B0%8F%E9%A1%B6%E5%A0%86/</url>
    <content><![CDATA[<h2 id="1-什么是堆、大顶堆和小顶堆"><a href="#1-什么是堆、大顶堆和小顶堆" class="headerlink" title="1. 什么是堆、大顶堆和小顶堆"></a>1. 什么是堆、大顶堆和小顶堆</h2><p>堆是一种非线性结构，可以把堆看作一棵二叉树，也可以看作一个数组，即：堆就是利用完全二叉树的结构来维护的一维数组。</p>
<p>堆可以分为大顶堆和小顶堆：<br>大顶堆：每个结点的值都大于或等于其左右孩子结点的值。<br>小顶堆：每个结点的值都小于或等于其左右孩子结点的值。<br>用简单的公式来描述一下堆的定义就是：</p>
<ul>
<li><p>大顶堆<strong>：</strong>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] </p>
</li>
<li><p>小顶堆<strong>：</strong>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>
</li>
</ul>
<p>如果是排序，求升序用大顶堆，求降序用小顶堆。一般我们说 topK 问题，就可以用大顶堆或小顶堆来实现，即最大的 K 个：小顶堆/最小的 K 个：大顶堆。</p>
<a id="more"></a>
<h2 id="2-大顶堆的构建过程"><a href="#2-大顶堆的构建过程" class="headerlink" title="2. 大顶堆的构建过程"></a>2. 大顶堆的构建过程</h2><p>大顶堆的构建过程就是<strong>从最后一个非叶子结点开始从下往上调整</strong>。</p>
<p>最后一个非叶子节点怎么找？这里我们用数组表示待排序序列，则最后一个非叶子结点的位置是：<strong>数组长度/2-1</strong>。假如数组长度为9，则最后一个非叶子结点位置是 9/2-1=3。</p>
<ol>
<li>比较当前结点的值和左子树的值，如果当前节点小于左子树的值，就交换当前节点和左子树；<br>交换完后要检查左子树是否满足大顶堆的性质，不满足则重新调整子树结构；</li>
<li>再比较当前结点的值和右子树的值，如果当前节点小于右子树的值，就交换当前节点和右子树；<br>交换完后要检查右子树是否满足大顶堆的性质，不满足则重新调整子树结构；</li>
<li>无需交换调整的时候，则大顶堆构建完成。</li>
</ol>
<p>画个图理解下，以 [3, 7, 16, 10, 21, 23] 为例：</p>
<p><img src="/2023/02/21/%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%92%8C%E5%B0%8F%E9%A1%B6%E5%A0%86/2.png" alt></p>
<h2 id="3-大顶堆的排序过程"><a href="#3-大顶堆的排序过程" class="headerlink" title="3. 大顶堆的排序过程"></a>3. 大顶堆的排序过程</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值，如此反复执行，便能得到一个有序序列了。</p>
<p>该排序过程可以用下面 4 步概括：<br>第 1 步：先 n 个元素的无序序列，构建成大顶堆；<br>第 2 步：将根节点与最后一个元素交换位置，（将最大元素”沉”到数组末端）；<br>第 3 步：交换过后可能不再满足大顶堆的条件，所以需要将剩下的 n-1 个元素重新构建成大顶堆；<br>第 4 步：重复第 2 步、第 3 步直到整个数组排序完成。</p>
<p>同样以 [3, 7, 16, 10, 21, 23] 为例：</p>
<p><img src="/2023/02/21/%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%92%8C%E5%B0%8F%E9%A1%B6%E5%A0%86/3.png" alt></p>
<h2 id="4-程序实例"><a href="#4-程序实例" class="headerlink" title="4. 程序实例"></a>4. 程序实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * i &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">int</span> v = a[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n &amp;&amp; v &lt; a[j])&#123;</span><br><span class="line">            v = a[j];</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; v)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a[i - <span class="number">1</span>];</span><br><span class="line">            a[i - <span class="number">1</span>] = v;</span><br><span class="line">            a[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        g1(a, n, i);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; a[i] != m; ++i);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (++i; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>)</span><br><span class="line">        ++j;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, g2(a, n, <span class="number">8</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>g1 函数的作用即为构建大顶堆，代码第28行：当 i = 7 时，a[i] = 8，退出循环，程序执行后控制台输出 j 的值为：4。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图像边缘检测</title>
    <url>/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-什么是边缘检测"><a href="#1-什么是边缘检测" class="headerlink" title="1. 什么是边缘检测"></a>1. 什么是边缘检测</h1><p>边缘检测是图像处理与计算机视觉中的重要技术之一。其目的是检测识别出图像中亮度变化剧烈的像素点构成的集合。图像边缘的正确检测对于分析图像中的内容、实现图像中物体的分割、定位等具有重要的作用。边缘检测大大减少了源图像的数据量，剔除了与目标不相干的信息，保留了图像重要的结构属性。</p>
<p>图像的边缘指的是图像中像素灰度值突然发生变化的区域，如果将图像的每一行像素和每一列像素都描述成一个关于灰度值的函数，那么图像的边缘对应在灰度值函数中是函数值突然变大的区域。函数值的变化趋势可以用函数的导数描述。当函数值突然变大时，导数也必然会变大，而函数值变化较为平缓区域，导数值也比较小，因此可以通过寻找导数值较大的区域去寻找函数中突然变化的区域，进而确定图像中的边缘位置。<a id="more"></a></p>
<h1 id="2-边缘检测的常用方法及Python应用"><a href="#2-边缘检测的常用方法及Python应用" class="headerlink" title="2. 边缘检测的常用方法及Python应用"></a>2. 边缘检测的常用方法及Python应用</h1><p>边缘检测的方法大致可分为两类：基于搜索和基于零交叉。</p>
<p>基于搜索的边缘检测方法：首先计算边缘强度，通常用一阶导数表示，例如梯度模，然后，计算估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值。</p>
<p>基于零交叉的边缘检测方法：找到由图像得到的二阶导数的零交叉点来定位边缘，通常用拉普拉斯算子或非线性微分方程的零交叉点。</p>
<p>滤波作为边缘检测的预处理通常是必要的，通常采用高斯滤波。</p>
<h2 id="2-1-一阶微分算子"><a href="#2-1-一阶微分算子" class="headerlink" title="2.1 一阶微分算子"></a>2.1 一阶微分算子</h2><p>一阶微分为基础的边缘检测，通过计算图像的梯度值来检测图像的边缘，如Roberts算子、Prewitt算子和Sobel算子等。</p>
<h3 id="2-1-1-Roberts算子"><a href="#2-1-1-Roberts算子" class="headerlink" title="2.1.1 Roberts算子"></a>2.1.1 Roberts算子</h3><p>Roberts算子是一种最简单的算子，它利用局部差分算子寻找边缘。采用对角线相邻两像素之差近似梯度幅值检测边缘，检测垂直边缘的效果比斜向边缘要好，定位精度高，但对噪声比较敏感，无法抑制噪声的影响。</p>
<p>Roberts算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差，如下的2个卷积核形成了Roberts算子，图像中的每一个点都用这2个核做卷积：</p>
<p><img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.1-1.png" alt></p>
<p>若对于输入图像f(x,y),使用Roberts算子后输出的目标图像为g(x,y),则</p>
<p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.1-2.png" alt></p>
<p>在Python中，Roberts算子主要是通过Numpy定义模板，再调用OpenCV的filter2D()函数实现边缘提取。该函数主要是利用内核实现对图像的卷积运算，其函数原型如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = filter2D(src, ddepth, kernel, dts, anchor,delta, borderType)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>src：表示输入图像；<br>ddepth: 表示目标图像所需的深度；<br>kernel: 表示卷积核,一个单通道浮点型矩阵；<br>anchor： 表示内核的基准点，其默认值为(-1, -1)，位于中心位置；<br>delta：表示在存储目标图像前可选的添加到像素的值，默认值为0；<br>borderType：表示边框模式。</p>
<p> 实验代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Roberts</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">   img = cv2.imread(srcImg_path)</span><br><span class="line">   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">   <span class="comment"># Roberts算子</span></span><br><span class="line">   kernelx = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>]], dtype=int)</span><br><span class="line">   kernely = np.array([[<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>]], dtype=int)</span><br><span class="line">   x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)</span><br><span class="line">   y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)</span><br><span class="line">   <span class="comment"># 转成uint8</span></span><br><span class="line">   absX = cv2.convertScaleAbs(x)</span><br><span class="line">   absY = cv2.convertScaleAbs(y)</span><br><span class="line">   Roberts = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="comment"># 显示图形</span></span><br><span class="line">   titles = [<span class="string">"Original Image"</span>, <span class="string">"Roberts Image"</span>]</span><br><span class="line">   images = [img, Roberts]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">       plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">       plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">       plt.title(titles[i])</span><br><span class="line">       plt.axis(<span class="string">'off'</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.1-3.png" alt></p>
<h3 id="2-1-2-Prewitt算子"><a href="#2-1-2-Prewitt算子" class="headerlink" title="2.1.2 Prewitt算子"></a>2.1.2 Prewitt算子</h3><p>Prewitt是一种图像边缘检测的微分算子，其原理是利用特定区域内像素值产生的差分实现边缘检测。由于Prewitt算子采用3x3模板对区域内的像素值进行计算，而Roberts算子的模板为2x2，故Prewitt算子的边缘检测结果在水平和垂直方向均比Roberts算子更加明显。Prewitt算子适合用来识别噪声较多，灰度渐变的图像。</p>
<p>Prewitt算子卷积核如下：</p>
<p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.2-1.png" alt></p>
<p> 实验代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Prewitt</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">   img = cv2.imread(srcImg_path)</span><br><span class="line">   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">   <span class="comment"># Prewitt算子</span></span><br><span class="line">   kernelx = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]], dtype=int)</span><br><span class="line">   kernely = np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=int)</span><br><span class="line">   x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)</span><br><span class="line">   y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)</span><br><span class="line">   <span class="comment"># 转成uint8</span></span><br><span class="line">   absX = cv2.convertScaleAbs(x)</span><br><span class="line">   absY = cv2.convertScaleAbs(y)</span><br><span class="line">   Prewitt = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="comment"># 显示图形</span></span><br><span class="line">   titles = [<span class="string">"Original Image"</span>, <span class="string">"Prewitt Image"</span>]</span><br><span class="line">   images = [img, Prewitt]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">       plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">       plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">       plt.title(titles[i])</span><br><span class="line">       plt.axis(<span class="string">'off'</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p>  <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.2-2.png" alt></p>
<h3 id="2-1-3-Sobel算子"><a href="#2-1-3-Sobel算子" class="headerlink" title="2.1.3 Sobel算子"></a>2.1.3 Sobel算子</h3><p>在边缘检测中，常用的一种模板是Sobel算子。Sobel算子有两个卷积核，一个是检测水平边缘的；另一个是检测垂直边缘的。与Prewitt算子相比，Sobel算子对于像素的位置的影响做了加权，可以降低边缘模糊程度，因此效果更好。</p>
<p>Sobel算子卷积核如下：</p>
<p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.3-1.png" alt></p>
<p> 在opencv-python中定义了Sobel算子，其函数原型如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = Sobel(src, ddepth, dx, dy, dst,ksize, scale, delta, borderType)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>src：表示输入图像；<br>dst：表示输出的边缘图，其大小和通道数与输入图像相同；<br>ddepth：表示目标图像所需的深度，针对不同的输入图像，输出目标图像有不同的深度；<br>dx：表示x方向上的差分阶数，取值1或0；<br>dy：表示y方向上的差分阶数，取值1或0；<br>ksize：表示Sobel算子的大小，其值必须是正数和奇数；<br>scale：表示缩放导数的比例常数，默认情况下没有伸缩系数；<br>delta：表示将结果存入目标图像之前，添加到结果中的可选增量值。</p>
<p> 实验代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sobel_demo</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">   img = cv2.imread(srcImg_path)</span><br><span class="line">   img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">   grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">   <span class="comment"># Sobel算子</span></span><br><span class="line">   x = cv2.Sobel(grayImage, cv2.CV_16S, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">   y = cv2.Sobel(grayImage, cv2.CV_16S, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="comment"># 转成uint8</span></span><br><span class="line">   absX = cv2.convertScaleAbs(x)</span><br><span class="line">   absY = cv2.convertScaleAbs(y)</span><br><span class="line">   Sobel = cv2.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="comment"># 显示图形</span></span><br><span class="line">   titles = [<span class="string">"Original Image"</span>, <span class="string">"Sobel Image"</span>]</span><br><span class="line">   images = [img, Sobel]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">       plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">       plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">       plt.title(titles[i])</span><br><span class="line">       plt.axis(<span class="string">'off'</span>)</span><br><span class="line">   plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.1.3-2.png" alt></p>
<h2 id="2-2-二阶微分算子"><a href="#2-2-二阶微分算子" class="headerlink" title="2.2 二阶微分算子"></a>2.2 二阶微分算子</h2><p>二阶微分为基础的边缘检测，通过寻求二阶导数中的过零点来检测边缘，如Laplacian算子和Canny算子等。</p>
<h3 id="2-2-1-Laplacian算子"><a href="#2-2-1-Laplacian算子" class="headerlink" title="2.2.1 Laplacian算子"></a>2.2.1 Laplacian算子</h3><p>Laplacian算子是n维欧几里德空间中的一个二阶微分算子，常用于图像增强和边缘提取。它通过灰度差分计算邻域内的像素，基本流程是：判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作。在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系，最后通过梯度运算的结果对像素灰度进行调整。</p>
<p>在opencv-python中，Laplacian算子封装在Laplacian()函数中，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>src：表示输入图像；<br>dst：表示输出的边缘图，其大小和通道数与输入图像相同；<br>ddepth：表示目标图像所需的深度；<br>ksize：表示用于计算二阶导数的滤波器的孔径大小，其值必须是正数和奇数，且默认值为1；<br>scale：表示计算拉普拉斯算子值的可选比例因子，默认值为1；<br>delta：表示将结果存入目标图像之前，添加到结果中的可选增量值，默认值为0；<br>borderType：表示边框模式。</p>
<p> 当ksize=1时，Laplacian()函数采用3x3模板（四邻域）进行变换处理。下面的实验代码是采用ksize=3的Laplacian算子进行图像锐化处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Laplacian_demo</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv2.imread(srcImg_path)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># Laplacian算子</span></span><br><span class="line">    Laplacian = cv2.Laplacian(grayImage, cv2.CV_16S, ksize=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 转成uint8</span></span><br><span class="line">    Laplacian = cv2.convertScaleAbs(Laplacian)</span><br><span class="line">    <span class="comment"># 显示图形</span></span><br><span class="line">    titles = [<span class="string">"Original Image"</span>, <span class="string">"Laplacian Image"</span>]</span><br><span class="line">    images = [img, Laplacian]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p> 效果如下：</p>
<p>  <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.2.1-1.png" alt></p>
<h3 id="2-2-2-Canny算子"><a href="#2-2-2-Canny算子" class="headerlink" title="2.2.2 Canny算子"></a>2.2.2 Canny算子</h3><p>Canny算子由John F. Canny在1986年提出，由于它出色的检测和容错能力，至今一直被广泛使用。Canny边缘检测具有以下特点：<br>较低的错误率 - 只有真实存在的边缘才会被检测到。<br>较好的边缘定位 - 检测出来的结果和图像中真实的边缘在距离上的误差很小。<br>没有重复的检测 - 对于每一条边缘，只会返回一个与之对应的结果。</p>
<p> Canny算子的计算步骤大概分成以下几步：</p>
<p>1.图像灰度化<br>2.用高斯滤波去噪：目的是平滑一些纹理较弱的非边缘区域，以得到更准确的边缘。<br>3.计算梯度方向和大小：图像梯度表达的是各个像素点之间，像素值大小的变化幅度大小，变化较大，则可以认为是处于边缘位置。<br>4.非极大值抑制：在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点，即对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。<br>5.双阈值选取和滞后边界跟踪：确定哪些边界才是真正的边界。这时我们需要设置两个阈值：minVal和maxVal。当图像的灰度梯度高于maxVal时被认为是真的边界，那些低于minVal的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p>
<p> 在Python Opencv接口中，提供了Canny函数，其函数原型如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canny = cv2.Canny(image,threshold1,threshold2)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>image：灰度图；<br>threshold1：minval，较小的阈值将间断的边缘连接起来；<br>threshold2：maxval，较大的阈值检测图像中明显的边缘。</p>
<p> 实验代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Canny_demo</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv2.imread(srcImg_path)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 高斯滤波</span></span><br><span class="line">    img_GaussianBlur = cv2.GaussianBlur(gray, (<span class="number">3</span>,<span class="number">3</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># Canny算子</span></span><br><span class="line">    Canny = cv2.Canny(img_GaussianBlur, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 显示图形</span></span><br><span class="line">    titles = [<span class="string">"Original Image"</span>, <span class="string">"Canny Image"</span>]</span><br><span class="line">    images = [img, Canny]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i], <span class="string">"gray"</span>)</span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/06/%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/2.2.2-1.png" alt></p>
<h1 id="3-源码仓库地址"><a href="#3-源码仓库地址" class="headerlink" title="3. 源码仓库地址"></a>3. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2020</title>
    <url>/2020/12/31/%E6%88%91%E7%9A%842020/</url>
    <content><![CDATA[<p>2020，一场突如其来的疫情，让它注定成为不平凡的一年。</p>
<a id="more"></a>
<p>听说人这一生中有7次改变自己命运的机会，第一次是15岁，第二次是25岁，依此直到75岁。</p>
<p>恰巧，今年我25岁。在这一年，发生了许多的事。</p>
<p>日复一日繁杂的工作让我不断思考我的人生路线。可是，陷入泥潭是难以自拔的。好在积蓄的能量终究会爆发，在无人预料，甚至我自己也毫无准备的情况下，我辞职了。</p>
<p>毫无顾虑的睡上了几天，远在广东的两个大学同学邀我去广东游玩。于是人生中第一次坐飞机，第一次踏上了祖国的南方大地。</p>
<p>很快，3人租了辆车，开启了海岛之旅。于是我第一次见到真正的大海，第一次走在真正的沙滩上，感受海水袭来时的重心不稳，吹着海风，吃着海鲜大餐，享受着无与伦比的惬意与快乐。</p>
<p>也认识了很多朋友，他们是一群积极向上的年轻人，没有大城市的勾心斗角，只有淳朴的热情。可惜我是一个无比慢热的人，甚至没来得及跟他们交换微信，在一次晚餐后匆匆离别，或许就是永别了。</p>
<p>返回南京，开始找工作，我自信最迟半个月肯定能找到心仪的工作。然而，事实狠狠打了我的脸，眼看一个月了，有几份工作，却都不是我特别满意的。慢慢地，我的耐心被消磨殆尽，也疲于奔波，在看清形势后，找了一份勉强满意的工作，准备一边做着一边找机会跳槽。</p>
<p>可惜，命运总是会跟你开各种各样的玩笑。一次PM找我谈话，我以为是工作上的事，事实也确实是，不过内容是，我因为某种不可抗力需要转岗或者离开，而此时我进入公司才3周。先是震惊，不过几分钟后我就冷静了下来，因为我已经想好了接下来要做的事。</p>
<p>有了方向，路途就不再迷茫。虽然可能有点晚，不过相比眼下一眼望到底的人生，似乎一切都还来得及，那就奋起努力吧！</p>
<p>时间很快，2020还有几个小时就要成为过去式了，而我也将踏上新的人生旅途，过往虽有遗憾，却不后悔。</p>
<p>别了，2020。你好，2021！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>寻梦环游记</title>
    <url>/2023/03/06/%E5%AF%BB%E6%A2%A6%E7%8E%AF%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>看了这部早有耳闻的电影，原因可能是开学前给去世的爷爷上坟和最近身体不好的奶奶，但直到前两天我才知道这是部关于死亡的电影。故事可以说是多级反转，不过结局是美好的：一家人在一起，载歌载舞，无论他们是生是死。<a id="more"></a></p>
<p>不久前的寒假，我回到儿时的故乡。儿时热闹的村庄，早已没有了往日的喧嚣。那时，无论盛夏烈日炎炎，还是冬天白雪皑皑，总有我们一群嬉笑打闹的孩子，大人们忙碌谈笑，老人们家长里短。然而，在我长大的短短二十年间，老人们陆续离去，我们也离开家乡，或是上学或是工作或是在外地买房。这个村庄，只剩一群不愿离开，也离不开的中老年人守护。他们保留着传统的生活习惯，随着时光流逝，最后也会像这可能不知多久后消失的村庄，埋入祖辈的墓地里，隐入历史的尘烟中。</p>
<p>我生于旧世纪的尾巴，成长在由贫穷迈向小康的转折点，农村和城市的印记都刻在我的脑海里。虽然我现在在大城市学习生活，以后也大概率会在大城市工作生活。然而一直以来，我做梦的场景好像很多时候都是故乡的村庄和老房子，甚至都不是现在翻新的房子，虽然这房子也翻新得有十年了吧。这是什么原因？我一直苦苦思索而不得。可能儿时的我，儿时的村庄才是我潜意识中真正幸福的时光吧，在那个记忆里，我才真正放松和自由。有时我也想，等我老了也回来吧，那时的我也没有了欲望和抱负，坐在宁静的村庄晒着太阳，回忆往事，静静等待死亡，最后叶落归根。</p>
<p>奶奶身体不好，可能随时离我们而去，爸爸妈妈也步入中年。曾经我在想，他们一生的意义是什么呢？他们没有知识，不知道文化的魅力和宇宙的浩瀚；他们没去过大城市，没见过高楼大厦，去过风景名胜；他们没有以后……后来我想通了，他们的一生在他们眼中未必不是精彩的，他们从乱世中走来，度过苦难，却也见过现代社会的繁荣，我们不必为他们悲哀，因为一代人自有一代人的命运，我们最终也会如此。</p>
<p>时间缓缓流淌，死是我们的归宿，就像电影中的那样，谁也不能幸免，所以我们不必害怕，但我们现在得认真地活，认真地陪伴家人，认真学习工作，感受人生。这样，在我们离开这个世界时，才能更加坦然，让活着的人记住我们。到那时，在另一个世界的我们和这个世界的人们，虽然肉体无法接触，但灵魂一直相伴，直到最终和我们最亲近的人在另一个世界重逢。</p>
<p><img src="/2023/03/06/%E5%AF%BB%E6%A2%A6%E7%8E%AF%E6%B8%B8%E8%AE%B0/寻梦环游记.jpg" alt></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>我的研究生之旅</title>
    <url>/2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>应该是三月吧，时间记不清了，初试成绩出来的那一刻我觉得应该进不了复试了。<a id="more"></a>又逢家中的一些变故，那时只想离开家，所以我骗家人不想调剂，决定出去找工作，其实我的内心是想调剂的。</p>
<p>离开家，回到曾经工作的地方一直准备调剂，却又感觉希望渺茫，心想实在调剂不上就继续工作吧。调剂系统出来的第一天，由于没有调剂经验，很快填完了3个名额，填的学校都是比较好的学校，导致填完就没有了下文，最多就是被查看，一直没有复试通知。错过了前期的黄金调剂期，后面调剂越来越难，幸运的是，在最后时刻终于被录取了，虽然是一所很一般的学校。心是有不甘，但这已经是比较好的结局。</p>
<p>九月入学，第一次来到东北，有些陌生，有些新鲜。很快适应了大学生活，就像我只是放假后又重新回到学校，不过还是有了很多不一样的感受。再一次在秋天凉爽的夜晚漫步在学校的马路操场上，看着熙熙攘攘的学生，踩着滑板，唱着歌，一幅幅青春的模样，一年前的我怎么也不会想到今天的自己又回到了校园，以一个学生的身份。没错，我又回到了校园，没有生活的琐碎，工作的烦恼，只有无忧无虑的学习、生活和娱乐，可以有大量的时间做自己想做的事，我感到无比幸运，因为就连这样的散步都是工作后奢侈的享受。我又走进了图书馆，去阶梯教室上课，去食堂吃饭，睡四人寝……每一件事都是熟悉的样子，恍如昨日，这些曾经离开校园后最美好的回忆，我正在体验着，也更加珍惜，果然人总是在失去后才会懂得拥有的珍贵。</p>
<p>一学期的学习生活很快结束，考试周的考试也结束了，又松了口气，可以继续做自己想做的事，看自己喜欢的书，马上就可以放假飞到想去的城市见见许久未见的老友。生活很平淡，有时甚至很艰难，可是总有什么是我们期待的，总有什么是值得我们期待的，不知不觉中，我们都在朝着更好的方向努力，明天的生活不知道会怎样，可是我们要珍惜现在的我们和现在的时光。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>本文介绍几种常用的排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序。</strong></p>
<a id="more"></a>
<hr>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>冒泡排序（Bubble Sort）：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    bubble_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">                temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>选择排序（Selection Sort）：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    selection_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span>=i;                  <span class="comment">// 记录最小值，第一个元素默认最小</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)		<span class="comment">// 访问未排序的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[<span class="built_in">min</span>])			<span class="comment">// 找到目前最小值</span></span><br><span class="line">                <span class="built_in">min</span>=j;				<span class="comment">// 记录最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[<span class="built_in">min</span>];			<span class="comment">// 交换两个变量</span></span><br><span class="line">            a[<span class="built_in">min</span>]=a[i];</span><br><span class="line">            a[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><p>插入排序（英语：Insertion Sort）：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    insertion_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        temp=arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：-2"><a href="#运行结果：-2" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 9 22 32 34 35 37 50 55 64 70 82 89</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>希尔排序（Shell Sort）：也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 </li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    shell_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap,i,j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(gap=len&gt;&gt;<span class="number">1</span>;gap&gt;<span class="number">0</span>;gap=gap&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=gap;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-gap;j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;temp;j-=gap)</span><br><span class="line">                arr[j+gap]=arr[j];</span><br><span class="line">            arr[j+gap]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：-3"><a href="#运行结果：-3" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>归并排序（Merge Sort）：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>可从上到下或从下到上进行。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mini</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    merge_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mini</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a=arr;</span><br><span class="line">    <span class="keyword">int</span> *b=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">int</span> *temp,seg,start;</span><br><span class="line">    <span class="keyword">for</span>(seg=<span class="number">1</span>;seg&lt;len;seg+=seg)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span>(start=<span class="number">0</span>;start&lt;len;start+=seg+seg)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">int</span> low=start;</span><br><span class="line">			<span class="keyword">int</span> mid=mini(start+seg,len);</span><br><span class="line">			<span class="keyword">int</span> high=mini(start+seg+seg,len);</span><br><span class="line">            <span class="keyword">int</span> k=low;</span><br><span class="line">            <span class="keyword">int</span> start1=low;</span><br><span class="line">			<span class="keyword">int</span> end1=mid;</span><br><span class="line">            <span class="keyword">int</span> start2=mid;</span><br><span class="line">			<span class="keyword">int</span> end2=high;</span><br><span class="line">            <span class="keyword">while</span>(start1&lt;end1&amp;&amp;start2&lt;end2)</span><br><span class="line">                b[k++]=a[start1]&lt;a[start2]?a[start1++]:a[start2++];</span><br><span class="line">            <span class="keyword">while</span>(start1&lt;end1)</span><br><span class="line">                b[k++]=a[start1++];</span><br><span class="line">            <span class="keyword">while</span>(start2&lt;end2)</span><br><span class="line">                b[k++]=a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        temp=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a!=arr)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        b=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span> [],<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">const</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    merge_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> reg[],<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k,len,mid,start1,start2,end1,end2;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=<span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    len=<span class="built_in">end</span>-start;</span><br><span class="line">	mid=(len&gt;&gt;<span class="number">1</span>)+start;</span><br><span class="line">    start1=start;</span><br><span class="line">	end1=mid;</span><br><span class="line">    start2=mid+<span class="number">1</span>;</span><br><span class="line">	end2=<span class="built_in">end</span>;</span><br><span class="line">    merge_sort_recursive(arr,reg,start1,end1);</span><br><span class="line">    merge_sort_recursive(arr,reg,start2,end2);</span><br><span class="line">    k=start;</span><br><span class="line">    <span class="keyword">while</span>(start1&lt;=end1&amp;&amp;start2&lt;=end2)</span><br><span class="line">        reg[k++]=arr[start1]&lt;arr[start2]?arr[start1++]:arr[start2++];</span><br><span class="line">    <span class="keyword">while</span>(start1&lt;=end1)</span><br><span class="line">        reg[k++]=arr[start1++];</span><br><span class="line">    <span class="keyword">while</span>(start2&lt;=end2)</span><br><span class="line">        reg[k++]=arr[start2++];</span><br><span class="line">    <span class="keyword">for</span>(k=start;k&lt;=<span class="built_in">end</span>;k++)</span><br><span class="line">        arr[k]=reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[N];</span><br><span class="line">    merge_sort_recursive(arr,reg,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果：-4"><a href="#运行结果：-4" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="备注：常用排序算法的时间复杂度和空间复杂度"><a href="#备注：常用排序算法的时间复杂度和空间复杂度" class="headerlink" title="备注：常用排序算法的时间复杂度和空间复杂度"></a>备注：常用排序算法的时间复杂度和空间复杂度</h2><p><img src="/2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/总.png" style="zoom:50%;"></p>
<p><img src="/2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/总1.png" alt></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>梅子鸡之味</title>
    <url>/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/</url>
    <content><![CDATA[<p>很久没有安静地看一部电影了，在新年的第一天，经一位网友的推荐，看了这部充满浪漫色彩的“喜剧”。电影开始时确实有点让人摸不着头脑，以至于常常被逗笑，可越看越有一种悲伤的气息扑面而来。我倒没有真的很悲伤，但确实引发了我的一些思考。<a id="more"></a></p>
<p>影片的结构很精巧，开始就说明了主人公的最终命运——八天后的死亡，然后从第一天直到第八天，层层递进，描绘了他面对即将到来的死亡的内心变化，并且在这之间穿插了过往历史进行深入阐述，直至最后与影片开头呼应，将整个故事完美串联到一起。</p>
<p>影片采用一种夸张的浪漫主义手法讲述故事。故事背景设定在上世纪中叶的法国，电影画面营造了一种饱含历史气息的氛围，让人很难想象这是一部2011年的电影。正是这种氛围，让人渐渐走进故事，就像被拉进了故事中，仿佛真切看到了发生的一切，让我想起了一部很久前看过的电影《爱有来生》，似有异曲同工之妙。</p>
<p>影片的故事从主人公、主人公的妻子、主人公的所爱三个人展开，主人公与所爱互相爱慕，却因为现实不得不分开，主人公的妻子深爱主人公，却爱而不得，最终导致了三个人的悲剧。摔坏的小提琴是主人公爱的破碎，也是主人公妻子爱的破碎，更是主人公所爱爱的破碎，正因如此，他才会选择死亡。电影从爱情与婚姻、艺术与生活、梦与现实，乃至教育、家庭、责任、社会、宗教、死亡、命运等多个角度进行了深入探讨，每一个角度都值得我们深入思考，所以这不仅仅是一个悲惨的爱情故事，更是一部千姿百态的生活全景图。</p>
<p>然而，电影在充满悲剧色彩的故事中还是给了我们一丝温暖与慰藉的。电影结尾，在主人公的坟墓前，爱他的人都来送他最后一程，包括他的挚爱；电影中主人公最想不到的小儿子在深夜为他默默祈祷；主人公母亲去世后坟墓上漂浮的烟雾花朵。即使生活充满支离破碎，命运满是伤痕，总是有人在乎你，爱着你的，即使他们终将离我们而去，但曾经留下的痕迹与回忆相信在最寒冷的黑夜也能给我们些许暖意。</p>
<p>最后，这确实是一部值得推荐和隔一段时间反复观看的电影。</p>
<p><img src="/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/梅子鸡之味.jpg" alt></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>文件重定向</title>
    <url>/2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<p>当测试程序时，反复从键盘敲入测试数据作为程序的输入，是非常乏味且低效的。<a id="more"></a>大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与文件命名关联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>
<p>假定$是操作系统提示符，程序已经编译为名为addItems.exe的可执行文件（在UNIX操作系统中是addItems），则上述命令会从一个名为infile的文件读取数据，并将结果写入到一个名为outfile的文件中，两个文件都处于当前目录中。</p>
<p>以在Windows下为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G:\C++Primer\Debug&gt;<span class="string">"C++Primer.exe"</span> &lt;infile.txt&gt;outfile.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>海街日记</title>
    <url>/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>“虽然知道自己马上就要死了，但是依然能感受到美丽的东西是美的，很开心。”<a id="more"></a></p>
<p>电影开头铃的父亲和电影结尾二宫女士的去世，告诉我们无尽温柔的人也无法抵挡死亡；海上的烟花会和盛开的樱花，在绽放后转瞬消逝……这些无一不蕴含对美好易逝的感叹。</p>
<p>但这部电影的主题却不是宣扬悲观，而是在告诉人们，死亡和失去并不可怕，重要的是珍惜身边的人，珍惜现在，好好生活。</p>
<p><img src="/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/海街日记.jpg" alt></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>追赶法求解线性方程组</title>
    <url>/2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p><strong>利用追赶法求解线性方程组，基于C语言实现。</strong></p>
<p><strong>追赶法是LU分解法的一种特例，其系数矩阵是一种稀疏矩阵，除主对角线及相邻的两条对角线为非零元素，其余元素值均为0，称为三对角矩阵。</strong></p>
<a id="more"></a>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> c[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> d[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>, i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]/b[i<span class="number">-1</span>];</span><br><span class="line">        b[i]=b[i]-c[i<span class="number">-1</span>]*a[i];</span><br><span class="line">        d[i]=d[i]-a[i]*d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    d[n]=d[n]/b[n];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=(d[i]-c[i]*d[i+<span class="number">1</span>])/b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.100000</span></span><br><span class="line"><span class="number">2.200000</span></span><br><span class="line"><span class="number">2.300000</span></span><br><span class="line"><span class="number">2.400000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title>论持久战</title>
    <url>/2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/</url>
    <content><![CDATA[<p><a href="https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193805b.htm" target="_blank" rel="noopener"><strong>在线阅读网址一</strong></a><br><a href="http://chinatide.net/xiachao/3-2.html" target="_blank" rel="noopener"><strong>在线阅读网址二</strong></a></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图均衡化</title>
    <url>/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-图像直方图"><a href="#1-图像直方图" class="headerlink" title="1. 图像直方图"></a>1. 图像直方图</h1><p>图像直方图，是指对整个图像在灰度范围内的像素值(0-255)统计出现频率次数，据此生成的直方图，称为图像直方图或直方图。直方图反映了图像灰度的分布情况，是图像的统计学特征。也可以说，直方图是图像中像素强度分布的图形表达方式，它统计了每一个强度值所具有的像素个数。</p>
<h1 id="2-直方图均衡化"><a href="#2-直方图均衡化" class="headerlink" title="2. 直方图均衡化"></a>2. 直方图均衡化</h1><p>直方图均衡化是以累计分布函数为核心，将原始图像灰度直方图从比较集中的某个灰度区间，非线性地映射为在全部灰度范围内的较均匀分布，从而增强对比度。</p>
<a id="more"></a>
<p>直方图均衡化的数学原理如下：<br>首先作原始图像灰度的概率直方图, 然后设输入像素灰度值为r<sub>k</sub>，累计分布函数为</p>
<p><img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-1.png" alt></p>
<p>其中n<sub>i</sub>为图像中灰度值为r<sub>i</sub>的像素频数，n为图像像素总数。设输出像素灰度值为s<sub>k</sub>，像素范围为s<sub>min</sub>-s<sub>max</sub>。期望输出灰度直方图是均匀分布，即</p>
<p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-2.png" alt></p>
<p>令C(s<sub>k</sub>)=C(r<sub>k</sub>)，即得</p>
<p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-3.png" alt></p>
<p>所以最终直方图均衡化的点算子为</p>
<p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/2-4.png" alt></p>
<h1 id="3-直方图均衡化的Python实现"><a href="#3-直方图均衡化的Python实现" class="headerlink" title="3. 直方图均衡化的Python实现"></a>3. 直方图均衡化的Python实现</h1><p>根据直方图均衡化的数学原理，用Python实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算累计分布函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span><span class="params">(rk)</span>:</span></span><br><span class="line">    <span class="comment"># 读取图片灰度直方图</span></span><br><span class="line">    <span class="comment"># bins为直方图直方柱的取值向量，hist为bins各取值区间上的频数取值</span></span><br><span class="line">    hist, bins = np.histogram(rk, <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    <span class="comment"># 计算累计分布函数</span></span><br><span class="line">    <span class="keyword">return</span> hist.cumsum()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算灰度均衡化映射</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">T</span><span class="params">(rk)</span>:</span></span><br><span class="line">    cdf = C(rk)</span><br><span class="line">    <span class="comment"># 均衡化</span></span><br><span class="line">    cdf = (cdf - cdf.min()) * (<span class="number">255</span> - <span class="number">0</span>) / (cdf.max() - cdf.min()) + <span class="number">0</span></span><br><span class="line">    <span class="comment">#cdf = 255.0 * cdf / cdf[-1]</span></span><br><span class="line">    <span class="keyword">return</span> cdf.astype(<span class="string">'uint8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将二维数字图像矩阵转变为一维向量</span></span><br><span class="line">rk = img.flatten()</span><br><span class="line"><span class="comment"># 原始图像灰度直方图</span></span><br><span class="line">plt.hist(rk, <span class="number">256</span>, [<span class="number">0</span>, <span class="number">255</span>], color = <span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line">imgDst = T(rk)[img]     </span><br><span class="line">plt.hist(imgDst.flatten(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">255</span>], color = <span class="string">'b'</span>)</span><br><span class="line">plt.legend([<span class="string">'Before Equalization'</span>,<span class="string">'Equalization'</span>]) </span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 展示前后对比图像</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Original Gray'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(imgDst, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Histogram Equalization'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>均衡前后图像灰度直方图如下所示：</p>
<p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/3-1.png" alt></p>
<p>直方图均衡化前后的图像对比如下所示：</p>
<p><img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/3-2.png" alt></p>
<h1 id="4-opencv-python中直方图均衡化的应用"><a href="#4-opencv-python中直方图均衡化的应用" class="headerlink" title="4. opencv-python中直方图均衡化的应用"></a>4. opencv-python中直方图均衡化的应用</h1><p>opencv-python中使用cv.equalizeHist函数即可实现直方图均衡化，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst=cv.equalizeHist(src[, dst])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：输入需是灰度图像。</p>
</blockquote>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">dst = cv.equalizeHist(img)</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Original Gray'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst, cmap=<span class="string">'gray'</span>), plt.title(<span class="string">'Histogram Equalization'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p> <img src="/2023/01/08/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/4.png" alt></p>
<h1 id="源码仓库地址"><a href="#源码仓库地址" class="headerlink" title="源码仓库地址"></a>源码仓库地址</h1><p>🌼<a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>链队列的实现及应用</title>
    <url>/2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>本文记录单链队列（队列的链式存储结构）的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li>
<li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li>
</ul>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QueuePtr front;</span><br><span class="line">	QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!Q.front)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Q.front)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.rear=Q.front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Q.front);</span><br><span class="line">		Q.front=Q.rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Q清为空队列</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p,q;</span><br><span class="line">	Q.rear=Q.front;</span><br><span class="line">	p=Q.front-&gt;next;</span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		q=p;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列Q为空队列，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Q的元素个数，即队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	p=Q.front;</span><br><span class="line">	<span class="keyword">while</span>(Q.rear!=p)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则用e返回Q的队头元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p=Q.front-&gt;next;</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e作为新的队尾元素</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=p;</span><br><span class="line">	Q.rear=p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	p=Q.front-&gt;next;</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit失败，则操作失败</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q,<span class="keyword">void</span> (*visit)(QElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	p=Q.front-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(QElemType i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	QElemType d;</span><br><span class="line">	LinkQueue q;</span><br><span class="line">	i=InitQueue(q);</span><br><span class="line">	<span class="keyword">if</span>(i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"成功地构造了一个空队列！\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始化队列后，队列空否？%d(1：空 0：否)，"</span>,QueueEmpty(q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line">	EnQueue(q,<span class="number">-5</span>);</span><br><span class="line">	EnQueue(q,<span class="number">5</span>);</span><br><span class="line">	EnQueue(q,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"插入3个元素（-5,5,10）后，队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"现在队列空否？%d(1：空 0：否)\n"</span>,QueueEmpty(q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"现在队列中的元素为："</span>);</span><br><span class="line">	QueueTraverse(q,visit);</span><br><span class="line">	i=GetHead(q,d);</span><br><span class="line">	<span class="keyword">if</span>(i==OK)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队头元素为：%d\n"</span>,d);</span><br><span class="line">	DeQueue(q,d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"删除了队头元素：%d\n"</span>,d);</span><br><span class="line">	i=GetHead(q,d);</span><br><span class="line">	<span class="keyword">if</span>(i==OK)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"新的队头元素为：%d\n"</span>,d);</span><br><span class="line">	ClearQueue(q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"清空队列后，q.front=%u q.rear=%u q.front-&gt;next=%u\n"</span>,q.front,q.rear,q.front-&gt;next);</span><br><span class="line">	DestroyQueue(q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"销毁队列后，q.front=%u q.rear=%u\n"</span>,q.front,q.rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">成功地构造了一个空队列！</span><br><span class="line">初始化队列后，队列空否？<span class="number">1</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)，队列长度为：<span class="number">0</span></span><br><span class="line">插入<span class="number">3</span>个元素（<span class="number">-5</span>,<span class="number">5</span>,<span class="number">10</span>）后，队列长度为：<span class="number">3</span></span><br><span class="line">现在队列空否？<span class="number">0</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)</span><br><span class="line">现在队列中的元素为：<span class="number">-5</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line">队头元素为：<span class="number">-5</span></span><br><span class="line">删除了队头元素：<span class="number">-5</span></span><br><span class="line">新的队头元素为：<span class="number">5</span></span><br><span class="line">清空队列后，q.front=10555928 q.rear=10555928 q.front-&gt;next=0</span><br><span class="line">销毁队列后，q.front=<span class="number">0</span> q.rear=<span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯消去法求解线性方程组</title>
    <url>/2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p><strong>利用高斯消去法求解线性方程组，基于C语言实现。</strong></p>
<a id="more"></a>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A[MAX][MAX];</span><br><span class="line"><span class="keyword">double</span> b[MAX];</span><br><span class="line"><span class="keyword">double</span> X[MAX];</span><br><span class="line"><span class="keyword">int</span> NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的阶数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;NUM);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的第%d行元素:"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=NUM; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;A[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入右端项b:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的系数矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">float</span> mik;	<span class="comment">//消元过程所用变量</span></span><br><span class="line">    <span class="keyword">float</span> S;	<span class="comment">//回代过程所用变量</span></span><br><span class="line"></span><br><span class="line">    inputMatrix();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消元</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;NUM<span class="number">-1</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!A[k][k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">1</span>; i&lt;NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mik=A[i][k]/A[k][k];</span><br><span class="line">			b[i]=b[i]-mik*b[k];</span><br><span class="line">            <span class="keyword">for</span>(j=k; j&lt;NUM; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j]=A[i][j]-mik*A[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回代</span></span><br><span class="line">    X[NUM<span class="number">-1</span>]=b[NUM<span class="number">-1</span>]/A[NUM<span class="number">-1</span>][NUM<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(k=NUM<span class="number">-2</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        S=b[k];</span><br><span class="line">        <span class="keyword">for</span>(j=k+<span class="number">1</span>; j&lt;NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            S=S-A[k][j]*X[j];</span><br><span class="line">        &#125;</span><br><span class="line">        X[k]=S/A[k][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出解</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该线性方程组的解为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"X%d=%lf\n"</span>,i+<span class="number">1</span>,X[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入系数矩阵A的阶数:<span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">1</span>行元素:<span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">输入系数矩阵A的第<span class="number">2</span>行元素:<span class="number">12</span> <span class="number">-3</span> <span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">3</span>行元素:<span class="number">-18</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line">输入右端项b:<span class="number">6</span> <span class="number">15</span> <span class="number">-15</span></span><br><span class="line"></span><br><span class="line">输入的系数矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">12.000000</span> <span class="number">-3.000000</span> <span class="number">3.000000</span></span><br><span class="line"><span class="number">-18.000000</span> <span class="number">3.000000</span> <span class="number">-1.000000</span></span><br><span class="line">输入的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">15.000000</span></span><br><span class="line"><span class="number">-15.000000</span></span><br><span class="line"></span><br><span class="line">消元后的矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">-15.000000</span> <span class="number">-9.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">4.400000</span></span><br><span class="line">消元后的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">-57.000000</span></span><br><span class="line"><span class="number">13.200001</span></span><br><span class="line"></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">X1=<span class="number">1.000000</span></span><br><span class="line">X2=<span class="number">2.000000</span></span><br><span class="line">X3=<span class="number">3.000000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序串的实现及应用</title>
    <url>/2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>本文记录顺序串的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li>
<li>采用C语言实现。</li>
</ul>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SString.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 10                                 <span class="comment">// 顺序串的最大串长</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串的顺序存储类型定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN + <span class="number">1</span>];         <span class="comment">// 0号单元存放串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span></span>;       <span class="comment">//构造一个值为chars的串T		</span></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span></span>;	  <span class="comment">//用T返回由S1和S2联结而成的新串。若未截断，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span></span>;		                      <span class="comment">// 测试函数，打印字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, len;</span><br><span class="line">    </span><br><span class="line">    len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(chars);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// chars过长</span></span><br><span class="line">    <span class="keyword">if</span>(len &gt; MAXSTRLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T[<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        T[i] = chars[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> uncut;  <span class="comment">// 新串是否完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完全不需要裁剪</span></span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>] + S2[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制S2到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>] + S2[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 未裁剪，完整</span></span><br><span class="line">        uncut = TRUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要裁剪S2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(S1[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将S2的一部分复制到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只需要复制S1的一部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连同长度信息一起复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> uncut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"████████ Concat \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        SString Tmp1, Tmp2, Tmp3, Tmp4, S1, S2, S3, S4, S5, S6, S7, S8;</span><br><span class="line">        </span><br><span class="line">        StrAssign(S1, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S2, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S1和S2形成 Tmp1 ...\n"</span>);</span><br><span class="line">        Concat(Tmp1, S1, S2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp1 = "</span>);</span><br><span class="line">        PrintElem(Tmp1);</span><br><span class="line"></span><br><span class="line">		StrAssign(S3, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S4, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S3和S4形成 Tmp2 ...\n"</span>);</span><br><span class="line">        Concat(Tmp2, S3, S4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp2 = "</span>);</span><br><span class="line">        PrintElem(Tmp2);</span><br><span class="line"></span><br><span class="line">		StrAssign(S5, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S6, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S5和S6形成 Tmp3 ...\n"</span>);</span><br><span class="line">        Concat(Tmp3, S5, S6);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp3 = "</span>);</span><br><span class="line">        PrintElem(Tmp3);</span><br><span class="line"></span><br><span class="line">		StrAssign(S7, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S8, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S7和S8形成 Tmp4 ...\n"</span>);</span><br><span class="line">        Concat(Tmp4, S7, S8);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp4 = "</span>);</span><br><span class="line">        PrintElem(Tmp4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">████████ Concat</span><br><span class="line">█ 联接S1和S2形成 Tmp1 ...</span><br><span class="line">█ Tmp1 = +++++-----</span><br><span class="line">█ 联接S3和S4形成 Tmp2 ...</span><br><span class="line">█ Tmp2 = +++++++---</span><br><span class="line">█ 联接S5和S6形成 Tmp3 ...</span><br><span class="line">█ Tmp3 = +++++-----</span><br><span class="line">█ 联接S7和S8形成 Tmp4 ...</span><br><span class="line">█ Tmp4 = +++++++---</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序栈的实现及应用</title>
    <url>/2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>本文记录顺序栈的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li>
<li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li>
</ul>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SElemType *base;</span><br><span class="line">	SElemType *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空栈S</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">	<span class="keyword">if</span>(!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈S，栈S不再存在</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(S.base);</span><br><span class="line">	S.base=<span class="literal">NULL</span>;</span><br><span class="line">	S.top=<span class="literal">NULL</span>;</span><br><span class="line">	S.stacksize=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈S置为空栈</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈S为空栈，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈S的元素个数，即栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S.top-S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈不空，则用e返回S的栈顶元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top&gt;S.base)</span><br><span class="line">	&#123;</span><br><span class="line">		e=*(S.top<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈：插入元素e作为新的栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		S.base=(SElemType *)<span class="built_in">realloc</span>(S.base,</span><br><span class="line">			(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">		<span class="keyword">if</span>(!S.base)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		S.top=S.base+S.stacksize;</span><br><span class="line">		S.stacksize+=STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*S.top++=e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈：若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	e=*--S.top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.1：10进制转化为8进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conversion_3_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack s;</span><br><span class="line">	<span class="keyword">unsigned</span> n;</span><br><span class="line">	SElemType e;</span><br><span class="line"></span><br><span class="line">	InitStack(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入一个非负10进制整数："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%u"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		Push(s,n%<span class="number">8</span>);</span><br><span class="line">		n/=<span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"与其等值的8进制数为："</span>);</span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(s))</span><br><span class="line">	&#123;</span><br><span class="line">		Pop(s,e);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.2：括号匹配</span></span><br><span class="line"><span class="function">Status <span class="title">Conversion_3_2</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack s;</span><br><span class="line">	SElemType e;</span><br><span class="line"></span><br><span class="line">	InitStack(s);</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">for</span>(p=str;*p;++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*p==<span class="string">'('</span> || *p==<span class="string">'['</span> || *p==<span class="string">'&#123;'</span>)</span><br><span class="line">			Push(s,*p);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">')'</span> || *p==<span class="string">']'</span> || *p==<span class="string">'&#125;'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(StackEmpty(s))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			Pop(s,e);</span><br><span class="line">			<span class="keyword">if</span>(*p==<span class="string">')'</span> &amp;&amp; e!=<span class="string">'('</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">if</span>(*p==<span class="string">']'</span> &amp;&amp; e!=<span class="string">'['</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">if</span>(*p==<span class="string">'&#125;'</span> &amp;&amp; e!=<span class="string">'&#123;'</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!StackEmpty(s))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"算法3.1：\n"</span>);</span><br><span class="line">	Conversion_3_1();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"算法3.2：\n"</span>);</span><br><span class="line">	<span class="keyword">char</span> str[]=<span class="string">"(((1+b)-(a+3)))&#123;12[&#125;[]*4@]"</span>;</span><br><span class="line">	<span class="keyword">if</span>(Conversion_3_2(str))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"括号匹配！\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"括号不匹配！\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">算法<span class="number">3.1</span>：</span><br><span class="line">输入一个非负<span class="number">10</span>进制整数：<span class="number">1348</span></span><br><span class="line">与其等值的<span class="number">8</span>进制数为：<span class="number">2504</span></span><br><span class="line">算法<span class="number">3.2</span>：</span><br><span class="line">括号不匹配！</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL：无序关联容器</title>
    <url>/2022/05/09/C-STL%EF%BC%9A%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-无序关联容器"><a href="#1-无序关联容器" class="headerlink" title="1. 无序关联容器"></a>1. 无序关联容器</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>继 map、multimap、set、multiset 关联容器之后，本节介绍一类“特殊”的关联容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。<a id="more"></a></p>
<blockquote>
<p>注意，无序容器是 C++ 11 标准才正式引入到 STL 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p>
</blockquote>
<p>和关联容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，它们有本质上的不同：</p>
<ul>
<li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li>
<li>无序容器的底层实现采用的是哈希表的存储结构。</li>
</ul>
<blockquote>
<p>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。</p>
</blockquote>
<p>基于底层实现采用了不同的数据结构，因此和关联容器相比，无序容器具有以下 2 个特点：</p>
<ol>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联容器。</li>
</ol>
<h3 id="1-2-无序容器种类"><a href="#1-2-无序容器种类" class="headerlink" title="1.2 无序容器种类"></a>1.2 无序容器种类</h3><p>和关联容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p>
<p>下表对这 4 种无序容器的功能做了详细的介绍：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>无序容器</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>unordered_map</td>
<td>存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</key,></td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td>unordered_set</td>
<td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody>
</table>
</div>
<p>以上 4 种无序容器的名称，仅是在前面所学的 4 种关联容器名称的基础上，添加了 “unordered_”，其实它们仅有一个区别，即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。</p>
<blockquote>
<p>也就是说，C++ 11 标准的 STL 中，在已提供有 4 种关联式容器的基础上，又新增了各自的“unordered”版本（无序版本、哈希版本），提高了查找指定元素的效率。既然无序容器和之前所学的关联容器类似，那么在实际使用中应该选哪种容器呢？总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p>
</blockquote>
<p>这里以 unordered_map 容器为例，举个例子（不必深究该容器的具体用法）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_uMap&#123;</span><br><span class="line">        &#123;<span class="string">"C语言教程"</span>,<span class="string">"http://c.biancheng.net/c/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 查找指定键对应的值，效率比关联式容器高</span></span><br><span class="line">    <span class="built_in">string</span> str = my_uMap.at(<span class="string">"C语言教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"str = "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = my_uMap.<span class="built_in">begin</span>(); iter != my_uMap.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pair 类型键值对分为 2 部分</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = http://c.biancheng.net/c/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2. unordered_map"></a>2. unordered_map</h2><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p>
<blockquote>
<p>可以将 unordered_map 容器等价为无序的 map 容器。</p>
</blockquote>
<p>具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p>
<p>unordered_map 容器在<code>&lt;unordered_map&gt;</code>头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，但如果不用，则后续程序中在使用此容器时，需手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>unordered_map 容器模板的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,                        // 键值对中键的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,                          // 键值对中值的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,           // 容器内部存储键值对所用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,       // 判断各个键值对键相同的规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt; pair&lt;const Key,T&gt; &gt;  // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure>
<p>以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><key,T></key,T></td>
<td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td>
</tr>
<tr>
<td>Hash = hash\<Key></Key></td>
<td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash\<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</key></td>
</tr>
<tr>
<td>Pred = equal_to\<Key></Key></td>
<td>要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to\<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</key></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</p>
</blockquote>
<h4 id="2-2-成员方法"><a href="#2-2-成员方法" class="headerlink" title="2.2 成员方法"></a>2.2 成员方法</h4><p>unordered_map 既可以看做是关联容器，更属于自成一脉的无序容器。因此在该容器模板类中，既包含一些在学习关联容器时常见的成员方法，还有一些属于无序容器特有的成员方法。下表列出了 unordered_map 类模板提供的所有常用的成员方法以及各自的功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[key]</td>
<td>该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</td>
</tr>
<tr>
<td>at(key)</td>
<td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找以 key 键的键值对的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定键值对。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储键值对的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回以 key 为键的键值对所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_map 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，对于实现互换 2 个相同类型 unordered_map 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p>
</blockquote>
<h4 id="2-3-创建C-unordered-map容器的方法"><a href="#2-3-创建C-unordered-map容器的方法" class="headerlink" title="2.3 创建C++ unordered_map容器的方法"></a>2.3 创建C++ unordered_map容器的方法</h4><p>常见的创建 unordered_map 容器的方法有以下几种。</p>
<p>1) 通过调用 unordered_map 模板类的默认构造函数，可以创建空的 unordered_map 容器。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; umap;</span><br></pre></td></tr></table></figure>
<p>由此，就创建好了一个可存储 <string,string> 类型键值对的 unordered_map 容器。</string,string></p>
<p>2) 当然，在创建 unordered_map 容器的同时，可以完成初始化操作。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>通过此方法创建的 umap 容器中，就包含有 3 个键值对元素。</p>
<p>3) 另外，还可以调用 unordered_map 模板中提供的复制（拷贝）构造函数，将现有 unordered_map 容器中存储的键值对，复制给新建 unordered_map 容器。</p>
<p>例如，在第二种方式创建好 umap 容器的基础上，再创建并初始化一个 umap2 容器：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap2(umap);</span><br></pre></td></tr></table></figure>
<p>由此，umap2 容器中就包含有 umap 容器中所有的键值对。</p>
<p>除此之外，C++ 11 标准中还向 unordered_map 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_map 容器中存储的所有键值对，全部复制给新建容器。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_map 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt; retUmap()&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;tempUmap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempUmap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用移动构造函数，创建 umap2 容器</span></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap2(retUmap());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p>
</blockquote>
<p>4) 当然，如果不想全部拷贝，可以使用 unordered_map 类模板提供的迭代器，在现有 unordered_map 容器中选择部分区域内的键值对，为新建 unordered_map 容器初始化。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap2(++umap.begin(),umap.end());</span><br></pre></td></tr></table></figure>
<p>通过此方式创建的 umap2 容器，其内部就包含 umap 容器中除第 1 个键值对外的所有其它键值对。</p>
<h4 id="2-4-迭代器"><a href="#2-4-迭代器" class="headerlink" title="2.4 迭代器"></a>2.4 迭代器</h4><p>C++ STL 标准库中，unordered_map 容器迭代器的类型为前向迭代器（又称正向迭代器）。这意味着，假设 p 是一个前向迭代器，则其只能进行 <code>*p、p++、++p</code> 操作，且 2 个前向迭代器之间只能用 <code>==</code> 和 <code>!=</code> 运算符做比较。</p>
<p>在 unordered_map 容器模板中，提供了下表所示的成员方法，可用来获取指向指定位置的前向迭代器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>值得一提的是，equal_range(key) 很少用于 unordered_map 容器，因为该容器中存储的都是键不相等的键值对，即便调用该成员方法，得到的 2 个迭代器所表示的范围中，最多只包含 1 个键值对。事实上，该成员方法更适用于 unordered_multimap 容器。</p>
</blockquote>
<p>下面的程序演示了上表中部分成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"umap 存储的键值对包括："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 遍历输出 umap 容器中所有的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取指向指定键值对的前向迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">"Java教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"umap.find(\"Java教程\") = "</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">umap 存储的键值对包括：</span><br><span class="line">&lt;Python教程, http://c.biancheng.net/python/&gt;</span><br><span class="line">&lt;Linux教程, http://c.biancheng.net/linux/&gt;</span><br><span class="line">&lt;Java教程, http://c.biancheng.net/java/&gt;</span><br><span class="line">umap.find(<span class="string">"Java教程"</span>) = &lt;Java教程, http://c.biancheng.net/java/&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。</p>
<blockquote>
<p>所谓迭代器失效，针对的是那些用于表示容器内某个范围的迭代器，由于重哈希会重新调整每个键值对的存储位置，所以容器重哈希之后，之前表示特定范围的迭代器很可能无法再正确表示该范围。但是，重哈希并不会影响那些指向单个键值对元素的迭代器。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 向 umap 容器添加 50 个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        umap.emplace(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取键为 49 的键值对所在的范围</span></span><br><span class="line">    <span class="keyword">auto</span> pair = umap.equal_range(<span class="number">49</span>);</span><br><span class="line">    <span class="comment">// 输出 pair 范围内的每个键值对的键的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 手动调整最大负载因子数</span></span><br><span class="line">    umap.max_load_factor(<span class="number">3.0</span>);</span><br><span class="line">    <span class="comment">// 手动调用 rehash() 函数重哈希</span></span><br><span class="line">    umap.rehash(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 重哈希之后，pair 的范围可能会发生变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">49</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>观察输出结果不难发现，之前用于表示键为 49 的键值对所在范围的 2 个迭代器，重哈希之后表示的范围发生了改变。</p>
<blockquote>
<p>经测试，用于遍历整个容器的 begin()/end() 和 cbegin()/cend() 迭代器对，重哈希只会影响遍历容器内键值对的顺序，整个遍历的操作仍然可以顺利完成。</p>
</blockquote>
<h4 id="2-5-C-STL-unordered-map获取元素的几种方法"><a href="#2-5-C-STL-unordered-map获取元素的几种方法" class="headerlink" title="2.5 C++ STL unordered_map获取元素的几种方法"></a>2.5 C++ STL unordered_map获取元素的几种方法</h4><p>为了方便用户快速地从该类型容器提取出目标元素（也就是某个键值对的值），unordered_map 容器类模板中提供了以下几种方法。</p>
<p>1) unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 获取 "Java教程" 对应的值</span></span><br><span class="line">    <span class="built_in">string</span> str = umap[<span class="string">"Java教程"</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// [] 运算符在 = 右侧</span></span><br><span class="line">    <span class="built_in">string</span> str = umap[<span class="string">"STL教程"</span>];</span><br><span class="line">    <span class="comment">// [] 运算符在 = 左侧</span></span><br><span class="line">    umap[<span class="string">"C教程"</span>] = <span class="string">"http://c.biancheng.net/c/"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C教程 http://c.biancheng.net/c/</span><br><span class="line">STL教程</span><br></pre></td></tr></table></figure>
<p>可以看到，当使用 [ ] 运算符向 unordered_map 容器中添加键值对时，分为 2 种情况：</p>
<ol>
<li>当 [ ] 运算符位于赋值号（=）右侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为键值对要求的值类型的默认值（string 类型默认值为空字符串）；</li>
<li>当 [ ] 运算符位于赋值号（=）左侧时，则新添加键值对的键为 [ ] 运算符内的元素，其值为赋值号右侧的元素。</li>
</ol>
<p>2) unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出<code>out_of_range</code>异常。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 获取指定键对应的值</span></span><br><span class="line">    <span class="built_in">string</span> str = umap.at(<span class="string">"Python教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 执行此语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; umap.at("GO教程");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<p>此程序中，第 14 行代码用于获取 umap 容器中键为“Python教程”对应的值，由于 umap 容器确实有符合条件的键值对，因此可以成功执行；而第 17 行代码，由于当前 umap 容器没有存储以“Go教程”为键的键值对，因此执行此语句会抛出 out_of_range 异常。</p>
<p>3) [ ] 运算符和 at() 成员方法基本能满足大多数场景的需要。除此之外，还可以借助 unordered_map 模板中提供的 find() 成员方法。</p>
<p>和前面方法不同的是，通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p>
<ol>
<li>当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；</li>
<li>当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 查找成功</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">"Python教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter2 = umap.<span class="built_in">find</span>(<span class="string">"GO教程"</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter2 == umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"当前容器中没有以\"GO教程\"为键的键值对"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">当前容器中没有以<span class="string">"GO教程"</span>为键的键值对</span><br></pre></td></tr></table></figure>
<p>4) 除了 find() 成员方法之外，甚至可以借助 begin()/end() 或者 cbegin()/cend()，通过遍历整个容器中的键值对来找到目标键值对。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unordered_map&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建 umap 容器</span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    // 遍历整个容器中存储的键值对</span><br><span class="line">    <span class="keyword">for</span> (auto iter = umap.begin(); iter != umap.end(); ++iter) &#123;</span><br><span class="line">        //判断当前的键值对是否就是要找的</span><br><span class="line">        if (!iter-&gt;first.compare("Java教程")) &#123;</span><br><span class="line">            cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上 4 种方法中，前 2 种方法基本能满足多数场景的需要，建议初学者首选 at() 成员方法！</p>
</blockquote>
<h4 id="2-6-C-unordered-map-insert-方法"><a href="#2-6-C-unordered-map-insert-方法" class="headerlink" title="2.6 C++ unordered_map insert()方法"></a>2.6 C++ unordered_map insert()方法</h4><p>为了方便向已建 unordered_map 容器中添加新的键值对，该容器模板中提供了 insert() 方法，unordered_map 模板类中，提供了多种语法格式的 insert() 方法，根据功能的不同，可划分为以下几种用法。</p>
<p>1) insert() 方法可以将 pair 类型的键值对元素添加到 unordered_map 容器中，其语法格式有 2 种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以普通方式传递参数</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</span><br><span class="line"><span class="comment">// 以右值引用的方式传递参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span>&lt;iterator,bool&gt; <span class="title">insert</span> ( <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure>
<p>以上 2 种格式中，参数 val 表示要添加到容器中的目标键值对元素；该方法的返回值为 pair类型值，内部包含一个 iterator 迭代器和 bool 变量：</p>
<ul>
<li>当 insert() 将 val 成功添加到容器中时，返回的迭代器指向新添加的键值对，bool 值为 True；</li>
<li>当 insert() 添加键值对失败时，意味着当前容器中本就存储有和要添加键值对的键相等的键值对，这种情况下，返回的迭代器将指向这个导致插入操作失败的迭代器，bool 值为 False。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 构建要添加的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mypair(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 创建接收 insert() 方法返回值的pair类型变量</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    <span class="comment">// 调用 insert() 方法的第一种语法格式</span></span><br><span class="line">    ret = umap.insert(mypair);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; ret.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; ret.first-&gt;first &lt;&lt;<span class="string">" "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用 insert() 方法的第二种语法格式</span></span><br><span class="line">    ret = umap.insert(<span class="built_in">std</span>::make_pair(<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool = "</span> &lt;&lt; ret.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">bool = <span class="number">1</span></span><br><span class="line">iter -&gt; STL教程 http://c.biancheng.net/stl/</span><br><span class="line">bool = <span class="number">1</span></span><br><span class="line">iter -&gt; Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<p>从输出结果很容易看出，两次添加键值对的操作，insert() 方法返回值中的 bool 变量都为 1，表示添加成功，此时返回的迭代器指向的是添加成功的键值对。</p>
<p>2) 除此之外，insert() 方法还可以指定新键值对要添加到容器中的位置，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以普通方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">( const_iterator hint, <span class="keyword">const</span> value_type&amp; val )</span></span>;</span><br><span class="line"><span class="comment">// 以右值引用方法传递 val 参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">iterator</span> <span class="title">insert</span> ( <span class="title">const_iterator</span> <span class="title">hint</span>, <span class="title">P</span>&amp;&amp; <span class="title">val</span> );</span></span><br></pre></td></tr></table></figure>
<p>以上 2 种语法格式中，hint 参数为迭代器，用于指定新键值对要添加到容器中的位置；val 参数指的是要添加容器中的键值对；方法的返回值为迭代器：</p>
<ul>
<li>如果 insert() 方法成功添加键值对，该迭代器指向新添加的键值对；</li>
<li>如果 insert() 方法添加键值对失败，则表示容器中本就包含有相同键的键值对，该方法返回的迭代器就指向容器中键相同的键值对；</li>
</ul>
<blockquote>
<p>注意，以上 2 种语法格式中，虽然通过 hint 参数指定了新键值对添加到容器中的位置，但该键值对真正存储的位置，并不是 hint 参数说了算，最终的存储位置仍取决于该键值对的键的值。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 构建要添加的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mypair(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 创建接收 insert() 方法返回值的迭代器类型变量</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">// 调用第一种语法格式</span></span><br><span class="line">    iter = umap.insert(umap.<span class="built_in">begin</span>(), mypair);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用第二种语法格式</span></span><br><span class="line">    iter = umap.insert(umap.<span class="built_in">begin</span>(),<span class="built_in">std</span>::make_pair(<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt; "</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">iter -&gt; STL教程 http://c.biancheng.net/stl/</span><br><span class="line">iter -&gt; Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<p>3) insert() 方法还支持将某一个 unordered_map 容器中指定区域内的所有键值对，复制到另一个 unordered_map 容器中，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">insert</span> ( <span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span> );</span></span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 都为迭代器，<code>[first, last)</code>表示复制其它 unordered_map 容器中键值对的区域。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 创建一个空的 unordered_map 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; otherumap;</span><br><span class="line">    <span class="comment">// 指定要拷贝 umap 容器中键值对的范围</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++umap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = umap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 将指定 umap 容器中 [first,last) 区域内的键值对复制给 otherumap 容器</span></span><br><span class="line">    otherumap.insert(first, last);</span><br><span class="line">    <span class="comment">// 遍历 otherumap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherumap.<span class="built_in">begin</span>(); iter != otherumap.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Python教程 http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">Java教程 http:<span class="comment">//c.biancheng.net/java/</span></span><br></pre></td></tr></table></figure>
<p>4) 除了以上 3 种方式，insert() 方法还支持一次向 unordered_map 容器添加多个键值对，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，il 参数指的是可以用初始化列表的形式指定多个键值对元素。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建空的 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 向 umap 容器同时添加多个键值对</span></span><br><span class="line">    umap.insert(&#123; &#123;<span class="string">"STL教程"</span>,<span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;);</span><br><span class="line">    <span class="comment">// 遍历输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<p>总的来说，unordered_map 模板类提供的 insert() 方法有以上 4 种，我们可以根据实际场景的需要自行选择使用哪一种。</p>
<h4 id="2-7-C-unordered-map-emplace-和emplace-hint-方法"><a href="#2-7-C-unordered-map-emplace-和emplace-hint-方法" class="headerlink" title="2.7 C++ unordered_map emplace()和emplace_hint()方法"></a>2.7 C++ unordered_map emplace()和emplace_hint()方法</h4><p>和前面学的 map、set 等容器一样，C++ 11 标准也为 unordered_map 容器新增了 emplace() 和 emplace_hint() 成员方法。我们知道，实现向已有 unordered_map 容器中添加新键值对，可以通过调用 insert() 方法，但其实还有更好的方法，即使用 emplace() 或者 emplace_hint() 方法，它们完成“向容器中添加新键值对”的效率，要比 insert() 方法高。</p>
<h5 id="2-7-1-unordered-map-emplace-方法"><a href="#2-7-1-unordered-map-emplace-方法" class="headerlink" title="2.7.1 unordered_map emplace()方法"></a>2.7.1 unordered_map emplace()方法</h5><p>emplace() 方法的用法很简单，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">pair</span>&lt;iterator, bool&gt; <span class="title">emplace</span> ( <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br></pre></td></tr></table></figure>
<p>其中，参数 args 表示可直接向该方法传递创建新键值对所需要的 2 个元素的值，其中第一个元素将作为键值对的键，另一个作为键值对的值。也就是说，该方法无需我们手动创建键值对，其内部会自行完成此工作。</p>
<p>另外需要注意的是，该方法的返回值为 pair 类型值，其包含一个迭代器和一个 bool 类型值：</p>
<ul>
<li>当 emplace() 成功添加新键值对时，返回的迭代器指向新添加的键值对，bool 值为 True；</li>
<li>当 emplace() 添加新键值对失败时，说明容器中本就包含一个键相等的键值对，此时返回的迭代器指向的就是容器中键相同的这个键值对，bool 值为 False。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 定义一个接受 emplace() 方法的 pair 类型变量</span></span><br><span class="line">    pair&lt;<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    <span class="comment">// 调用 emplace() 方法</span></span><br><span class="line">    ret = umap.emplace(<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 输出 ret 中包含的 2 个元素的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool ="</span> &lt;&lt; ret.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt;"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">bool =<span class="number">1</span></span><br><span class="line">iter -&gt;STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<p>通过执行结果中 bool 变量的值为 1 可以得知，emplace() 方法成功将新键值对添加到了 umap 容器中。</p>
<h5 id="2-7-2-unordered-map-emplace-hint-方法"><a href="#2-7-2-unordered-map-emplace-hint-方法" class="headerlink" title="2.7.2 unordered_map emplace_hint()方法"></a>2.7.2 unordered_map emplace_hint()方法</h5><p>emplace_hint() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">iterator</span> <span class="title">emplace_hint</span> ( <span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br></pre></td></tr></table></figure>
<p>和 emplace() 方法相同，emplace_hint() 方法内部会自行构造新键值对，因此我们只需向其传递构建该键值对所需的 2 个元素（第一个作为键，另一个作为值）即可。不同之处在于：</p>
<ul>
<li>emplace_hint() 方法的返回值仅是一个迭代器，而不再是 pair 类型变量。当该方法将新键值对成功添加到容器中时，返回的迭代器指向新添加的键值对；反之，如果添加失败，该迭代器指向的是容器中和要添加键值对键相同的那个键值对。</li>
<li>emplace_hint() 方法还需要传递一个迭代器作为第一个参数，该迭代器表明将新键值对添加到容器中的位置。需要注意的是，新键值对添加到容器中的位置，并不是此迭代器说了算，最终仍取决于该键值对的键的值。</li>
</ul>
<blockquote>
<p>可以这样理解，emplace_hint() 方法中传入的迭代器，仅是给 unordered_map 容器提供一个建议，并不一定会被容器采纳。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap;</span><br><span class="line">    <span class="comment">// 定义一个接受 emplace_hint() 方法的迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">// 调用 empalce_hint() 方法</span></span><br><span class="line">    iter = umap.emplace_hint(umap.<span class="built_in">begin</span>(),<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>);</span><br><span class="line">    <span class="comment">// 输出 emplace_hint() 返回迭代器 iter 指向的键值对的内容</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter -&gt;"</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">iter -&gt;STL教程 http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>
<h4 id="2-8-C-STL-unordered-map删除元素：erase-和clear"><a href="#2-8-C-STL-unordered-map删除元素：erase-和clear" class="headerlink" title="2.8 C++ STL unordered_map删除元素：erase()和clear()"></a>2.8 C++ STL unordered_map删除元素：erase()和clear()</h4><p>C++ STL 标准库为了方便用户可以随时删除 unordered_map 容器中存储的键值对，unordered_map 容器类模板中提供了以下 2 个成员方法：</p>
<ul>
<li>erase()：删除 unordered_map 容器中指定的键值对；</li>
<li>clear()：删除 unordered_map 容器中所有的键值对，即清空容器。</li>
</ul>
<h5 id="2-8-1-unordered-map-erase-方法"><a href="#2-8-1-unordered-map-erase-方法" class="headerlink" title="2.8.1 unordered_map erase()方法"></a>2.8.1 unordered_map erase()方法</h5><p>为了满足不同场景删除 unordered_map 容器中键值对的需要，此容器的类模板中提供了 3 种语法格式的 erase() 方法。</p>
<p>1) erase() 方法可以接受一个正向迭代器，并删除该迭代器指向的键值对。该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">( const_iterator <span class="built_in">position</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 position 为指向容器中某个键值对的迭代器，该方法会返回一个指向被删除键值对之后位置的迭代器。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"erase:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 定义一个接收 erase() 方法的迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator ret;</span><br><span class="line">    <span class="comment">// 删除容器中第一个键值对</span></span><br><span class="line">    ret = umap.erase(umap.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; ret-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; ret-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">erase:</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">ret = Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<p>可以看到，通过给 erase() 方法传入指向容器中第一个键值对的迭代器，该方法可以将容器中第一个键值对删除，同时返回一个指向被删除键值对之后位置的迭代器。</p>
<blockquote>
<p>注意，如果erase()方法删除的是容器存储的最后一个键值对，则该方法返回的迭代器，将指向容器中最后一个键值对之后的位置（等同于 end() 方法返回的迭代器）。</p>
</blockquote>
<p>2) 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。erase() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，k 表示目标键值对的键的值；该方法会返回一个整数，其表示成功删除的键值对的数量。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;; </span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> delNum = umap.erase(<span class="string">"Python教程"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"delNum = "</span> &lt;&lt; delNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 再次输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">delNum = <span class="number">1</span></span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<p>通过输出结果可以看到，通过将 “Python教程” 传给 erase() 方法，就成功删除了 umap 容器中键为 “Python教程” 的键值对。</p>
<p>3) 除了支持删除 unordered_map 容器中指定的某个键值对，erase() 方法还支持一次删除指定范围内的所有键值对，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 first 和 last 都是正向迭代器，[first, last) 范围内的所有键值对都会被 erase() 方法删除；同时，该方法会返回一个指向被删除的最后一个键值对之后一个位置的迭代器。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// first 指向第一个键值对</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = umap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// last 指向最后一个键值对</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = umap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 删除[fist,last)范围内的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> ret = umap.erase(first, last);</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行程序会发现，没有输出任何数据，因为 erase() 方法删除了 umap 容器中 [begin(), end()) 范围内所有的元素。</p>
<h5 id="2-8-2-unordered-map-clear-方法"><a href="#2-8-2-unordered-map-clear-方法" class="headerlink" title="2.8.2 unordered_map clear()方法"></a>2.8.2 unordered_map clear()方法</h5><p>在个别场景中，可能需要一次性删除 unordered_map 容器中存储的所有键值对，可以使用 clear() 方法，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 umap 容器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">"STL教程"</span>, <span class="string">"http://c.biancheng.net/stl/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>, <span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>, <span class="string">"http://c.biancheng.net/java/"</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// 输出 umap 容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除容器内所有键值对</span></span><br><span class="line">    umap.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"umap size = "</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br><span class="line">umap size = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>显然，通过调用 clear() 方法，原本包含 3 个键值对的 umap 容器，变成了空容器。</p>
<blockquote>
<p>注意，虽然使用 erase() 方法的第 3 种语法格式，可能实现删除 unordered_map 容器内所有的键值对，但更推荐使用 clear() 方法。</p>
</blockquote>
<hr>
<h2 id="3-unordered-multimap"><a href="#3-unordered-multimap" class="headerlink" title="3. unordered_multimap"></a>3. unordered_multimap</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>C++ STL 标准库中，除了提供有 unordered_map 无序关联容器，还提供有和 unordered_map 容器非常相似的 unordered_multimap 无序关联容器。</p>
<p>和 unordered_map 容器一样，unordered_multimap 容器也以键值对的形式存储数据，且底层也采用哈希表结构存储各个键值对。两者唯一的不同之处在于，unordered_multimap 容器可以存储多个键相等的键值对，而 unordered_map 容器不行。</p>
<blockquote>
<p>无序容器中存储的各个键值对，都会哈希存到各个桶（本质为链表）中。而对于 unordered_multimap 容器来说，其存储的所有键值对中，键相等的键值对会被哈希到同一个桶中存储。</p>
</blockquote>
<p>另外值得一提得是，STL 标准库中实现 unordered_multimap 容器的模板类并没有定义在以自己名称命名的头文件中，而是和 unordered_map 容器一样，定义在<code>&lt;unordered_map&gt;</code>头文件，且位于 std 命名空间中。因此，在使用 unordered_multimap 容器之前，程序中应包含如下 2 行代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，但如果不用，则后续程序中在使用此容器时，需手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>unordered_multimap 容器模板的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,      // 键（<span class="title">key</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">T</span>,        // 值（<span class="title">value</span>）的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,  // 底层存储键值对时采用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,  // 判断各个键值对的键相等的规则</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt; pair&lt;const Key,T&gt; &gt; // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_multimap</span>;</span></span><br></pre></td></tr></table></figure>
<p>以上 5 个参数中，必须显式给前 2 个参数传值，且除极个别的情况外，最多只使用前 4 个参数，它们各自的含义和功能如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><key,T></key,T></td>
<td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td>
</tr>
<tr>
<td>Hash = hash\<Key></Key></td>
<td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash\<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</key></td>
</tr>
<tr>
<td>Pred = equal_to\<Key></Key></td>
<td>unordered_multimap 容器可以存储多个键相等的键值对，而判断是否相等的规则，由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to\<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</key></td>
</tr>
</tbody>
</table>
</div>
<p>注意，当 unordered_multimap 容器中存储键值对的键为自定义类型时，默认的哈希函数 hash\<key> 以及比较函数 equal_to\<key> 将不再适用，这种情况下，需要我们自定义适用的哈希函数和比较函数，并分别显式传递给 Hash 参数和 Pred 参数。</key></key></p>
<h3 id="3-2-成员方法"><a href="#3-2-成员方法" class="headerlink" title="3.2 成员方法"></a>3.2 成员方法</h3><p>和 unordered_map 容器相比，unordered_multimap 容器的类模板中没有重载 [ ] 运算符，也没有提供 at() 成员方法，除此之外它们完全一致。</p>
<blockquote>
<p>没有提供 [ ] 运算符和 at() 成员方法，意味着 unordered_multimap 容器无法通过指定键获取该键对应的值，因为该容器允许存储多个键相等的键值对，每个指定的键可能对应多个不同的值。</p>
</blockquote>
<p>unordered_multimap 类模板提供的成员方法如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找以 key 键的键值对的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定键值对。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储键值对的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回以 key 为键的键值对所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_multimap 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，对于实现互换 2 个相同类型 unordered_multimap 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p>
</blockquote>
<h3 id="3-3-创建C-unordered-multimap容器"><a href="#3-3-创建C-unordered-multimap容器" class="headerlink" title="3.3 创建C++ unordered_multimap容器"></a>3.3 创建C++ unordered_multimap容器</h3><p>常见的创建 unordered_map 容器的方法有以下几种。</p>
<p>1) 利用 unordered_multimap 容器类模板中的默认构造函数，可以创建空的 unordered_multimap 容器。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; myummap;</span><br></pre></td></tr></table></figure>
<p>由此，就创建好了一个可存储 <string, string> 类型键值对的 unordered_multimap 容器，只不过当前容器是空的，即没有存储任何键值对。</string,></p>
<p>2) 当然，在创建空 unordered_multimap 容器的基础上，可以完成初始化操作。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; myummap&#123;</span><br><span class="line">    &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>通过此方法创建的 myummap 容器中，就包含有 3 个键值对。</p>
<p>3) 另外，unordered_multimap 模板中还提供有复制（拷贝）构造函数，可以实现在创建 unordered_multimap 容器的基础上，用另一 unordered_multimap 容器中的键值对为其初始化。</p>
<p>例如，在第二种方式创建好 myummap 容器的基础上，再创建并初始化一个 myummap2 容器：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">unordered_multimap&lt;string, string&gt; myummap2(myummap);</span><br></pre></td></tr></table></figure>
<p>由此，刚刚创建好的 myummap2 容器中，就包含有 myummap 容器中所有的键值对。</p>
<p>除此之外，C++ 11 标准中还向 unordered_multimap 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_multimap 容器中存储的所有键值对，全部复制给新建容器。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_multimap 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multimap</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt; retUmmap() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;tempummap&#123;</span><br><span class="line">        &#123;<span class="string">"Python教程"</span>,<span class="string">"http://c.biancheng.net/python/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Java教程"</span>,<span class="string">"http://c.biancheng.net/java/"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Linux教程"</span>,<span class="string">"http://c.biancheng.net/linux/"</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempummap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并初始化 myummap 容器</span></span><br><span class="line">std::unordered_multimap&lt;std::string, std::string&gt; myummap(retummap());</span><br></pre></td></tr></table></figure>
<p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p>
<p>4) 当然，如果不想全部拷贝，可以使用 unordered_multimap 类模板提供的迭代器，在现有 unordered_multimap 容器中选择部分区域内的键值对，为新建 unordered_multimap 容器初始化。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line">std::unordered_multimap&lt;std::string, std::string&gt; myummap2(++myummap.begin(), myummap.end());</span><br></pre></td></tr></table></figure>
<p>通过此方式创建的 myummap2 容器，其内部就包含 myummap 容器中除第 1 个键值对外的所有其它键值对。</p>
<hr>
<h2 id="4-unordered-set"><a href="#4-unordered-set" class="headerlink" title="4. unordered_set"></a>4. unordered_set</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p>
<p>总的来说，unordered_set 容器具有以下几个特性：</p>
<ol>
<li>不再以键值对的形式存储数据，而是直接存储数据的值；</li>
<li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li>
<li>不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关）。</li>
</ol>
<blockquote>
<p>对于 unordered_set 容器不以键值对的形式存储数据，也可以这样认为，即 unordered_set 存储的都是键和值相等的键值对，为了节省存储空间，该类容器在实际存储时选择只存储每个键值对的值。</p>
</blockquote>
<p>另外，实现 unordered_set 容器的模板类定义在<code>&lt;unordered_set&gt;</code>头文件，并位于 std 命名空间中。这意味着，如果程序中需要使用该类型容器，则首先应该包含如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，但如果不用，则程序中只要用到该容器时，必须手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>unordered_set 容器的类模板定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,            // 容器中存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,    // 确定元素存储位置所用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,   // 判断各个元素是否相等所用的函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;Key&gt;   // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_set</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，以上 4 个参数中，只有第一个参数没有默认值，这意味着如果我们想创建一个 unordered_set 容器，至少需要手动传递 1 个参数。事实上，在 99% 的实际场景中最多只需要使用前 3 个参数（各自含义如下表所示），最后一个参数保持默认值即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key</td>
<td>确定容器存储元素的类型，如果读者将 unordered_set 看做是存储键和值相同的键值对的容器，则此参数则用于确定各个键值对的键和值的类型，因为它们是完全相同的，因此一定是同一数据类型的数据。</td>
</tr>
<tr>
<td>Hash = hash\<Key></Key></td>
<td>指定 unordered_set 容器底层存储各个元素时，所使用的哈希函数。需要注意的是，默认哈希函数 hash\<Key> 只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</Key></td>
</tr>
<tr>
<td>Pred = equal_to\<Key></Key></td>
<td>unordered_set 容器内部不能存储相等的元素，而衡量 2 个元素是否相等的标准，取决于该参数指定的函数。 默认情况下，使用 STL 标准库中提供的 equal_to\<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</key></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，如果 unordered_set 容器中存储的元素为自定义的数据类型，则默认的哈希函数 hash\<key> 以及比较函数 equal_to\<key> 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</key></key></p>
</blockquote>
<h3 id="4-2-成员方法"><a href="#4-2-成员方法" class="headerlink" title="4.2 成员方法"></a>4.2 成员方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器。</td>
</tr>
<tr>
<td>end();</td>
<td>返回指向容器中最后一个元素之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找值为 key 的元素的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新元素，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新元素，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_map 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储元素的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回值为 key 的元素所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_map 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody>
</table>
</div>
<p>注意，此容器模板类中没有重载 [ ] 运算符，也没有提供 at() 成员方法。不仅如此，由于 unordered_set 容器内部存储的元素值不能被修改，因此无论使用那个迭代器方法获得的迭代器，都不能用于修改容器中元素的值。</p>
<p>另外，对于实现互换 2 个相同类型 unordered_set 容器的所有元素，除了调用上表中的 swap() 成员方法外，还可以使用 STL 标准库提供的 swap() 非成员函数，它们具有相同的名称，用法也相同（都只需要传入 2 个参数即可），仅是调用方式上有差别。</p>
<h3 id="4-3-创建C-unordered-set容器"><a href="#4-3-创建C-unordered-set容器" class="headerlink" title="4.3 创建C++ unordered_set容器"></a>4.3 创建C++ unordered_set容器</h3><p>前面介绍了如何创建 unordered_map 和 unordered_multimap 容器，值得一提的是，创建它们的所有方式完全适用于 unordereded_set 容器。</p>
<p>1) 通过调用 unordered_set 模板类的默认构造函数，可以创建空的 unordered_set 容器。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uset;</span><br></pre></td></tr></table></figure>
<p>由此，就创建好了一个可存储 string 类型值的 unordered_set 容器，该容器底层采用默认的哈希函数 hash\<Key> 和比较函数 equal_to\<Key>。</Key></Key></p>
<p>2) 当然，在创建 unordered_set 容器的同时，可以完成初始化操作。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; uset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                      <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                      <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>通过此方法创建的 uset 容器中，就包含有 3 个 string 类型元素。</p>
<p>3) 还可以调用 unordered_set 模板中提供的复制（拷贝）构造函数，将现有 unordered_set 容器中存储的元素全部用于为新建 unordered_set 容器初始化。</p>
<p>例如，在第二种方式创建好 uset 容器的基础上，再创建并初始化一个 uset2 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uset2</span><span class="params">(uset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此，umap2 容器中就包含有 umap 容器中所有的元素。</p>
<p>除此之外，C++ 11 标准中还向 unordered_set 模板类增加了移动构造函数，即以右值引用的方式，利用临时 unordered_set 容器中存储的所有元素，给新建容器初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_set 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; retuset() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempuset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                              <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                              <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempuset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用移动构造函数，创建 uset 容器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uset</span><span class="params">(retuset())</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p>
</blockquote>
<p>4) 当然，如果不想全部拷贝，可以使用 unordered_set 类模板提供的迭代器，在现有 unordered_set 容器中选择部分区域内的元素，为新建 unordered_set 容器初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">uset2</span><span class="params">(++uset.<span class="built_in">begin</span>(),uset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建的 uset2 容器，其内部就包含 uset 容器中除第 1 个元素外的所有其它元素。</p>
<hr>
<h2 id="5-unordered-multiset"><a href="#5-unordered-multiset" class="headerlink" title="5. unordered_multiset"></a>5. unordered_multiset</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>前面章节介绍了 unordered_set 容器的特定和用法，在此基础上，本节再介绍一个类似的 C++ STL 无序容器，即 unordered_multiset 容器。</p>
<p>所谓“类似”，指的是 unordered_multiset 容器大部分的特性都和 unordered_set 容器相同，包括：</p>
<ol>
<li>unordered_multiset 不以键值对的形式存储数据，而是直接存储数据的值；</li>
<li>该类型容器底层采用的也是哈希表存储结构，它不会对内部存储的数据进行排序；</li>
<li>unordered_multiset 容器内部存储的元素，其值不能被修改。</li>
</ol>
<p>和 unordered_set 容器不同的是，unordered_multiset 容器可以同时存储多个值相同的元素，且这些元素会存储到哈希表中同一个桶（本质就是链表）上。</p>
<blockquote>
<p>可以这样认为，unordered_multiset 除了能存储相同值的元素外，它和 unordered_set 容器完全相同。</p>
</blockquote>
<p>另外值得一提的是，实现 unordered_multiset 容器的模板类并没有定义在以该容器名命名的文件中，而是和 unordered_set 容器共用同一个<code>&lt;unordered_set&gt;</code>头文件，并且也位于 std 命名空间。因此，如果程序中需要使用该类型容器，应包含如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，第二行代码不是必需的，但如果不用，则程序中只要用到该容器时，必须手动注明 std 命名空间（建议初学者使用）。</p>
</blockquote>
<p>unordered_multiset 容器类模板的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,            // 容器中存储元素的类型</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,    // 确定元素存储位置所用的哈希函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Pred</span> = <span class="title">equal_to</span>&lt;Key&gt;,   // 判断各个元素是否相等所用的函数</span></span><br><span class="line"><span class="class">           <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">allocator</span>&lt;Key&gt;   // 指定分配器对象的类型</span></span><br><span class="line"><span class="class">           &gt; <span class="title">class</span> <span class="title">unordered_multiset</span>;</span></span><br></pre></td></tr></table></figure>
<p>需要说明的是，在 99% 的实际场景中，最多只需要使用前 3 个参数（各自含义如下表所示），最后一个参数保持默认值即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key</td>
<td>确定容器存储元素的类型，如果读者将 unordered_multiset 看做是存储键和值相同的键值对的容器，则此参数则用于确定各个键值对的键和值的类型，因为它们是完全相同的，因此一定是同一数据类型的数据。</td>
</tr>
<tr>
<td>Hash = hash\<Key></Key></td>
<td>指定 unordered_multiset 容器底层存储各个元素时所使用的哈希函数。需要注意的是，默认哈希函数 hash\<Key> 只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</Key></td>
</tr>
<tr>
<td>Pred = equal_to\<Key></Key></td>
<td>用于指定 unordered_multiset 容器判断元素值相等的规则。默认情况下，使用 STL 标准库中提供的 equal_to\<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</key></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>总之，如果 unordered_multiset 容器中存储的元素为自定义的数据类型，则默认的哈希函数 hash\<key> 以及比较函数 equal_to\<key> 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。</key></key></p>
</blockquote>
<h3 id="5-2-成员函数"><a href="#5-2-成员函数" class="headerlink" title="5.2 成员函数"></a>5.2 成员函数</h3><p>unordered_multiset 模板类中提供的成员方法，无论是种类还是数量，都和 unordered_set 类模板一样，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器。</td>
</tr>
<tr>
<td>end();</td>
<td>返回指向容器中最后一个元素之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找值为 key 的元素的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新元素，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新元素，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_multimap 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储元素的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回值为 key 的元素所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回容器当前的负载因子。所谓负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_map 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody>
</table>
</div>
<p>注意，和 unordered_set 容器一样，unordered_multiset 模板类也没有重载 [ ] 运算符，没有提供 at() 成员方法。不仅如此，无论是由哪个成员方法返回的迭代器，都不能用于修改容器中元素的值。</p>
<p>另外，对于互换 2 个相同类型 unordered_multiset 容器存储的所有元素，除了调用上表中的 swap() 成员方法外，STL 标准库也提供了 swap() 非成员函数。</p>
<h3 id="5-3-创建C-unordered-multiset容器"><a href="#5-3-创建C-unordered-multiset容器" class="headerlink" title="5.3 创建C++ unordered_multiset容器"></a>5.3 创建C++ unordered_multiset容器</h3><p>考虑到不同场景的需要，unordered_multiset 容器模板类共提供了以下 4 种创建 unordered_multiset 容器的方式。</p>
<p>1) 调用 unordered_multiset 模板类的默认构造函数，可以创建空的 unordered_multiset 容器。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; umset;</span><br></pre></td></tr></table></figure>
<p>由此，就创建好了一个可存储 string 类型值的 unordered_multiset 容器，该容器底层采用默认的哈希函数 hash\<Key> 和比较函数 equal_to\<Key>。</Key></Key></p>
<p>2) 当然，在创建 unordered_multiset 容器的同时，可以进行初始化操作。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; umset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                            <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                            <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>通过此方法创建的 umset 容器中，内部存有 3 个 string 类型元素。</p>
<p>3) 还可以调用 unordered_multiset 模板中提供的复制（拷贝）构造函数，将现有 unordered_multiset 容器中存储的元素全部用于为新建 unordered_multiset 容器初始化。</p>
<p>例如，在第二种方式创建好 umset 容器的基础上，再创建并初始化一个 umset2 容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">umset2</span><span class="params">(umset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由此，umap2 容器中就包含有 umap 容器中所有的元素。</p>
<p>除此之外，C++ 11 标准中还向 unordered_multiset 模板类增加了移动构造函数，即以右值引用的方式，利用临时 unordered_multiset 容器中存储的所有元素，给新建容器初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回临时 unordered_multiset 容器的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; retumset() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempumset&#123; <span class="string">"http://c.biancheng.net/c/"</span>,</span><br><span class="line">                                                    <span class="string">"http://c.biancheng.net/java/"</span>,</span><br><span class="line">                                                    <span class="string">"http://c.biancheng.net/linux/"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempumset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用移动构造函数，创建 umset 容器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">umset</span><span class="params">(retumset())</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p>
</blockquote>
<p>4) 当然，如果不想全部拷贝，可以使用 unordered_multiset 类模板提供的迭代器，在现有 unordered_multiset 容器中选择部分区域内的元素，为新建的 unordered_multiset 容器初始化。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 2 个迭代器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">umset2</span><span class="params">(++umset.<span class="built_in">begin</span>(), umset.<span class="built_in">end</span>())</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过此方式创建的 umset2 容器，其内部就包含 umset 容器中除第 1 个元素外的所有其它元素。</p>
]]></content>
      <categories>
        <category>C++STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：explicit关键字</title>
    <url>/2023/03/30/C-%EF%BC%9Aexplicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>C++中的explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显示的，而非隐式的，跟它相对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下即声明为implicit(隐式)。<a id="more"></a></p>
<p>那么显示声明的构造函数和隐式声明的有什么区别呢? 来看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 没有使用<span class="title">explicit</span>关键字的类声明, 即默认为隐式声明  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    CxString(<span class="keyword">int</span> <span class="built_in">size</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        _size = <span class="built_in">size</span>;                <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = <span class="built_in">malloc</span>(<span class="built_in">size</span> + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, <span class="built_in">size</span> + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    CxString(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = <span class="built_in">malloc</span>(<span class="built_in">size</span> + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的, 为CxString预分配24字节的大小的内存  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是OK的, 为CxString预分配10字节的大小的内存  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数, 错误为: “CxString”: 没有合适的默认构造函数可用  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">"aaaa"</span>)</span></span>; <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string5 = <span class="string">"bbb"</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></span><br><span class="line">    CxString string6 = <span class="string">'c'</span>;   <span class="comment">// 这样也是OK的, 其实调用的是CxString(int size), 且size等于'c'的ascii码  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是OK的, 为CxString预分配2字节的大小的内存  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是OK的, 为CxString预分配3字节的大小的内存  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是OK的, 至少编译是没问题的, free释放_pstr内存指针的时候可能会报错, 完整的代码必须重载运算符"=", 并在其中处理内存释放</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/30/C-%EF%BC%9Aexplicit%E5%85%B3%E9%94%AE%E5%AD%97/pic1.png" alt></p>
<p>上面的代码中, “CxString string2 = 10;” 这句为什么是可以的呢？</p>
<p>在C++中, 如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。也就是说 “CxString string2 = 10;” 这段代码，编译器自动将整型转换为CxString类对象，实际上等同于下面的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CxString <span class="title">string2</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line"><span class="comment">// 或如下代码</span></span><br><span class="line"><span class="function">CxString <span class="title">temp</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line">CxString string2 = temp;</span><br></pre></td></tr></table></figure>
<p>但是，上面的代码中的_size代表的是字符串内存分配的大小，那么调用的第二句 “CxString string2 = 10;” 和第六句 “CxString string6 = ‘c’;” 就显得不伦不类，而且容易让人疑惑。有什么办法阻止这种用法呢？答案就是使用explicit关键字。我们把上面的代码修改一下，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 使用关键字<span class="title">explicit</span>的类声明, 显示转换  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="keyword">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _size = size;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    CxString(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是不行的, 因为explicit关键字取消了隐式转换  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">"aaaa"</span>)</span></span>; <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string5 = <span class="string">"bbb"</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></span><br><span class="line">    CxString string6 = <span class="string">'c'</span>;   <span class="comment">// 这样是不行的, 其实调用的是CxString(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/03/30/C-%EF%BC%9Aexplicit%E5%85%B3%E9%94%AE%E5%AD%97/pic2.png" alt></p>
<p>explicit关键字的作用就是防止类构造函数的隐式自动转换。</p>
<p>如上面所说， explicit关键字只对有一个参数的类构造函数有效，如果类构造函数参数大于或等于两个时，是不会产生隐式转换的，所以explicit关键字也就无效了。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // <span class="title">explicit</span>关键字在类构造函数参数大于或等于两个时无效  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _age;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _age = age;  </span><br><span class="line">        _size = size;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    CxString(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这个时候有没有explicit关键字都是一样的</span></span><br></pre></td></tr></table></figure>
<p>但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数, 例子如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 使用关键字<span class="title">explicit</span>声明  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">int</span> _age;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> size = <span class="number">0</span>)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _age = age;  </span><br><span class="line">        _size = size;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    CxString(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是不行的, 因为explicit关键字取消了隐式转换  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载</span></span><br></pre></td></tr></table></figure>
<p>总结：<br>explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。</p>
<p>google的c++规范中提到：explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit，例如作为其他类的透明包装器的类。<br>effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake多级目录编译</title>
    <url>/2023/04/21/Cmake%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>以下面的C++程序多级目录为例：</p>
<p><img src="/2023/04/21/Cmake%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BC%96%E8%AF%91/目录结构.png" alt></p>
<p>根目录的CMakelists.txt示例代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span><span class="number">.0</span>)</span><br><span class="line">project(cppjson VERSION <span class="number">0.1</span><span class="number">.0</span>)</span><br><span class="line"></span><br><span class="line"># The <span class="keyword">default</span> include directory</span><br><span class="line">include_directories(./)</span><br><span class="line"></span><br><span class="line"><span class="meta"># home directory source</span></span><br><span class="line">aux_source_directory(. ROOT_SOURCE)</span><br><span class="line"></span><br><span class="line"><span class="meta"># sub directory source</span></span><br><span class="line">add_subdirectory(json)</span><br><span class="line"></span><br><span class="line"><span class="meta"># build executable file</span></span><br><span class="line">add_executable(main $&#123;ROOT_SOURCE&#125; $&#123;PARSER_SRC&#125;)</span><br></pre></td></tr></table></figure>
<p>子目录的CMakelists.txt示例代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># sub directory source</span></span><br><span class="line">aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125; PARSER_SRC)</span><br><span class="line"><span class="built_in">set</span>(PARSER_SRC $&#123;PARSER_SRC&#125; PARENT_SCOPE)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++ Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割算法</title>
    <url>/2023/06/10/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>图像分割是指将图像分成若干互不重叠的子区域，使得同一个子区域内的特征具有一定相似性，不同子区域的特征呈现较为明显的差异。之前介绍了基于阈值的分割方法，比如Otsu法等；基于边缘检测的分割方法，比如Sobel算子、Canny算子等。下面介绍<strong>基于区域的分割方法</strong>和<strong>基于图的分割方法</strong>。<a id="more"></a></p>
<h1 id="1-基于区域的分割方法"><a href="#1-基于区域的分割方法" class="headerlink" title="1. 基于区域的分割方法"></a>1. 基于区域的分割方法</h1><p>基于区域的分割算法将具有相似特征的像素集合聚集构成一个区域，这个区域中的相邻像素之间具有相似的性质，主要包括<strong>区域生长算法、区域分裂合并算法和分水岭算法</strong>等。</p>
<h2 id="1-1-区域生长算法"><a href="#1-1-区域生长算法" class="headerlink" title="1.1 区域生长算法"></a>1.1 区域生长算法</h2><p>区域生长的基本思想是将具有相似性质的像素集合起来构成区域。具体先对每个需要分割的区域找一个种子像素作为生长起点，然后将种子像素和周围邻域中与种子像素有相同或相似性质的像素（根据某种事先确定的生长或相似准则来判定）合并到种子像素所在的区域中。将这些新像素当作新的种子继续上面的过程，直到没有满足条件的像素可被包括进来，这样一个区域就生长成了。</p>
<p>区域生长实现步骤如下:</p>
<ol>
<li>对图像顺序扫描，找到第1个还没有归属的像素，设该像素为(x0, y0)；</li>
<li>以(x0,y0)为中心，考虑(x0,y0)的4邻域或者8邻域像素(x,y)与种子像素的灰度值之差的绝对值小于某个阈值T，如果满足条件，将(x,y)与(x0,y0)合并(在同一区域内)，同时将(x,y)压入堆栈；</li>
<li>从堆栈中取出一个像素，把它当作(x0, y0)返回到步骤2；</li>
<li>当堆栈为空时，返回到步骤1；</li>
<li>重复步骤1-4直到图像中的每个点都有归属时，生长结束。</li>
</ol>
<p>下图为测试效果（左侧为原图灰度图像，右侧为区域生长图像）： </p>
<p><img src="/2023/06/10/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/2.1.png" alt> </p>
<blockquote>
<p>需要注意的是：当选取的种子不同时，得到的区域生长图像也会不同。</p>
</blockquote>
<h2 id="1-2-区域分裂合并算法"><a href="#1-2-区域分裂合并算法" class="headerlink" title="1.2 区域分裂合并算法"></a>1.2 区域分裂合并算法</h2><p>区域生长是从某个或者某些像素点出发，最后得到整个区域，进而实现目标提取。而分裂合并可以看做是区域生长的逆过程：从整个图像出发，不断分裂得到各个子区域，然后再把前景区域合并，实现目标提取。分裂合并的假设是对于一幅图像，前景区域由一些相互连通的像素组成。因此，如果把一幅图像分裂到像素级，那么就可以判定该像素是否为前景像素。当所有像素点或者子区域完成判断以后，把前景区域或者像素合并就可得到前景目标。</p>
<p>假定一幅图像分为若干区域，按照有关区域的逻辑词P的性质，各个区域上所有的像素将是一致的。区域分裂合并的算法如下：</p>
<ol>
<li>将整幅图像设置为初始区域；</li>
<li>选择一个区域R，若P（R）错误，则将该区域分为4个子区域；</li>
<li>考虑图像中任意两个或更多的邻接子区域R1，R2，…,Rn；</li>
<li>如果P（R1∪R2∪…∪Rn）正确，则将这n个区域合并为一个区域；</li>
<li>重复上述步骤，直到不能再进行区域分裂合并。</li>
</ol>
<p>下图为测试效果：</p>
<p><img src="/2023/06/10/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/2.2.png" alt> </p>
<h2 id="1-3-分水岭算法"><a href="#1-3-分水岭算法" class="headerlink" title="1.3 分水岭算法"></a>1.3 分水岭算法</h2><h3 id="1-3-1-分水岭算法原理"><a href="#1-3-1-分水岭算法原理" class="headerlink" title="1.3.1 分水岭算法原理"></a>1.3.1 分水岭算法原理</h3><p>图像的灰度空间很像地球表面的整个地理结构，每个像素的灰度值代表高度。其中的灰度值较大的像素连成的线可以看做山脊，也就是分水岭。其中的水就是用于二值化的gray threshold level，二值化阈值可以理解为水平面，比水平面低的区域会被淹没，刚开始用水填充每个孤立的山谷(局部最小值)。当水平面上升到一定高度时，水就会溢出当前山谷，可以通过在分水岭上修大坝，从而避免两个山谷的水汇集，这样图像就被分成2个像素集，一个是被水淹没的山谷像素集，一个是分水岭线像素集。最终这些大坝形成的线就对整个图像进行了分区，实现对图像的分割。</p>
<p>在该算法中，空间上相邻并且灰度值相近的像素被划分为一个区域。</p>
<p>分水岭算法的整个过程如下：</p>
<ol>
<li>把梯度图像中的所有像素按照灰度值进行分类，并设定一个测地距离阈值；</li>
<li>找到灰度值最小的像素点（默认标记为灰度值最低点），让threshold从最小值开始增长，这些点为起始点；</li>
<li>水平面在增长的过程中，会碰到周围的邻域像素，测量这些像素到起始点（灰度值最低点）的测地距离，如果小于设定阈值，则将这些像素淹没，否则在这些像素上设置大坝，这样就对这些邻域像素进行了分类；</li>
<li>随着水平面越来越高，会设置更多更高的大坝，直到灰度值的最大值，所有区域都在分水岭线上相遇，这些大坝就对整个图像像素进行了分区。</li>
</ol>
<p>用上面的算法对图像进行分水岭运算，由于噪声点或其它因素的干扰，可能会得到密密麻麻的小区域，即图像被分得太细（over-segmented，过度分割），这因为图像中有非常多的局部极小值点，每个点都会自成一个小区域。</p>
<p>其中的解决方法有：</p>
<p>（1）对图像进行高斯平滑操作，抹除很多小的最小值，这些小分区就会合并。</p>
<p>（2）不从最小值开始增长，可以将相对较高的灰度值像素作为起始点（需要用户手动标记），从标记处开始进行淹没，则很多小区域都会被合并为一个区域，这被称为<strong>基于图像标记(mark)的分水岭算法</strong>。</p>
<h3 id="1-3-2-opencv-python中分水岭算法的应用"><a href="#1-3-2-opencv-python中分水岭算法的应用" class="headerlink" title="1.3.2 opencv-python中分水岭算法的应用"></a>1.3.2 opencv-python中分水岭算法的应用</h3><p>在OpenCV中，我们需要给不同区域贴上不同的标签。用大于1的整数表示我们确定为前景或对象的区域，用1表示我们确定为背景或非对象的区域，最后用0表示我们无法确定的区域。然后应用分水岭算法，我们的标记图像将被更新，更新后的标记图像的边界像素值为-1。</p>
<p>具体步骤如下：</p>
<ol>
<li>对图进行灰度化和二值化得到二值图像；</li>
<li>通过膨胀得到确定的背景区域，通过距离转换得到确定的前景区域，剩余部分为不确定区域；</li>
<li>对确定的前景图像进行连接组件处理，得到标记图像；</li>
<li>根据标记图像对原图像应用分水岭算法，更新标记图像。</li>
</ol>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># noise removal</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sure_bg = cv2.dilate(opening, kernel, iterations=<span class="number">2</span>)  <span class="comment"># sure background area</span></span><br><span class="line">sure_fg = cv2.erode(opening, kernel, iterations=<span class="number">2</span>)  <span class="comment"># sure foreground area</span></span><br><span class="line">unknown = cv2.subtract(sure_bg, sure_fg)  <span class="comment"># unknown area</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Perform the distance transform algorithm</span></span><br><span class="line">dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># Normalize the distance image for range = &#123;0.0, 1.0&#125;</span></span><br><span class="line">cv2.normalize(dist_transform, dist_transform, <span class="number">0</span>, <span class="number">1.0</span>, cv2.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finding sure foreground area</span></span><br><span class="line">ret, sure_fg = cv2.threshold(dist_transform, <span class="number">0.5</span>*dist_transform.max(), <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finding unknown region</span></span><br><span class="line">sure_fg = np.uint8(sure_fg)</span><br><span class="line">unknown = cv2.subtract(sure_bg,sure_fg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Marker labelling</span></span><br><span class="line">ret, markers = cv2.connectedComponents(sure_fg)</span><br><span class="line"><span class="comment"># Add one to all labels so that sure background is not 0, but 1</span></span><br><span class="line">markers = markers+<span class="number">1</span></span><br><span class="line"><span class="comment"># Now, mark the region of unknown with zero</span></span><br><span class="line">markers[unknown==<span class="number">255</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">markers_copy = markers.copy()</span><br><span class="line">markers_copy[markers==<span class="number">0</span>] = <span class="number">150</span>  <span class="comment"># 灰色表示背景</span></span><br><span class="line">markers_copy[markers==<span class="number">1</span>] = <span class="number">0</span>    <span class="comment"># 黑色表示背景</span></span><br><span class="line">markers_copy[markers&gt;<span class="number">1</span>] = <span class="number">255</span>   <span class="comment"># 白色表示前景</span></span><br><span class="line"></span><br><span class="line">markers_copy = np.uint8(markers_copy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用分水岭算法执行基于标记的图像分割，将图像中的对象与背景分离</span></span><br><span class="line">markers = cv2.watershed(img, markers)</span><br><span class="line">img[markers==<span class="number">-1</span>] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]  <span class="comment"># 将边界标记为红色</span></span><br><span class="line"></span><br><span class="line">plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">'Watershed_image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2023/06/10/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/2.3.png" alt="img"> </p>
<h1 id="2-基于图的分割方法"><a href="#2-基于图的分割方法" class="headerlink" title="2. 基于图的分割方法"></a>2. 基于图的分割方法</h1><p>此类方法把图像分割问题与图的最小割（min cut）问题相关联。首先将图像映射为带权无向图G=<V，E>，图中每个节点N∈V对应于图像中的每个像素，每条边∈E连接着一对相邻的像素，边的权值表示了相邻像素之间在灰度、颜色或纹理方面的非负相似度。而对图像的一个分割s就是对图的一个剪切，被分割的每个区域C∈S对应着图中的一个子图。而分割的最优原则就是使划分后的子图在内部保持相似度最大，而子图之间的相似度保持最小。基于图的分割方法的本质就是移除特定的边，将图划分为若干子图从而实现分割，常用的方法有GraphCut，GrabCut和Random Walk等。</V，E></p>
<h3 id="2-1-Grabcut图像分割"><a href="#2-1-Grabcut图像分割" class="headerlink" title="2.1 Grabcut图像分割"></a>2.1 Grabcut图像分割</h3><p>Grabcut是基于图割(graph cut)实现的图像分割算法，它需要用户输入一个bounding box作为分割目标位置，实现对目标与背景的分离/分割。Grabcut分割速度快，效果好，支持交互操作，因此在很多APP图像分割/背景虚化的软件中经常使用。</p>
<p>算法流程如下：</p>
<ol>
<li>在图片中定义含有（一个或多个）物体的矩形；</li>
<li>矩形外的区域被自动认为是背景；</li>
<li>对于用户定义的矩形区域，可用背景中数据来区分是前景还是背景；</li>
<li>用高斯混合模型（GMM）来对背景和前景建模，并将未定义的像素标记为可能的前景或背景；</li>
<li>图像中的每一个像素都被看作通过虚拟边与周围像素连接，而每条边都有一个属于前景或背景的概率，这基于它和周围像素颜色上的相似性；</li>
<li>每一个像素（即算法中的节点）会与一个前景或背景节点连接；</li>
<li>在节点完成连接后(可能与背景或前景连接)，若节点之间的边属于不同终端(即一个节点属于前景，另一个节点属于背景)，则会切断他们之间的边，这就能将图像各部分分割出来。</li>
</ol>
<p>OpenCV中使用cv2.grabCut()函数来实现图像分割，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.grabCut(img, rect, mask, bgdModel, fgdModel, iterCount, mode = GC_EVAL)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>img：输入的三通道图像；</p>
</li>
<li><p>rect：表示roi区域；</p>
</li>
<li><p>mask：输入的单通道图像，初始化方式为GC_INIT_WITH_RECT表示ROI区域可以被初始化为：</p>
<p>GC_BGD：定义为明显的背景像素 0</p>
<p>GC_FGD：定义为明显的前景像素 1</p>
<p>GC_PR_BGD：定义为可能的背景像素 2</p>
<p>GC_PR_FGD：定义为可能的前景像素 3</p>
</li>
<li><p>bgdModel：表示临时背景模型数组；</p>
</li>
<li><p>fgdModel：表示临时前景模型数组；</p>
</li>
<li><p>iterCount：表示图割算法迭代次数, 次数越多，效果越好；</p>
</li>
<li><p>mode：当使用用户提供的roi时使用GC_INIT_WITH_RECT。</p>
</li>
</ul>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">r = cv2.selectROI(<span class="string">'input'</span>, img, <span class="literal">False</span>)  <span class="comment"># 返回 (x_min, y_min, w, h)</span></span><br><span class="line">print(<span class="string">"input:"</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># roi区域</span></span><br><span class="line">roi = img[int(r[<span class="number">1</span>]):int(r[<span class="number">1</span>] + r[<span class="number">3</span>]), int(r[<span class="number">0</span>]):int(r[<span class="number">0</span>] + r[<span class="number">2</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原图mask</span></span><br><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩形roi</span></span><br><span class="line">rect = (int(r[<span class="number">0</span>]), int(r[<span class="number">1</span>]), int(r[<span class="number">2</span>]), int(r[<span class="number">3</span>]))  <span class="comment"># 包括前景的矩形，格式为(x,y,w,h)</span></span><br><span class="line"></span><br><span class="line">bgdmodel = np.zeros((<span class="number">1</span>, <span class="number">65</span>), np.float64)  <span class="comment"># bg模型的临时数组</span></span><br><span class="line">fgdmodel = np.zeros((<span class="number">1</span>, <span class="number">65</span>), np.float64)  <span class="comment"># fg模型的临时数组</span></span><br><span class="line"></span><br><span class="line">cv2.grabCut(img, mask, rect, bgdmodel, fgdmodel, <span class="number">11</span>, mode=cv2.GC_INIT_WITH_RECT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取前景和可能的前景区域</span></span><br><span class="line">mask2 = np.where((mask == <span class="number">1</span>) + (mask == <span class="number">3</span>), <span class="number">255</span>, <span class="number">0</span>).astype(<span class="string">'uint8'</span>)</span><br><span class="line">print(mask2.shape)</span><br><span class="line"></span><br><span class="line">result = cv2.bitwise_and(img, img, mask=mask2)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(cv2.cvtColor(roi, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">'roi_img'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(cv2.cvtColor(result, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">'Grabcut_image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2023/06/10/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95/3.png" alt="img"> </p>
<h1 id="3-源码仓库地址"><a href="#3-源码仓库地址" class="headerlink" title="3. 源码仓库地址"></a>3. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
        <tag>图像分割</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>霍夫变换</title>
    <url>/2023/06/11/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="1-什么是霍夫变换"><a href="#1-什么是霍夫变换" class="headerlink" title="1. 什么是霍夫变换"></a>1. 什么是霍夫变换</h1><p>霍夫变换(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。</p>
<p>霍夫变换于1962年由PaulHough首次提出，最初的Hough变换是设计用来检测直线和曲线，起初的方法要求知道物体边界线的解析方程，但不需要有关区域位置的先验知识。这种方法的一个突出优点是分割结果的Robustness,即对数据的不完全或噪声不是非常敏感。然而，要获得描述边界的解析表达常常是不可能的。后于1972年由Richard Duda &amp; Peter Hart推广使用，经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。</p>
<p>霍夫变换在OpenCV中分为霍夫线变换和霍夫圆变换两种。<a id="more"></a></p>
<h1 id="2-霍夫直线检测"><a href="#2-霍夫直线检测" class="headerlink" title="2. 霍夫直线检测"></a>2. 霍夫直线检测</h1><p>Hough直线检测的基本原理在于利用点与线的对偶性，在我们的直线检测任务中，即图像空间中的直线与参数空间中的点是一一对应的，参数空间中的直线与图像空间中的点也是一一对应的。这意味着我们可以得出两个非常有用的结论：</p>
<p>​    1）图像空间中的每条直线在参数空间中都对应着单独一个点来表示；<br>​    2）图像空间中的直线上任何一部分线段在参数空间对应的是同一个点。</p>
<p>因此Hough直线检测算法就是把在图像空间中的直线检测问题转换到参数空间中对点的检测问题，通过在参数空间里寻找峰值来完成直线检测任务。</p>
<h2 id="2-1-霍夫直线检测的具体步骤"><a href="#2-1-霍夫直线检测的具体步骤" class="headerlink" title="2.1 霍夫直线检测的具体步骤"></a>2.1 霍夫直线检测的具体步骤</h2><ol>
<li>彩色图像-&gt;灰度图；</li>
<li>去噪（高斯核）；</li>
<li>边缘提取（梯度算子、拉普拉斯算子、canny、sobel）；</li>
<li>二值化（判断此处是否为边缘点，就看灰度值==255）；</li>
<li>映射到霍夫空间（准备两个容器，一个用来展示hough-space概况，一个数组hough-space用来储存voting的值，因为投票过程往往有某个极大值超过阈值，多达几千，不能直接用灰度图来记录投票信息）；</li>
<li>取局部极大值，设定阈值，过滤干扰直线；</li>
<li>绘制直线、标定角点。 </li>
</ol>
<h2 id="2-2-霍夫直线检测的优缺点"><a href="#2-2-霍夫直线检测的优缺点" class="headerlink" title="2.2 霍夫直线检测的优缺点"></a>2.2 霍夫直线检测的优缺点</h2><p><strong>优点</strong>：Hough直线检测的优点是抗干扰能力强，对图像中直线的残缺部分、噪声以及其它共存的非直线结构不敏感，能容忍特征边界描述中的间隙，并且相对不受图像噪声的影响。</p>
<p><strong>缺点</strong>：Hough变换算法的特点导致其时间复杂度和空间复杂度都很高，并且在检测过程中只能确定直线方向，丢失了线段的长度信息。由于霍夫检测过程中进行了离散化，因此检测精度受参数离散间隔制约。</p>
<h2 id="2-3-OpenCV中霍夫直线检测的应用"><a href="#2-3-OpenCV中霍夫直线检测的应用" class="headerlink" title="2.3 OpenCV中霍夫直线检测的应用"></a>2.3 OpenCV中霍夫直线检测的应用</h2><p>OpenCV的中用函数HoughLines(标准)和HoughLinesP(基于统计)来检测图像中的直线，函数原型如下：</p>
<h3 id="2-3-1-标准霍夫检测"><a href="#2-3-1-标准霍夫检测" class="headerlink" title="2.3.1 标准霍夫检测"></a>2.3.1 标准霍夫检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = cv.HoughLines( image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]] )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：<br>lines：返回值（ρ,θ），ρ以像素为单位，θ以弧度为单位；<br>rho：累加器的距离分辨率（以像素为单位）；<br>theta：累加器的角度分辨率（弧度）；<br>threshold：阈值，仅大于的才可以被返回；<br>srn：对于多尺度Hough变换，它是距离分辨率rho的除数。粗累加器距离分辨率为rho，精确累加器分辨率为rho/srn。如果srn=0和stn=0，则使用经典Hough变换。否则，这两个参数都应为正值；<br>stn：对于多尺度Hough变换，它是距离分辨率θ的除数；<br>min_theta：对于标准和多尺度Hough变换，检查直线的最小角度。必须介于0和最大θ之间；<br>max_theta：对于标准和多尺度Hough变换，检查直线的最大角度。必须介于min_theta和CV_PI之间。</p>
</blockquote>
<h3 id="2-3-2-概率霍夫检测"><a href="#2-3-2-概率霍夫检测" class="headerlink" title="2.3.2 概率霍夫检测"></a>2.3.2 概率霍夫检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = cv.HoughLinesP( image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]] )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：<br>lines：返回两个端点的坐标；<br>rho：累加器的距离分辨率（以像素为单位）；<br>theta：累加器的角度分辨率（弧度）；<br>threshold：阈值，仅大于的才可以被返回；<br>minLineLength：最小行长度，小于该长度的线段将被拒绝；<br>maxLineGap：同一直线上连接点的最大允许间距。</p>
</blockquote>
<p> 测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">src = cv.imread(<span class="string">"demo-line.jpg"</span>)</span><br><span class="line">img = src.copy()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 二值化图像（Canny边缘检测）</span></span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">dst_img = cv.Canny(gray_img, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 霍夫线变换</span></span><br><span class="line">lines = cv.HoughLines(dst_img, <span class="number">0.5</span>, np.pi / <span class="number">180</span>, <span class="number">300</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将检测的线绘制在原图上（注意是极坐标）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho, theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    <span class="comment"># 找两个点</span></span><br><span class="line">    x0 = rho * a</span><br><span class="line">    y0 = rho * b</span><br><span class="line">    x1 = int(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">    y1 = int(y0 + <span class="number">1000</span> * a)</span><br><span class="line">    x2 = int(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">    y2 = int(y0 - <span class="number">1000</span> * a)</span><br><span class="line">    cv.line(img, (x1, y1), (x2, y2), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.subplot(<span class="number">311</span>), plt.imshow(src, <span class="string">'gray'</span>), plt.title(<span class="string">'src_img'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">312</span>), plt.imshow(dst_img, <span class="string">'gray'</span>), plt.title(<span class="string">'canny_img'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">313</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'HoughLines_img'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p> 效果如下：</p>
<p><img src="/2023/06/11/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/2.3.2.png" alt="img"> </p>
<h1 id="3-霍夫圆检测"><a href="#3-霍夫圆检测" class="headerlink" title="3. 霍夫圆检测"></a>3. 霍夫圆检测</h1><p>霍夫圆变换的基本思路是认为图像上每一个非零像素点都有可能是一个潜在的圆上的一点，跟霍夫线变换一样，也是通过投票，生成累积坐标平面，设置一个累积权重来定位圆。</p>
<p>OpenCV中使用cv2.HoughCircles函数来实现霍夫圆检测，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) → circles</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明:<br>image：8位单通道图像，如果使用彩色图像，需要先转换成灰度图像；<br>method：定义检测图像中圆的方法，目前唯一实现的方法是cv2.HOUGH_GRADIENT；<br>dp：图像像素分辨率与参数空间分辨率的比值（官方文档上写的是图像分辨率与累加器分辨率的比值，它把参数空间认为是一个累加器，毕竟里面存储的都是经过的像素点的数量），dp=1，则参数空间与图像像素空间（分辨率）一样大，dp=2，参数空间的分辨率只有像素空间的一半大；<br>minDist：检测到的圆的中心，（x,y）坐标之间的最小距离。如果minDist太小，则可能导致检测到多个相邻的圆。如果minDist太大，则可能导致很多圆检测不到；<br>param1：用于处理边缘检测的梯度值方法；<br>param2：cv2.HOUGH_GRADIENT方法的累加器阈值。阈值越小，检测到的圆越多；<br>minRadius：半径的最小大小（以像素为单位）；<br>maxRadius：半径的最大大小（以像素为单位）。</p>
</blockquote>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'demo-circle.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">img = cv2.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)</span><br><span class="line">circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,<span class="number">1</span>,<span class="number">200</span>,param1=<span class="number">50</span>,param2=<span class="number">30</span>,minRadius=<span class="number">0</span>,maxRadius=<span class="number">0</span>)</span><br><span class="line">circles = np.uint16(np.around(circles))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>,:]:</span><br><span class="line">    <span class="comment"># draw the outer circle</span></span><br><span class="line">    cv2.circle(cimg,(i[<span class="number">0</span>],i[<span class="number">1</span>]),i[<span class="number">2</span>],(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># draw the center of the circle</span></span><br><span class="line">    cv2.circle(cimg,(i[<span class="number">0</span>],i[<span class="number">1</span>]),<span class="number">2</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'src_img'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(cimg, <span class="string">'gray'</span>), plt.title(<span class="string">'HoughCircles_img'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2023/06/11/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/3.png" alt="img"> </p>
<h1 id="4-源码仓库地址"><a href="#4-源码仓库地址" class="headerlink" title="4. 源码仓库地址"></a>4. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>LBP特征提取</title>
    <url>/2023/06/12/LBP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<p>LBP指局部二值模式，英文全称：Local Binary Pattern，是一种用来描述图像局部特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点。<a id="more"></a></p>
<h1 id="1-LBP原理及其扩展"><a href="#1-LBP原理及其扩展" class="headerlink" title="1 LBP原理及其扩展"></a>1 LBP原理及其扩展</h1><h2 id="1-1-原始LBP"><a href="#1-1-原始LBP" class="headerlink" title="1.1 原始LBP"></a>1.1 原始LBP</h2><p>原始的LBP算子定义在像素3<em>3的邻域内，以邻域中心像素为阈值，相邻的8个像素的灰度值与邻域中心的像素值进行比较，若周围像素大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3</em>3邻域内的8个点经过比较可产生8位二进制数，将这8位二进制数依次排列形成一个二进制数字，这个二进制数字就是中心像素的LBP值，因此LBP值有256种。中心像素的LBP值反映了该像素周围区域的纹理信息。需要注意的是，计算LBP特征的图像必须是灰度图，如果是彩色图，需要先转换成灰度图。 </p>
<h2 id="1-2-圆形LBP"><a href="#1-2-圆形LBP" class="headerlink" title="1.2 圆形LBP"></a>1.2 圆形LBP</h2><p>由于原始LBP特征使用的是固定邻域内的灰度值，因此当图像的尺度发生变化时，LBP特征的编码将会发生错误，LBP特征将不能正确的反映像素点周围的纹理信息，因此研究人员对其进行了改进。基本的LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对LBP算子进行了改进，将3*3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的LBP算子允许在半径为R的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子，这种LBP特征叫做Extended LBP，也叫Circular LBP。</p>
<h2 id="1-3-旋转不变LBP"><a href="#1-3-旋转不变LBP" class="headerlink" title="1.3 旋转不变LBP"></a>1.3 旋转不变LBP</h2><p>上面的LBP特征具有灰度不变性，但还不具备旋转不变性，因此研究人员又在上面的基础上进行了扩展，提出了具有旋转不变性的LBP特征。首先不断的旋转圆形邻域内的LBP特征，根据选择得到一系列的LBP特征值，从这些LBP特征值选择LBP特征值最小的作为中心像素点的LBP特征。</p>
<h2 id="1-4-Uniform-Pattern-LBP"><a href="#1-4-Uniform-Pattern-LBP" class="headerlink" title="1.4 Uniform Pattern LBP"></a>1.4 Uniform Pattern LBP</h2><p>为了解决二进制模式过多的问题，提高统计性，Ojala提出了采用一种“等价模式”(Uniform Pattern)来对LBP算子的模式种类进行降维。Ojala等认为，在实际图像中，绝大多数LBP模式最多只包含两次从1到0或从0到1的跳变。因此，Ojala将“等价模式”定义为：当某个LBP所对应的循环二进制数从0到1或从1到0最多有两次跳变时，该LBP所对应的二进制就称为一个等价模式类。如00000000(0次跳变)，00000111(只含一次从0到1的跳变)，10001111(先由1跳到0，再由0跳到1，共两次跳变)都是等价模式类。除等价模式类以外的模式都归为另一类，称为混合模式类，例如10010111(共四次跳变)。通过这样的改进，二进制模式的种类大大减少，而不会丢失任何信息。模式数量由原来的2P种减少为P(P-1)+2种，其中P表示邻域集内的采样点数。对于3*3邻域内8个采样点来说，二进制模式由原始的256种减少为58种，即：它把值分为59类，58个uniform pattern为一类，其它的所有值为第59类。这样直方图从原来的256维变成59维。这使得特征向量的维数更少，并且可以减少高频噪声带来的影响。具体实现如下：</p>
<p>采样点数目为8个，即LBP特征值有28种，共256个值，正好对应灰度图像的0-255，因此原始的LBP特征图像是一幅正常的灰度图像，而等价模式LBP特征，根据0-1跳变次数，将这256个LBP特征值分为了59类，从跳变次数上划分：跳变0次—2个，跳变1次—0个，跳变2次—56个，跳变3次—0个，跳变4次—140个，跳变5次—0个，跳变6次—56个，跳变7次—0个，跳变8次—2个。共9种跳变情况，将这256个值进行分配，跳变小于2次的为等价模式类，共58个，他们对应的值按照从小到大分别编码为1-58，即它们在LBP特征图像中的灰度值为1-58，而除了等价模式类之外的混合模式类被编码为0，即它们在LBP特征中的灰度值为0，因此等价模式LBP特征图像整体偏暗。</p>
<h2 id="1-5-MB-LBP"><a href="#1-5-MB-LBP" class="headerlink" title="1.5 MB-LBP"></a>1.5 MB-LBP</h2><p>MB-LBP的原理：将图像分成一个个小块（Block），每个小块再分为一个个的小区域（类似于HOG中的cell），小区域内的灰度平均值作为当前小区域的灰度值，与周围小区域灰度进行比较形成LBP特征，生成的特征称为MB-LBP，Block大小为3<em>3，则小区域的大小为1，就是原始的LBP特征，Block大小为9</em>9，小区域的大小为3*3。接下来对得到LBP特征进行均值模式编码，通过对得到的特征图求直方图，得到了LBP特征值0-255之间(0-255即直方图中的bin)的特征数量，通过对bin中的数值进行排序，通过权衡，将排序在前63位的特征值看作是等价模式类，其他的为混合模式类，总共64类，作者在论文中称之为SEMB-LBP(Statistically Effective MB-LBP)。类似于等价模式LBP，等价模式的LBP的等价模式类为58种，混合模式类1种，共59种。二者除了等价模式类的数量不同之外，主要区别在于：对等价模式类的定义不同，等价模式LBP是根据0-1的跳变次数定义的，而SEMB-LBP是通过对直方图排序得到的。</p>
<h1 id="2-对于边缘点的处理"><a href="#2-对于边缘点的处理" class="headerlink" title="2. 对于边缘点的处理"></a>2. 对于边缘点的处理</h1><p>对于图像边缘的点，由于通常不能用上述方法来处理成LBP特征点，一般来说有以下几种处理方法：<br>（1）将边缘的提取不到周围特征的点不进行LBP处理，结果LBP特征图片的像素点会比之前少。<br>（2）将边缘不存在的邻域点值设置为0。<br>（3）将边缘的提取不到周围特征的点用原像素点的值取代。</p>
<h1 id="3-LBP的Python应用"><a href="#3-LBP的Python应用" class="headerlink" title="3. LBP的Python应用"></a>3. LBP的Python应用</h1><p>Python skimage库中使用local_binary_pattern函数实现LBP提取特征，其函数原型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">local_binary_pattern(image, P, R, method=<span class="string">'default'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：<br>image：（N，M）阵列Graylevel图像。<br>P：int圆对称邻居设置点的数量（角度空间的量化）。<br>R：float圆的半径（操作员的空间分辨率）。<br>method：{‘default’，‘ror’，‘uniform’，‘var’}确定模式的方法，如下所示：<br>        ‘default’：原始的局部二值模式，它是灰度但不是旋转不变的。<br>        ‘ror’：扩展灰度和旋转不变的默认实现。<br>        ‘uniform’：改进的旋转不变性和均匀的模式以及角度空间的更精细的量化，灰度和旋转不变。<br>        ‘nri_uniform’：非旋转不变的均匀图案变体，它只是灰度不变的R199。<br>        ‘VAR’：局部对比度的旋转不变方差度量，图像纹理是旋转但不是灰度不变的。</p>
</blockquote>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> local_binary_pattern</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># settings for LBP</span></span><br><span class="line">radius = <span class="number">1</span>  <span class="comment"># LBP算法中范围半径的取值</span></span><br><span class="line">n_points = <span class="number">8</span> * radius   <span class="comment"># 领域像素点数</span></span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">'lenna.jpg'</span>)  <span class="comment"># 读取图像</span></span><br><span class="line">image1 = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) <span class="comment"># 按照RGB顺序展示原图</span></span><br><span class="line">image2 = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)   <span class="comment"># 灰度转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LBP处理</span></span><br><span class="line">lbp = local_binary_pattern(image2, n_points, radius)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">131</span>), plt.imshow(image1), plt.title(<span class="string">'Original Image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>), plt.imshow(image2, <span class="string">'gray'</span>), plt.title(<span class="string">'Gray Image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>), plt.imshow(lbp, <span class="string">'gray'</span>), plt.title(<span class="string">'LBP Image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2023/06/12/LBP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/3.png" alt="img"> </p>
<h1 id="4-LBPH算法及其应用"><a href="#4-LBPH算法及其应用" class="headerlink" title="4. LBPH算法及其应用"></a>4. LBPH算法及其应用</h1><h2 id="4-1-LBPH算法原理"><a href="#4-1-LBPH算法原理" class="headerlink" title="4.1 LBPH算法原理"></a>4.1 LBPH算法原理</h2><p>LBPH(Local Binary Patterns Histograms)局部二进制编码直方图，是一种人脸识别算法，用于识别人脸，它以其性能以及如何能够从正面和侧面识别人脸而闻名。建立在LBPH基础之上的人脸识别法基本思想如下：首先以每个像素为中心，判断与周围像素灰度值大小关系，对其进行二进制编码，从而获得整幅图像的LBP编码图像；再将LBP图像分为个区域，获取每个区域的LBP编码直方图，继而得到整幅图像的LBP编码直方图，通过比较不同人脸图像LBP编码直方图达到人脸识别的目的,其优点是不会受到光照、缩放、旋转和平移的影响。</p>
<p>一幅图像具体的计算LBPH的过程如下：<br>a.    计算图像的LBP特征图像；<br>b.    将LBP特征图像进行分块，Opencv中默认将LBP特征图像分成8行8列64块区域；<br>c.    计算每块区域特征图像的直方图cell_LBPH，将直方图进行归一化；<br>d.    将上面计算的每块区域特征图像的直方图按分块的空间顺序依次排列成一行，形成LBP特征向量；<br>e.    用机器学习的方法对LBP特征向量进行训练，用来检测和识别目标。</p>
<h2 id="4-2-LBPH识别应用"><a href="#4-2-LBPH识别应用" class="headerlink" title="4.2 LBPH识别应用"></a>4.2 LBPH识别应用</h2><p>如下是LBPH人脸识别的部分测试代码：</p>
<p><img src="/2023/06/12/LBP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/4.png" alt="img"> </p>
<p>根据上述代码，基于LBPH的人脸识别基本步骤可以概括如下：</p>
<p>a. 创建空列表分别存储用于训练的人脸和人脸标签；</p>
<p>b. 遍历训练集，将训练人脸及便签存进空列表；</p>
<p>c. 通过OpenCV的LBPH识别函数对训练集中的人脸和人脸标签生成识别器；</p>
<p>d. 读取测试图像，通过识别器进行预测识别该人脸属于哪一类。</p>
<h1 id="5-源码仓库地址"><a href="#5-源码仓库地址" class="headerlink" title="5. 源码仓库地址"></a>5. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title>SIFT算法</title>
    <url>/2023/06/13/SIFT%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-SIFT算法简介"><a href="#1-SIFT算法简介" class="headerlink" title="1. SIFT算法简介"></a>1. SIFT算法简介</h1><p>SIFT (Scale-invariant feature transform)，尺度不变特征转换，是一种图像局部特征提取算法，它通过在不同的尺度空间中寻找极值点（特征点，关键点）的精确定位和主方向，构建关键点描述符来提取特征。SIFT提取的关键点具有尺度不变性、旋转不变性，而且不会因光照、仿射变换和噪音等因素而干扰。SIFT所查找到的关键点是一些十分突出、不会因光照、仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。<a id="more"></a></p>
<h2 id="1-1-SIFT特征检测步骤"><a href="#1-1-SIFT特征检测步骤" class="headerlink" title="1.1 SIFT特征检测步骤"></a>1.1 SIFT特征检测步骤</h2><p>SIFT特征检测主要分为以下四步：<br>（1）尺度空间的极值检测：搜索所有尺度空间上的图像，通过高斯微分函数来识别潜在的对尺度和旋转不变的兴趣点；<br>（2）特征点定位：在每个候选的位置上，通过一个拟合精细模型来确定位置尺度，关键点的选取依据他们的稳定程度；<br>（3）特征方向赋值：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性；<br>（4）特征点描述：在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/1.png" alt="img"> </p>
<h2 id="1-2-SIFT算法的特点"><a href="#1-2-SIFT算法的特点" class="headerlink" title="1.2 SIFT算法的特点"></a>1.2 SIFT算法的特点</h2><p>（1）图像的局部特征，对旋转、尺度缩放、亮度变化保持不变，对视角变化、仿射变换、噪声也保持一定程度的稳定性。<br>（2）独特性好，信息量丰富，适用于海量特征库进行快速、准确的匹配。<br>（3）多量性，即使是很少几个物体也可以产生大量的SIFT特征。<br>（4）高速性，经优化的SIFT匹配算法甚至可以达到实时性。<br>（5）可扩展性，可以很方便的与其他的特征向量进行联合。</p>
<h1 id="2-SIFT算法原理"><a href="#2-SIFT算法原理" class="headerlink" title="2. SIFT算法原理"></a>2. SIFT算法原理</h1><h2 id="2-1-尺度空间"><a href="#2-1-尺度空间" class="headerlink" title="2.1 尺度空间"></a>2.1 尺度空间</h2><p>在一定的范围内，无论物体是大还是小，人眼都可以分辨出来，然而计算机要有相同的能力却很难，在未知的场景中，计算机视觉并不能够提供物体的尺度大小，其中的一种方法是把物体不同尺度下的图像都提供给机器，让机器能够对物体在不同尺度下有一个统一的认知，在建立统一认知的过程中，要考虑的就是图像在不同的尺度下都存在的特点。</p>
<h3 id="2-1-1-多分辨率金字塔"><a href="#2-1-1-多分辨率金字塔" class="headerlink" title="2.1.1 多分辨率金字塔"></a>2.1.1 多分辨率金字塔</h3><p>早期的图像多尺度通常使用图像金字塔的表示形式，图像金字塔是同一图像在不同分辨率下得到的一组结果，生成过程包含：<br>（1）对原始图像进行平滑；<br>（2）对平滑后的图像进行下采样。</p>
<p>降采样后得到一系列不断尺寸缩小的图像。显然，一个传统的金字塔中，每一层的图像是其上一层图像长、高的各一半。多分辨率的图像金字塔虽然生成简单，但其本质是降采样，图像的局部特征则难以保持，也就是无法保持特征的尺度不变性。</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/2.png" alt="img" style="zoom:80%;"> </p>
<h3 id="2-1-2-高斯金字塔"><a href="#2-1-2-高斯金字塔" class="headerlink" title="2.1.2 高斯金字塔"></a>2.1.2 高斯金字塔</h3><p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/3.png" alt="img" style="zoom:80%;"> </p>
<p><strong><em>高斯金字塔的构建可以分为两步：</em></strong><br>（1）对图像做高斯平滑；<br>（2）对平滑后的图像做下采样。</p>
<p>为了让尺度体系其连续性，在简单下采样的基础上增加了高斯滤波，一副图像可以产生几组（octave）图像，一组图像包括几层（interval）图像。</p>
<p><strong><em>高斯金字塔分布情况（o组s层）：</em></strong></p>
<p>容易看出，高斯金字塔有多组，每组又有多层，一组的多个层之间的尺度是不一样的，也就是使用的高斯参数σ不同，相邻两层之间的尺度相差一个比例因子k，如果每组有S层，则k=21/S，上一组图像的最底层图像是由下一组中尺度为2σ的图像进行因子为2的降采样得到的（高斯金字塔是从底层开始建立的），高斯金字塔构建完成之后，将相邻的金字塔相减就得到了DoG金字塔。</p>
<p>高斯金字塔的组数：</p>
<script type="math/tex; mode=display">
o=[log_2min(m,n)]-a</script><p>o表示高斯金字塔的层数，m，n分别是图像的行和列。减去的系数a可以在 0 – log<sub>2</sub>min(m,n) 之间的任意值，和具体需要的金字塔的顶层图像的大小有关。</p>
<p>高斯模糊参数可由下面的关系得到：</p>
<script type="math/tex; mode=display">
σ(o,s)=σ_0*2^\frac{o+s}{S}</script><p>其中o为所在的组，s为所在的层，σ<sub>0</sub>为初始的尺度，S为每组的层数。</p>
<p><strong><em>同组内相邻层的图像尺度间的关系：</em></strong></p>
<script type="math/tex; mode=display">
σ_{s+1}=k*σ_s=2^\frac{1}{S}*σ_s</script><p><strong><em>相邻组之间的尺度关系：</em></strong></p>
<script type="math/tex; mode=display">
σ_{o+1}=2*σ_o</script><p>上一组图像的底层是由前一组图像的倒数第二层图像隔点采样生成的，这样可以保证尺度的连续性。</p>
<h3 id="2-1-3-高斯尺度空间（使用不同的参数）"><a href="#2-1-3-高斯尺度空间（使用不同的参数）" class="headerlink" title="2.1.3 高斯尺度空间（使用不同的参数）"></a>2.1.3 高斯尺度空间（使用不同的参数）</h3><p>我们要精确表示的物体都是通过一定的尺度来反映的，现实世界的物体也总是通过不同尺度的观察而得到不同的变化。</p>
<p>尺度空间的理论最早在1962年提出，主要思想是通过对原始图像进行尺度变换，获得图像多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为一种特征向量，实现边缘、角点检测和不同分辨率上的特征提取等。</p>
<p>尺度空间中各个尺度图像的模糊程度逐渐变大，能够模拟人在距离由近到远时目标在视网膜上的形成过程，尺度越大，图像越模糊。</p>
<p>图像和高斯函数进行卷积运算能够对图像进行模糊，且不同尺度的高斯核可以得到不同程度的模糊图像，一幅图像的高斯尺度空间可以通过图像和不同尺度的高斯核卷积得到：</p>
<script type="math/tex; mode=display">
L(x,y,σ)=G(x,y,σ)*I(x,y)</script><p>其中，G是高斯函数：</p>
<script type="math/tex; mode=display">
G(x,y,σ)=\frac{1}{2πσ^2}e^\frac{x^2+y^2}{2σ^2}</script><p>其中，σ是尺度空间因子，是高斯正态分布的标准差，反映了图像被模糊的程度，其值越大图像越模糊，对应的尺度也就越大，L(x,y,σ)对应高斯尺度空间。</p>
<p> T Lindeber在文献《Scale-space theory: a basic tool for analyzing structures at different scales》中证明，高斯核是唯一可以产生多尺度空间的核。</p>
<p><strong><em>高斯模糊性质：</em></strong><br>（1）高斯模糊具有圆对称性。<br>（2）高斯模糊具有线性可分的性质，可以在二维图像上对两个独立的一维空间分别进行计算，大大的减小了运算次数。<br>（3）对一副图像进行多次连续高斯模糊的效果与一次更大的高斯模糊可以产生同样的效果，大的高斯模型的半径是所用多个高斯模糊半径平方和的平方根。</p>
<p>例如：使用半径分别为6和8的两次高斯模糊变换得到的效果等同于一次半径为10的高斯模糊的效果：sqrt(6<sup>2</sup>+8<sup>2</sup>)=10，根据这个关系，使用多个连续较小的高斯模糊处理不会比单个高斯较大处理时间要少。</p>
<p><strong><em>构造尺度空间的目的：</em></strong></p>
<p>为了检测出来在不同尺度下都存在的特征点，而检测特征点较好的算子是高斯拉普拉斯（LoG），即Δ<sup>2</sup>G：</p>
<script type="math/tex; mode=display">
Δ^2=\frac{ə^2}{əx^2}+\frac{ə^2}{əy^2}</script><p>LoG的缺点：虽然其能够较好的检测到图像中的特征点，但是运算量过大。通常可以使用DoG（差分高斯，Different of Gaussian）来近似计算LoG。设k为相邻两个高斯尺度空间的比例因子，则DoG定义为：</p>
<script type="math/tex; mode=display">
D(x,y,σ)=[G(x,y,kσ)−G(x,y,σ)]∗I(x,y)=L(x,y,kσ)−L(x,y,σ)</script><p>其中，L(x,y,σ)是图像的高斯尺度空间。</p>
<p>DoG是如何得到的：将相邻的两个高斯空间的图像相减即可得到DoG响应图像，为了得到DoG响应图像，要先构建高斯尺度空间，而高斯的尺度空间可以在图像金字塔将采用的基础上加上高斯滤波得到，也就是对图像金字塔的每层图像使用不同的参数σ进行高斯模糊，使得每层金字塔有多张高斯模糊过的图像，降采样时，金字塔上边一组图像的第一章是由其下面一组图像倒数第三张降采样得到的。</p>
<h2 id="2-2-DoG空间极值检测（查找关键点）"><a href="#2-2-DoG空间极值检测（查找关键点）" class="headerlink" title="2.2 DoG空间极值检测（查找关键点）"></a>2.2 DoG空间极值检测（查找关键点）</h2><p>关键点是一些十分突出的点，不会因光照条件的改变而消失，比如角点、边缘点、暗区域的亮点和亮区域的暗点，既然两幅图像中有相同的景物，那么使用某种方法分别提取各自的稳定点，这些点之间会有相应的匹配点。</p>
<p>所谓关键点，就是在不同尺度空间的图像下检测出的具有方向信息的局部极值点。</p>
<p>为了寻找尺度空间的极值点，每个像素点要和其图像域（同一尺度空间）和尺度域（相邻的尺度空间）的所有相邻点进行比较，当其大于（或者小于）所有相邻点时，该点就是极值点。如图所示，中间的检测点要和其所在图像的3×3邻域8个像素点，以及其相邻的上下两层的3×3领域18个像素点，共26个像素点进行比较。</p>
<p>从上面的描述中可以知道，每组图像的第一层和最后一层是无法进行比较取得极值的。为了满足尺度变换的连续性，在每一组图像的顶层继续使用高斯模糊生成3幅图像，高斯金字塔每组有S+3层图像，DoG金字塔的每组有S+2组图像。</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/4.png" alt="img"> </p>
<p>DoG在计算上只需相邻尺度高斯平滑后图像相减，因此简化了计算。</p>
<h2 id="2-3-删除不好的极值点（特征点）"><a href="#2-3-删除不好的极值点（特征点）" class="headerlink" title="2.3 删除不好的极值点（特征点）"></a>2.3 删除不好的极值点（特征点）</h2><p>通过比较检测得到的DoG的局部极值点实在离散的空间搜索得到的，由于离散空间是对连续空间采样得到的结果，因此在离散空间找到的极值点不一定是真正意义上的极值点，因此要设法将不满足条件的点剔除掉。可以通过尺度空间DoG函数进行曲线拟合寻找极值点，这一步的本质是去掉DoG局部曲率非常不对称的点。</p>
<p>要剔除掉的不符合要求的点主要有两种：<br>（1）低对比度的特征点<br>（2）不稳定的边缘响应点</p>
<h2 id="2-4-求取特征点的主方向"><a href="#2-4-求取特征点的主方向" class="headerlink" title="2.4 求取特征点的主方向"></a>2.4 求取特征点的主方向</h2><p>经过上面的步骤已经找到了在不同尺度下都存在的特征点，为了实现图像旋转不变性，需要给特征点的方向进行赋值。利用特征点邻域像素的梯度分布特性来确定其方向参数，再利用图像的梯度直方图求取关键点局部结构的稳定方向。</p>
<p>找到了特征点，也就可以得到该特征点的尺度σ，也就可以得到特征点所在的尺度图像：L(x,y,σ)=G(x,y,σ)∗I(x,y)。</p>
<p>计算以特征点为中心、以3×1.5σ * 3×1.5σ为半径的区域图像的幅角和幅值，每个点L(x,y)的梯度的模m(x,y)以及方向θ(x,y)可通过下面的公式求得：</p>
<script type="math/tex; mode=display">
m(x,y)=\sqrt{[L(x+1,y)-L(x-1,y)]^2+[L(x,y+1)-L(x,y-1)]^2}</script><script type="math/tex; mode=display">
θ(x,y)=arctan\frac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}</script><p>计算得到梯度方向后，就要使用直方图统计特征点邻域内像素对应的梯度方向和幅值。梯度方向的直方图的横轴是梯度方向的角度（梯度方向的范围是0到360度，直方图每36度一个柱共10个柱，或者没45度一个柱共8个柱），纵轴是梯度方向对应梯度幅值的累加，在直方图的峰值就是特征点的主方向。使用高斯函数对直方图进行平滑以增强特征点近的邻域点对关键点方向的作用，并减少突变的影响。</p>
<p>得到特征点的主方向后，对于每个特征点可以得到三个信息(x,y,σ,θ)，即位置、尺度和方向。由此可以确定一个SIFT特征区域，一个SIFT特征区域由三个值表示，中心表示特征点位置，半径表示关键点的尺度，箭头表示主方向。具有多个方向的关键点可以被复制成多份，然后将方向值分别赋给复制后的特征点，一个特征点就产生了多个坐标、尺度相等，但是方向不同的特征点。</p>
<h2 id="2-5-生成特征描述"><a href="#2-5-生成特征描述" class="headerlink" title="2.5 生成特征描述"></a>2.5 生成特征描述</h2><p>通过以上的步骤已经找到了SIFT特征点位置、尺度和方向信息，下面就需要使用一组向量来描述关键点也就是生成特征点描述子，这个描述符不只包含特征点，也含有特征点周围对其有贡献的像素点。描述子应具有较高的独立性，以保证匹配率。</p>
<p>特征描述符的生成大致有三个步骤：<br>（1）校正旋转主方向，确保旋转不变性。<br>（2）生成描述子，最终形成一个128维的特征向量。<br>（3）归一化处理，将特征向量长度进行归一化处理，进一步去除光照的影响。</p>
<p>为了保证特征矢量的旋转不变性，要以特征点为中心，在附近邻域内将坐标轴旋转θθ角度，即将坐标轴旋转为特征点的主方向，旋转后邻域内的像素的新坐标为：</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} x^\text{'} \\ y^\text{'} \end{matrix} \right]=\left[ \begin{matrix} cosθ & -sinθ \\ sinθ & cosθ \end{matrix}\right]\left[ \begin{matrix} x \\ y \end{matrix} \right]</script><p>旋转之后的主方向为中心取8x8的窗口，左图中央为当前关键点的位置，每个小格代表Wie关键点邻域所在尺度空间的一个像素，求取每个像素的梯度幅值和方向，箭头方向代表梯度方向，长度代表梯度幅值，然后利用高斯窗口对其进行加权运算，最后在每个4x4的小块上绘制8个方向的梯度直方图，计算每个梯度方向的累加值，即可形成一个种子点，如右图所示，每个特征的由4个种子点组成，每个种子点有8个方向的向量信息，这种邻域方向性信息联合增强了算法的抗噪能力，同时对于含有定位误差的特征匹配也提供了比较理性的容错性。</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/5.png" alt="img" style="zoom:50%;"> </p>
<p>不同于求主方向，此时每个种子区域的梯度直方图在0-360之间划分为8个方向区间，每个区间为45度，即每个种子点有8个方向的梯度强度信息。</p>
<p>在实际计算的过程中，为了增强匹配的稳健性，Lowe建立对每个关键点使用4x4共16个种子点来描述，这样一个关键点就会产生128维的SIFT特征向量。</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/6.png" alt="img" style="zoom:80%;"> </p>
<p>通过对特征点周围的像素进行分块，计算块内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象，具有唯一性。</p>
<hr>
<p>综上，SIFT特征对旋转、尺度缩放、亮度等有鲁棒性，是一种非常稳定的局部特征，在图像处理和计算机视觉领域具有很重要的作用，其本身也比较复杂。</p>
<p>（1）DoG尺度空间的极值检测：</p>
<p>首先构造DoG尺度空间，在SIFT中使用不同参数的高斯模糊来表示不同的尺度空间，而构造尺度空间是为了检测在不同尺度下都存在的特征点，特征点的检测比较常用的方法是高斯拉普拉斯，但是LoG的运算量是比较大的，Marr和Hidreth指出可以使用DoG（高斯差分）来近似计算LoG，所以在DoG的尺度空间下检测极值点。</p>
<p>（2）删除不稳定的极值点：</p>
<p>低对比度的极值点+不稳定的边缘响应点</p>
<p>（3）确定特征的的主方向：</p>
<p>以特征点的为中心、以3×1.5σ * 3×1.5σ为半径的领域内计算各个像素点的梯度的幅角和幅值，然后使用直方图对梯度的幅角进行统计。直方图的横轴是梯度的方向，纵轴为梯度方向对应梯度幅值的累加值，直方图中最高峰所对应的方向即为特征点的方向。</p>
<p>（4）生成特征描述子：</p>
<p>首先将坐标轴旋转为特征点的方向，以特征点为中心的16x16的窗口的像素的梯度幅值和方向，将窗口内的像素分为16块，每块是其像素内8个方向的直方图统计，共可以形成128维的特征向量。</p>
<h1 id="3-SIFT算法在OpenCV中的应用"><a href="#3-SIFT算法在OpenCV中的应用" class="headerlink" title="3. SIFT算法在OpenCV中的应用"></a>3. SIFT算法在OpenCV中的应用</h1><p>SIFT算法在OpenCV中主要包括以下几个函数：</p>
<ol>
<li><p>cv2.xfeatures2d.SIFT_create()：实例化SIFT</p>
</li>
<li><p>sift.detect()：找出关键点</p>
</li>
<li><p>cv2.drawKeypoints()：画出关键点</p>
</li>
<li><p>sift.compute()：根据关键点计算SIFT向量</p>
</li>
</ol>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到特征点</span></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line">kp = sift.detect(gray, <span class="literal">None</span>)  <span class="comment"># 关键点</span></span><br><span class="line">img = cv2.drawKeypoints(gray, kp, img)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(gray, <span class="string">'gray'</span>), plt.title(<span class="string">'Gray Image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'Keypoints Image'</span>), plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算特征</span></span><br><span class="line"><span class="comment"># kp为关键点keypoints</span></span><br><span class="line"><span class="comment"># des为描述子descriptors</span></span><br><span class="line">kp, des = sift.compute(gray, kp)</span><br><span class="line">print(np.array(kp).shape) <span class="comment">#(203,)</span></span><br><span class="line">print(des.shape) <span class="comment">#(203, 128)，128维向量</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/7.png" alt="img"> </p>
<h1 id="4-SIFT算法进行图像分类的思路"><a href="#4-SIFT算法进行图像分类的思路" class="headerlink" title="4. SIFT算法进行图像分类的思路"></a>4. SIFT算法进行图像分类的思路</h1><p>通过比较待识别图片与训练图集中的每一张图片的sift描述子的个数，找出匹配度最高的那张图片所在的类别，则该类别就被判定为待识别图片的类别。</p>
<p>如以下代码所示，有40类图片，每类图片5张：首先计算待识别图片的des描述子，然后依次比较每一类中每一张图片与该描述子的匹配数之和（平均匹配数），则匹配数之和（平均匹配数）最大的一类判定为与待识别图片为同一类。</p>
<p><img src="/2023/06/13/SIFT%E7%AE%97%E6%B3%95/8.png" alt="img"> </p>
<h1 id="5-源码仓库地址"><a href="#5-源码仓库地址" class="headerlink" title="5. 源码仓库地址"></a>5. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing-and-MachineLearning" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA算法</title>
    <url>/2023/06/14/PCA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-数据降维"><a href="#1-数据降维" class="headerlink" title="1. 数据降维"></a>1. 数据降维</h1><p>在许多领域的研究与应用中，通常需要对含有多个变量的数据进行观测，收集大量数据后进行分析寻找规律。多变量大数据集无疑会为研究和应用提供丰富的信息，但是也在一定程度上增加了数据采集的工作量。更重要的是在很多情形下，许多变量之间可能存在相关性，从而增加了问题分析的复杂性。如果分别对每个指标进行分析，分析往往是孤立的，不能完全利用数据中的信息，因此盲目减少指标会损失很多有用的信息，从而产生错误的结论。<a id="more"></a></p>
<p>因此需要找到一种合理的方法，在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的。由于各变量之间存在一定的相关关系，因此可以考虑将关系紧密的变量变成尽可能少的新变量，使这些新变量是两两不相关的，那么就可以用较少的综合指标分别代表存在于各个变量中的各类信息。主成分分析与因子分析就属于这类降维算法。</p>
<p>降维就是一种对高维度特征数据预处理方法。降维是将高维度的数据保留下最重要的一些特征，去除噪声和不重要的特征，从而实现提升数据处理速度的目的。在实际的生产和应用中，降维在一定的信息损失范围内，可以为我们节省大量的时间和成本。降维也成为应用非常广泛的数据预处理方法。</p>
<p>降维具有如下一些优点：<br>（1）使得数据集更易使用。<br>（2）降低算法的计算开销。<br>（3）去除噪声。<br>（4）使得结果容易理解。</p>
<p>降维的算法有很多，比如<strong>奇异值分解(SVD)、主成分分析(PCA)、因子分析(FA)、独立成分分析(ICA)</strong>。</p>
<h1 id="2-PCA原理"><a href="#2-PCA原理" class="headerlink" title="2. PCA原理"></a>2. PCA原理</h1><p>PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k个坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k个含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。</p>
<p> 那么我们如何得到这些包含最大差异性的主成分方向呢？事实上，通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。</p>
<p>由于得到协方差矩阵的特征值特征向量有两种方法：<strong>特征值分解协方差矩阵、奇异值分解协方差矩阵</strong>，所以PCA算法有两种实现方法：<strong>基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法</strong>。</p>
<p>下面具体介绍基于特征值分解协方差矩阵实现PCA算法的原理。</p>
<h2 id="2-1-基变换"><a href="#2-1-基变换" class="headerlink" title="2.1 基变换"></a>2.1 基变换</h2><p>一般来说，欲获得原始数据新的表示空间，最简单的是对原始数据进行线性变换（基变换）：Y=PX，其中Y是样本在新空间的表达，P是基向量，X是原始样本。我们可知选择不同的基可以对一组数据给出不同的表示，同时当基的数量少于原始样本本身的维数则可达到降维的效果，矩阵表示如下：</p>
<p><img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/1.png" alt="img"> </p>
<p>其中，p<sub>i</sub>是一个行向量，表示第i个基；a<sub>j</sub>是一个列向量，表示第j个原始数据记录。特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一个N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。从原本X∈R<sup>N*M</sup>降维到Y∈R<sup>R*M</sup>。因此这种矩阵相乘的表示也可以表示降维变换。</p>
<p>最后，上述分析同时给矩阵相乘找到了一种物理解释：两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。更抽象的说，一个矩阵可以表示一种线性变换。</p>
<h2 id="2-2-方差"><a href="#2-2-方差" class="headerlink" title="2.2 方差"></a>2.2 方差</h2><p>那么如何选择一个方向或者基才是最优的？观察下图,</p>
<p><img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/2.png" alt="img"> </p>
<p>我们将所有的点分别向两条直线做投影，基于PCA最大可分思想，我们要找的方向是降维后损失最小，可以理解为投影后的数据尽可能的分开，那么这种分散程度可以用数学上的方差来表示，方差越大数据越分散。方差公式如下：</p>
<script type="math/tex; mode=display">
Var(a)=\frac{1}{m}\sum_{i=1}^n(a_i-μ)^2</script><p>对数据进行了中心化后（可以方便后面的操作）：</p>
<script type="math/tex; mode=display">
Var(a)=\frac{1}{m}\sum_{i=1}^m(a_i)^2</script><h2 id="2-3-协方差"><a href="#2-3-协方差" class="headerlink" title="2.3 协方差"></a>2.3 协方差</h2><p>从二维降到一维可以使用方差最大来选出能使基变换后数据分散最大的方向（基），但如果遇到高维的变换，当完成第一个方向（基）选择后，第二个投影方向应该与第一个“几乎重合在一起”，这显然是没有用的，因此要有其它的约束条件。我们希望两个字段尽可能表示更多的信息，使其不存在相关性。</p>
<p>数学上用协方差表示其相关性：</p>
<script type="math/tex; mode=display">
Cov(a,b)=\frac{1}{m}\sum_{i=1}^ma_ib_i</script><p>当Cov(a,b)=0时，表示两个字段完全独立，这也是我们的优化目标。</p>
<h2 id="2-4-协方差矩阵"><a href="#2-4-协方差矩阵" class="headerlink" title="2.4 协方差矩阵"></a>2.4 协方差矩阵</h2><p>我们想达到的目标与字段内方差及字段间协方差有密切关系，假如只有 、  两个字段，那么我们将它们按行组成矩阵X,表示如下：</p>
<script type="math/tex; mode=display">
X=\left( \begin{matrix} a_1 & a_2 & ... & a_m \\ b_1 & b_2 & ... & b_m \end{matrix} \right)</script><p>然后我们用X乘以X的转置，并乘上系数1/m:</p>
<script type="math/tex; mode=display">
\frac{1}mXX^T=\left( \begin{matrix} \frac{1}{m}\sum_{i=1}^ma_i^2 & \frac{1}{m}\sum_{i=1}^ma_ib_i \\ \frac{1}{m}\sum_{i=1}^ma_ib_i & \frac{1}{m}\sum_{i=1}^mb_i^2 \end{matrix} \right)</script><p>可见，协方差矩阵是一个对称的矩阵，而且对角线是各个维度的方差，而其它元素是a和b的协方差，即两者被统一到了一个矩阵。</p>
<h2 id="2-5-协方差矩阵对角化"><a href="#2-5-协方差矩阵对角化" class="headerlink" title="2.5 协方差矩阵对角化"></a>2.5 协方差矩阵对角化</h2><p>我们的目标是使<img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/3.png" alt="img">，根据上述推倒，可以看出我们的优化目标  <img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/4.png" alt="img">等价于协方差矩阵对角化。即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p>
<p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：</p>
<p><img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/5.png" alt="img"> </p>
<p>可见，我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了寻找一个矩阵P，满足PCPT是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件。</p>
<p> 我们希望的是投影后的方差最大化，于是我们的优化目标可以写为：</p>
<script type="math/tex; mode=display">
max_p tr(PCP^T)</script><script type="math/tex; mode=display">
s.t. PP^T = I</script><p>利用拉格朗日函数可以得到：J(P)=tr(PCP<sup>T</sup>)+ λ(PP<sup>T</sup>-I),对P求导有CP<sup>T</sup>+λP<sup>T</sup>=0，整理下即为：CP<sup>T</sup>=(-λ)P<sup>T</sup>。</p>
<p>于是，只需对协方差矩阵C进行特征分解，对求得的特征值进行排序，再对P<sup>T</sup>=(P<sub>1</sub>,P<sub>2</sub>,…,P<sub>R</sub>)取前K列组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p>
<h1 id="3-PCA算法流程"><a href="#3-PCA算法流程" class="headerlink" title="3. PCA算法流程"></a>3. PCA算法流程</h1><p>从上面可以看出，求样本 x<sub>i </sub>的 n’ 维的主成分其实就是求样本集的协方差矩阵的前 n’ 个特征值对应特征向量矩阵 P，然后对于每个样本x<sub>i </sub>，做如下变换y<sub>i </sub>=Px<sub>i </sub>，即达到降维的PCA目的。</p>
<p>下面是具体的算法流程：<br>输入：n维样本集X=(x<sub>1 </sub>,x<sub>2</sub>,…,x<sub>m</sub>)，要降维到的维数 n’；<br>输出：降维后的样本集Y。</p>
<p>1.对所有的样本进行中心化；<br>2.计算样本的协方差矩阵；<br>3.求出协方差矩阵的特征值及对应的特征向量；<br>4.将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P；<br>5.Y=PX即为降维到k维后的数据。</p>
<blockquote>
<p>注意：有时候，我们不指定降维后的n’的值，而是换种方式，指定一个降维到的主成分比重阈值t。这个阈值t在(0,1]之间。假如我们的n个特征值为λ1≥λ2≥…≥λn,则n’可以通过下式得到:<img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/6.png" alt="img"> </p>
</blockquote>
<h1 id="4-PCA算法的特点"><a href="#4-PCA算法的特点" class="headerlink" title="4. PCA算法的特点"></a>4. PCA算法的特点</h1><p>作为一个非监督学习的降维方法，它只需要特征值分解，就可以对数据进行压缩，去噪。因此在实际场景应用很广泛。为了克服PCA的一些缺点，出现了很多PCA的变种，比如为解决非线性降维的KPCA，还有解决内存限制的增量PCA方法Incremental PCA，以及解决稀疏数据降维的PCA方法Sparse PCA等。</p>
<p>PCA算法的主要优点有：<br>（1） 仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　<br>（2）各主成分之间正交，可消除原始数据成分间的相互影响的因素。<br>（3）计算方法简单，主要运算是特征值分解，易于实现。</p>
<p>PCA算法的主要缺点有：<br>（1）主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。<br>（2）方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</p>
<h1 id="5-PCA算法的Python应用"><a href="#5-PCA算法的Python应用" class="headerlink" title="5. PCA算法的Python应用"></a>5. PCA算法的Python应用</h1><p>首先需要实现几个函数，分别是数据中心化、最小化降维造成的损失，确定k、得到最大的k个特征值和特征向量、得到降维后的数据、重构数据，然后通过PCA函数整合，最后调用main函数执行。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据中心化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Z_centered</span><span class="params">(dataMat)</span>:</span></span><br><span class="line">    rows, cols = dataMat.shape</span><br><span class="line">    meanVal = np.mean(dataMat, axis=<span class="number">0</span>)  <span class="comment"># 按列求均值，即求各个特征的均值</span></span><br><span class="line">    meanVal = np.tile(meanVal, (rows, <span class="number">1</span>))</span><br><span class="line">    newdata = dataMat - meanVal</span><br><span class="line">    <span class="keyword">return</span> newdata, meanVal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小化降维造成的损失，确定k</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Percentage2n</span><span class="params">(eigVals, percentage)</span>:</span></span><br><span class="line">    sortArray = np.sort(eigVals)  <span class="comment"># 升序</span></span><br><span class="line">    sortArray = sortArray[<span class="number">-1</span>::<span class="number">-1</span>]  <span class="comment"># 逆转，即降序</span></span><br><span class="line">    arraySum = sum(sortArray)</span><br><span class="line">    tmpSum = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sortArray:</span><br><span class="line">        tmpSum += i</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmpSum &gt;= arraySum * percentage:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最大的k个特征值和特征向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EigDV</span><span class="params">(covMat, p)</span>:</span></span><br><span class="line">    D, V = np.linalg.eig(covMat)  <span class="comment"># 得到特征值和特征向量</span></span><br><span class="line">    k = Percentage2n(D, p)  <span class="comment"># 确定k值</span></span><br><span class="line">    print(<span class="string">"保留"</span> + str(p*<span class="number">100</span>) + <span class="string">"%信息，降维后的特征个数："</span> + str(k) + <span class="string">"\n"</span>)</span><br><span class="line">    eigenvalue = np.argsort(D)</span><br><span class="line">    K_eigenValue = eigenvalue[<span class="number">-1</span>:-(k + <span class="number">1</span>):<span class="number">-1</span>]</span><br><span class="line">    K_eigenVector = V[:, K_eigenValue]</span><br><span class="line">    <span class="keyword">return</span> K_eigenValue, K_eigenVector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到降维后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlowDataMat</span><span class="params">(DataMat, K_eigenVector)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> DataMat * K_eigenVector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重构数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reconstruction</span><span class="params">(lowDataMat, K_eigenVector, meanVal)</span>:</span></span><br><span class="line">    reconDataMat = lowDataMat * K_eigenVector.T + meanVal</span><br><span class="line">    <span class="keyword">return</span> reconDataMat</span><br><span class="line"></span><br><span class="line"><span class="comment"># PCA算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PCA</span><span class="params">(data, p)</span>:</span></span><br><span class="line">    dataMat = np.float32(np.mat(data))</span><br><span class="line">    <span class="comment"># 数据中心化</span></span><br><span class="line">    dataMat, meanVal = Z_centered(dataMat)</span><br><span class="line">    <span class="comment"># 计算协方差矩阵</span></span><br><span class="line">    <span class="comment"># covMat = Cov(dataMat)</span></span><br><span class="line">    covMat = np.cov(dataMat, rowvar=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 得到最大的k个特征值和特征向量</span></span><br><span class="line">    D, V = EigDV(covMat, p)</span><br><span class="line">    <span class="comment"># 得到降维后的数据</span></span><br><span class="line">    lowDataMat = getlowDataMat(dataMat, V)</span><br><span class="line">    <span class="comment"># 重构数据</span></span><br><span class="line">    reconDataMat = Reconstruction(lowDataMat, V, meanVal)</span><br><span class="line">    <span class="keyword">return</span> reconDataMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    imagePath = <span class="string">'lenna.jpg'</span></span><br><span class="line">    image = cv.imread(imagePath)</span><br><span class="line">    image = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line">    rows, cols = image.shape</span><br><span class="line">    print(<span class="string">"降维前的特征个数："</span> + str(cols) + <span class="string">"\n"</span>)</span><br><span class="line">    print(image)</span><br><span class="line">    print(<span class="string">'----------------------------------------'</span>)</span><br><span class="line">    reconImage = PCA(image, <span class="number">0.99</span>) <span class="comment"># 通过改变保留信息的程度来看这个图片的特征值 </span></span><br><span class="line">    reconImage = reconImage.astype(np.uint8)</span><br><span class="line">    print(reconImage)</span><br><span class="line">    cv.imshow(<span class="string">'test'</span>, reconImage)</span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>保留不同信息量，降维后特征个数如下：</p>
<p><img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/7.png" alt="img"><img src="file:///C:\Users\fwp\AppData\Local\Temp\ksohtml20184\wps15.jpg" alt="img"> </p>
<p>特征个数为52和95的降维后图片如下：</p>
<p><img src="/2023/06/14/PCA%E7%AE%97%E6%B3%95/8.png" alt="img"> </p>
<p>可以发现，降维后保留的特征越多，图片越清晰。</p>
<blockquote>
<p> P.S. 在Python的sklearn的库里面集成很多机器学习算法的库，其中也包括主成分分析的方法。</p>
</blockquote>
<h1 id="6-源码仓库地址"><a href="#6-源码仓库地址" class="headerlink" title="6. 源码仓库地址"></a>6. 源码仓库地址</h1><p>🌼 <a href="https://github.com/crossoverpptx/ImageProcessing-and-MachineLearning" target="_blank" rel="noopener">图像处理、机器学习的常用算法汇总</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
