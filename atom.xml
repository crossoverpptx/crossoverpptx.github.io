<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverpptx&#39;s Blog</title>
  
  <subtitle>黑夜给了我黑色的眼睛，我却用它寻找光明</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-01-05T01:39:17.113Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crossoverpptx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++：深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2023/01/05/C-%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2023/01/05/C-%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2023-01-05T01:14:15.000Z</published>
    <updated>2023-01-05T01:39:17.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是浅拷贝和深拷贝"><a href="#1-什么是浅拷贝和深拷贝" class="headerlink" title="1. 什么是浅拷贝和深拷贝"></a>1. 什么是浅拷贝和深拷贝</h2><p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是<strong>浅拷贝</strong>，这和调用 memcpy() 函数的效果非常类似。<a id="more"></a></p><p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><p>下面通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。</p><p><strong>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。</strong></p><p>深拷贝的例子比比皆是，除了上面的变长数组类，动态数组类也需要深拷贝；此外，标准模板库STL中的 string、vector、stack、set、map 等也都必须使用深拷贝。</p><p>如果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br></pre></td></tr></table></figure><p>可以发现，更改 arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，导致 arr2.m_p 和 arr1.m_p 指向了同一块内存，所以会相互影响。</p><p>另外需要注意的是，printArray() 函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了 const 限制，以使得语义更加明确。</p><h2 id="2-到底是浅拷贝还是深拷贝"><a href="#2-到底是浅拷贝还是深拷贝" class="headerlink" title="2. 到底是浅拷贝还是深拷贝"></a>2. 到底是浅拷贝还是深拷贝</h2><p>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</p><p>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1: count = <span class="number">1</span>, time = <span class="number">1488344372</span></span><br><span class="line">obj2: count = <span class="number">2</span>, time = <span class="number">1488344375</span></span><br></pre></td></tr></table></figure><p>运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-什么是浅拷贝和深拷贝&quot;&gt;&lt;a href=&quot;#1-什么是浅拷贝和深拷贝&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是浅拷贝和深拷贝&quot;&gt;&lt;/a&gt;1. 什么是浅拷贝和深拷贝&lt;/h2&gt;&lt;p&gt;对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Base(): m_a(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), m_b(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Base(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b): m_a(a), m_b(b)&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m_a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m_b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = a;  &lt;span class=&quot;comment&quot;&gt;//拷贝&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Base &lt;span class=&quot;title&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Base obj2 = obj1;  &lt;span class=&quot;comment&quot;&gt;//拷贝&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是&lt;strong&gt;浅拷贝&lt;/strong&gt;，这和调用 memcpy() 函数的效果非常类似。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++11：move函数将左值强制转换为右值</title>
    <link href="http://yoursite.com/2023/01/04/C-11%EF%BC%9Amove%E5%87%BD%E6%95%B0%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC/"/>
    <id>http://yoursite.com/2023/01/04/C-11%EF%BC%9Amove%E5%87%BD%E6%95%B0%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC/</id>
    <published>2023-01-04T00:54:35.000Z</published>
    <updated>2023-01-04T01:27:50.637Z</updated>
    
    <content type="html"><![CDATA[<p>通过学习《<a href="https://crossoverpptx.github.io/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">C++11移动构造函数</a>》我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p><p>需要注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p><p><strong>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</strong>基于 move() 函数特殊的功能，其常用于实现移动语义。</p><a id="more"></a><p>move() 函数的用法也很简单，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg )</span><br></pre></td></tr></table></figure><p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p><p>下面用一些代码演示了move() 函数的使用方法。</p><p>（1）move() 函数的基础应用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movedemo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    movedemo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    movedemo(<span class="keyword">const</span> movedemo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    movedemo(movedemo &amp;&amp;d):num(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"move construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo2:\n"</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"demo3:\n"</span>;</span><br><span class="line">    movedemo demo3 = <span class="built_in">std</span>::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line"><span class="built_in">move</span> construct!</span><br></pre></td></tr></table></figure><p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p><blockquote><p>注意：调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 30 行代码会导致程序运行时发生错误。</p></blockquote><p>（2）灵活使用 move() 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    first() :num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    first(first &amp;&amp;d) :num(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"first move construct!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    second() :fir() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    second(second &amp;&amp; sec) :fir(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"second move construct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">first <span class="built_in">move</span> construct!</span><br><span class="line">second <span class="built_in">move</span> construct</span><br></pre></td></tr></table></figure><p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。仔细观察可以发现，程序中使用了两次 move() 函数：</p><ul><li>程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li><li>程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过学习《&lt;a href=&quot;https://crossoverpptx.github.io/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C++11移动构造函数&lt;/a&gt;》我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。&lt;/p&gt;
&lt;p&gt;需要注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。&lt;/strong&gt;基于 move() 函数特殊的功能，其常用于实现移动语义。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：移动构造函数</title>
    <link href="http://yoursite.com/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2023/01/03/C-11%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-03T00:44:50.000Z</published>
    <updated>2023-01-03T11:52:07.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拷贝构造函数中的深拷贝问题"><a href="#1-拷贝构造函数中的深拷贝问题" class="headerlink" title="1. 拷贝构造函数中的深拷贝问题"></a>1. 拷贝构造函数中的深拷贝问题</h2><p>在 C++ 98/03 标准中，如果想用其它对象初始化一个同类的新对象，只能借助类中的拷贝构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。<strong>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。</strong></p><a id="more"></a><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ~demo()&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"class destruct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</p><p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p><ol><li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</li><li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li><li>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li><li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li></ol><p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure><p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!        &lt;-- 执行 demo()</span><br><span class="line">copy construct!    &lt;-- 执行 <span class="keyword">return</span> demo()</span><br><span class="line">class destruct!     &lt;-- 销毁 demo() 产生的匿名对象</span><br><span class="line">copy construct!    &lt;-- 执行 a = get_demo()</span><br><span class="line">class destruct!     &lt;-- 销毁 get_demo() 返回的临时对象</span><br><span class="line">class destruct!     &lt;-- 销毁 a</span><br></pre></td></tr></table></figure><p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p><blockquote><p>事实上，此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p></blockquote><p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p><h2 id="2-C-移动构造函数（移动语义的具体实现）"><a href="#2-C-移动构造函数（移动语义的具体实现）" class="headerlink" title="2. C++移动构造函数（移动语义的具体实现）"></a>2. C++移动构造函数（移动语义的具体实现）</h2><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p><p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p><blockquote><p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p></blockquote><p>例如，下面程序对 demo 类进行了修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    demo(demo &amp;&amp;d):num(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"move construct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"class destruct!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。<strong>和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。</strong>并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p><p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="built_in">move</span> construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br><span class="line"><span class="class"><span class="title">move</span> <span class="title">construct</span>!</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">destruct</span>!</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure><p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p><p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p><blockquote><p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p></blockquote><p>那么，如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p><p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-拷贝构造函数中的深拷贝问题&quot;&gt;&lt;a href=&quot;#1-拷贝构造函数中的深拷贝问题&quot; class=&quot;headerlink&quot; title=&quot;1. 拷贝构造函数中的深拷贝问题&quot;&gt;&lt;/a&gt;1. 拷贝构造函数中的深拷贝问题&lt;/h2&gt;&lt;p&gt;在 C++ 98/03 标准中，如果想用其它对象初始化一个同类的新对象，只能借助类中的拷贝构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。&lt;strong&gt;需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++：拷贝构造函数</title>
    <link href="http://yoursite.com/2023/01/02/C-%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2023/01/02/C-%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2023-01-02T09:28:09.000Z</published>
    <updated>2023-01-02T11:16:39.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拷贝和拷贝构造函数"><a href="#1-拷贝和拷贝构造函数" class="headerlink" title="1. 拷贝和拷贝构造函数"></a>1. 拷贝和拷贝构造函数</h2><p>拷贝和复制是一个意思，对应的英文单词都是<code>copy</code>。对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。<a id="more"></a></p><p>在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化：</p><ol><li>分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li><li>初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。</li></ol><p>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net http://c.biancheng.net</span></span><br></pre></td></tr></table></figure><p>s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。</p><blockquote><p>对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的，这其实涉及到C++转换构造函数的知识。s4 也是类似的道理。</p></blockquote><p>对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p><p>对于 func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 func() 时，才会将其它对象的数据拷贝给 str 以完成初始化。</p><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。</p><p>下面的例子演示了拷贝构造函数的定义和使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.<span class="built_in">display</span>();</span><br><span class="line">    stu2.<span class="built_in">display</span>();</span><br><span class="line">    stu3.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copy constructor was called.</span><br><span class="line">Copy constructor was called.</span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span></span><br></pre></td></tr></table></figure><p>第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p><h3 id="1-1-为什么必须是当前类的引用呢？"><a href="#1-1-为什么必须是当前类的引用呢？" class="headerlink" title="1.1 为什么必须是当前类的引用呢？"></a>1.1 为什么必须是当前类的引用呢？</h3><p>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p><h3 id="1-2-为什么是-const-引用呢？"><a href="#1-2-为什么是-const-引用呢？" class="headerlink" title="1.2 为什么是 const 引用呢？"></a>1.2 为什么是 const 引用呢？</h3><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>以上面的 Student 类为例，将 const 去掉后，拷贝构造函数的原型变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(Student &amp;stu);</span><br></pre></td></tr></table></figure><p>此时，下面的代码就会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure><p>stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用<code>Student::Student(const Student &amp;stu)</code>，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用<code>Student::Student(Student &amp;stu)</code>，所以最终调用失败了。</p><p>当然，也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。</p><h2 id="2-默认拷贝构造函数"><a href="#2-默认拷贝构造函数" class="headerlink" title="2. 默认拷贝构造函数"></a>2. 默认拷贝构造函数</h2><p>其实，即使我们没学习过拷贝构造函数，实际上却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。</p><p>对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-拷贝和拷贝构造函数&quot;&gt;&lt;a href=&quot;#1-拷贝和拷贝构造函数&quot; class=&quot;headerlink&quot; title=&quot;1. 拷贝和拷贝构造函数&quot;&gt;&lt;/a&gt;1. 拷贝和拷贝构造函数&lt;/h2&gt;&lt;p&gt;拷贝和复制是一个意思，对应的英文单词都是&lt;code&gt;copy&lt;/code&gt;。对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>梅子鸡之味</title>
    <link href="http://yoursite.com/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/"/>
    <id>http://yoursite.com/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/</id>
    <published>2023-01-01T13:59:52.000Z</published>
    <updated>2023-01-02T09:08:34.089Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有安静地看一部电影了，在新年的第一天，经一位网友的推荐，看了这部充满浪漫色彩的“喜剧”。电影开始时确实有点让人摸不着头脑，以至于常常被逗笑，可越看越有一种悲伤的气息扑面而来。我倒没有真的很悲伤，但确实引发了我的一些思考。</p><p>影片的结构很精巧，开始就说明了主人公的最终命运——八天后的死亡，然后从第一天直到第八天，层层递进，描绘了他面对即将到来的死亡的内心变化，并且在这之间穿插了过往历史进行深入阐述，直至最后与影片开头呼应，将整个故事完美串联到一起。</p><p>影片采用一种夸张的浪漫主义手法讲述故事。故事背景设定在上世纪中叶的法国，电影画面营造了一种饱含历史气息的氛围，让人很难想象这是一部2011年的电影。正是这种氛围，让人渐渐走进故事，就像被拉进了故事中，仿佛真切看到了发生的一切，让我想起了一部很久前看过的电影《爱有来生》，似有异曲同工之妙。</p><p>影片的故事从主人公、主人公的妻子、主人公的所爱三个人展开，主人公与所爱互相爱慕，却因为现实不得不分开，主人公的妻子深爱主人公，却爱而不得，最终导致了三个人的悲剧。摔坏的小提琴是主人公爱的破碎，也是主人公妻子爱的破碎，更是主人公所爱爱的破碎，正因如此，他才会选择死亡。电影从爱情与婚姻、艺术与生活、梦与现实，乃至教育、家庭、责任、社会、宗教、死亡、命运等多个角度进行了深入探讨，每一个角度都值得我们深入思考，所以这不仅仅是一个悲惨的爱情故事，更是一部千姿百态的生活全景图。</p><p>然而，电影在充满悲剧色彩的故事中还是给了我们一丝温暖与慰藉的。电影结尾，在主人公的坟墓前，爱他的人都来送他最后一程，包括他的挚爱；电影中主人公最想不到的小儿子在深夜为他默默祈祷；主人公母亲去世后坟墓上漂浮的烟雾花朵。即使生活充满支离破碎，命运满是伤痕，总是有人在乎你，爱着你的，即使他们终将离我们而去，但曾经留下的痕迹与回忆相信在最寒冷的黑夜也能给我们些许暖意。</p><p>最后，这确实是一部值得推荐和隔一段时间反复观看的电影。</p><p><img src="/2023/01/01/%E6%A2%85%E5%AD%90%E9%B8%A1%E4%B9%8B%E5%91%B3/梅子鸡之味.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久没有安静地看一部电影了，在新年的第一天，经一位网友的推荐，看了这部充满浪漫色彩的“喜剧”。电影开始时确实有点让人摸不着头脑，以至于常常被逗笑，可越看越有一种悲伤的气息扑面而来。我倒没有真的很悲伤，但确实引发了我的一些思考。&lt;/p&gt;
&lt;p&gt;影片的结构很精巧，开始就说明了主</summary>
      
    
    
    
    <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>C++11：引用限定符</title>
    <link href="http://yoursite.com/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    <id>http://yoursite.com/2023/01/01/C-11%EF%BC%9A%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6/</id>
    <published>2023-01-01T00:49:01.000Z</published>
    <updated>2023-01-01T01:26:38.500Z</updated>
    
    <content type="html"><![CDATA[<p>C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p><a id="more"></a><h2 id="1-C-11：引用限定符"><a href="#1-C-11：引用限定符" class="headerlink" title="1. C++11：引用限定符"></a>1. C++11：引用限定符</h2><p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p><p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。<strong>所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</strong><br>修改上面程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 17 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。<br>同理，我们再次修改程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num):num(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p><blockquote><p>注意：引用限定符不适用于静态成员函数和友元函数。</p></blockquote><h2 id="2-const和引用限定符"><a href="#2-const和引用限定符" class="headerlink" title="2. const和引用限定符"></a>2. const和引用限定符</h2><p>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 get_num() 就是一个常成员函数。const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。<br>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> num,<span class="keyword">int</span> num2) :num(num),num2(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="keyword">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.get_num() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">move</span>(a).get_num2() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中有左值和右值的概念。其实，左值和右值的区分也同样适用于类对象，本文中将左值的类对象称为左值对象，将右值的类对象称为右值对象。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>不知如何起标题的2022</title>
    <link href="http://yoursite.com/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/"/>
    <id>http://yoursite.com/2022/12/31/%E4%B8%8D%E7%9F%A5%E5%A6%82%E4%BD%95%E8%B5%B7%E6%A0%87%E9%A2%98%E7%9A%842022/</id>
    <published>2022-12-31T08:44:48.000Z</published>
    <updated>2022-12-31T13:26:27.418Z</updated>
    
    <content type="html"><![CDATA[<p>想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）</p><p>翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成，庆幸的是总还是有一点进展的，虽然只是一点点。</p><p>无论如何，还是认识了一些新朋友，新老师，还有新网友。从他们那里，学到了很多东西，说明走出去，多见见世面，总归是好的。学习上，上课、看论文、做实验，有条不紊。虽然没怎么用功，但还是获得了二等学业奖学金，还是很开心的。科研上，还没有什么实质性成果，但是研究方向和目标已经明确和清晰，接下来就是一步步向前迈进和解决问题。生活上，没什么特别高兴的事，但比起糟糕的2021年，已经是很大的进步了。</p><p>这么看，今年还是不错的一年，但，还是有很多遗憾。因为疫情，上半年一直在家上网课，下半年被封在学校，始终没能出去走走看看。马上2023年了，我还是一个人，今晚的跨年又是一个人过，可悲可叹！其实，去年认识了一个女生，虽然接触不多，但我也不知道为什么对她有莫名的好感。从小到大，我都没有喜欢过一个女孩，我曾经一度以为，我是一个没有心的人，不懂得什么叫喜欢，因为我真的不知道喜欢一个人是什么感觉，直到遇见了她。对不起，内心戏有点多了，这也许并不是喜欢，只是有好感吧，又或者，这只是一个我想象中的女生，因为我已经一年没见过她了，只在微信聊过几句学习上的事。甚至她可能已经有男朋友了吧？笑死，我真是太可笑了！那就定一个目标吧，如果知道明年她还没有对象，我就鼓起勇气真正地走近她，至少不留遗憾。</p><p>3年的疫情终于迎来了转机，虽然我在放开后第一波就感染了，过程还很难受，好在很快就恢复了。身边越来越多的亲戚朋友都感染了，倒是没有听说有严重的，但是现实中肯定还是有很多重症。身处时代的漩涡中，作为普通人，我们无可奈何，只能尽力而为，保护好自己和所爱的人。</p><p>可是，阴霾总会过去的！我不是天生的乐观派，但我依旧相信希望，人总得有点希望。虽然这世间的一切本来不属于某个人，也终将不属于某个人。虽然我们可能经历苦难，面对疾病，遭遇挫折，背负谩骂，可是那又怎么样呢？宇宙那么大，我们何其渺小，就让我们做颗遥远恒星，隐约在茫茫天际，闪烁着微光足矣。</p><p>愿我所爱，万事胜意！</p><p>愿爱我的人，永远幸福！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想写点什么，记录一下即将过去的这一年。可是面对电脑屏幕，想了半小时都想不出一个合适的标题，可见这一年确实没什么值得说的。不过这也是好事，说明这一年没什么坏事。（真是听君一席话，如听一席话。）&lt;/p&gt;
&lt;p&gt;翻了年初给自己定的目标，总共4条，只完成1条。剩下的3条，虽然没完成</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++11：longlong超长整型和nullptr初始化空指针</title>
    <link href="http://yoursite.com/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2022/12/31/C-11%EF%BC%9Alonglong%E8%B6%85%E9%95%BF%E6%95%B4%E5%9E%8B%E5%92%8Cnullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88/</id>
    <published>2022-12-31T00:42:06.000Z</published>
    <updated>2022-12-31T01:31:44.597Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。<a id="more"></a></p><h2 id="1-C-11：long-long-超长整型"><a href="#1-C-11：long-long-超长整型" class="headerlink" title="1. C++11：long long 超长整型"></a>1. C++11：long long 超长整型</h2><p>C++ 11 标准中，基于整数大小的考虑，共提供了如下表所示的这些数据类型。与此同时，标准中还明确限定了各个数据类型最少占用的位数。</p><div class="table-container"><table><thead><tr><th>整数类型</th><th>等价类型</th><th>C++11标准规定占用最少位数</th></tr></thead><tbody><tr><td>short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short int</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned short</td><td>unsigned short int（无符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned short int</td><td>unsigned short int（无符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned</td><td>unsigned int（无符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>unsigned int</td><td>unsigned int（无符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long int</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>signed long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>signed long int</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>unsigned long</td><td>unsigned long int（无符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>unsigned long int</td><td>unsigned long int（无符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>long long int（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>signed long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>signed long long int（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>unsigned long long（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>unsigned long long int（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td>至少 64 位（8 个字节）</td></tr></tbody></table></div><blockquote><p>C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。不过需要注意的是，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</p></blockquote><p>在上表罗列的这些数据类型中，long long 超长整型是 C++ 11 标准新添加的。其实早在 1995 年，就有人提议将 long long 整形写入 C++ 98 标准，但被委员会拒绝了。而后 long long 整形被 C99 标准（C语言标准之一）采纳，并逐渐被很多编译器支持，于是 C++ 标准委员会重新决定将 long long 整形写入 C++ 11 标准中。</p><p>如同 long 类型整数需明确标注 “L” 或者 “l” 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p><ul><li>对于有符号 long long 整形，后缀用 “LL” 或者 “ll” 标识。例如，”10LL” 就表示有符号超长整数 10；</li><li>对于无符号 long long 整形，后缀用 “ULL”、”ull”、”Ull” 或者 “uLL” 标识。例如，”10ULL” 就表示无符号超长整数 10。</li></ul><blockquote><p>如果不添加任何标识，则所有的整数都会默认为 int 类型。</p></blockquote><p>对于 long long 类型来说，如果想了解当前平台上 long long 整形的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：<br>1）LLONG_MIN：代表当前平台上最小的 long long 类型整数；<br>2）LLONG_MAX：代表当前平台上最大的 long long 类型整数；<br>3）ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"long long最大值："</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">" "</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt;<span class="string">"long long最小值："</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt; <span class="string">"unsigned long long最大值："</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">" "</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为（不唯一）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">-9223372036854775808</span> <span class="number">8000000000000000</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>最小值：<span class="number">9223372036854775807</span> <span class="number">7f</span>ffffffffffffff</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>最大值：<span class="number">18446744073709551615</span> ffffffffffffffff</span><br></pre></td></tr></table></figure><p>此程序中，输出了各最大值和最小值对应的十六进制，显然在当前平台（Windows10 64位操作系统）上，long long 超长整型占用 64 位（也就是 16 个字节）的存储空间。</p><h2 id="2-C-11：nullptr-初始化空指针"><a href="#2-C-11：nullptr-初始化空指针" class="headerlink" title="2. C++11：nullptr 初始化空指针"></a>2. C++11：nullptr 初始化空指针</h2><p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p><blockquote><p>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p></blockquote><p>C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。<br>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p><p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="number">0</span>);</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">int</span> n</span><br></pre></td></tr></table></figure><p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。<br>C++ 98/03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isnull( (<span class="keyword">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line">isnull( (<span class="keyword">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure><p>如此，才会成功调用我们预期的函数。</p><p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。</p><blockquote><p>在使用 nullptr 之前，需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，则需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std=c++0x 编译选项）。</p></blockquote><p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p><p>值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p><p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"void*c"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isnull(<span class="literal">NULL</span>);</span><br><span class="line">    isnull(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n</span><br><span class="line"><span class="keyword">void</span>*c</span><br></pre></td></tr></table></figure><p>借助执行结果不难看出，由于 nullptr 无法隐式转换为整形，而可以隐式匹配指针类型，因此执行结果和我们的预期相符。</p><p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++11 标准中新添加的 long long 超长整型和 nullptr 初始化空指针。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：constexpr关键字</title>
    <link href="http://yoursite.com/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2022/12/30/C-11%EF%BC%9Aconstexpr%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-12-30T02:17:44.000Z</published>
    <updated>2022-12-30T03:08:35.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-常量表达式"><a href="#1-C-常量表达式" class="headerlink" title="1. C++常量表达式"></a>1. C++常量表达式</h2><p>constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。</p><p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。<a id="more"></a></p><p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure><p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p><p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。而常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p><blockquote><p>注意：获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p></blockquote><h2 id="2-constexpr修饰普通变量"><a href="#2-constexpr修饰普通变量" class="headerlink" title="2. constexpr修饰普通变量"></a>2. constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：2</p><blockquote><p>注意：可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p></blockquote><p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p><blockquote><p>需要注意的是，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。但我们必须清楚，const 和 constexpr 并不相同。</p><p>另外需要注意的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p></blockquote><h2 id="3-constexpr修饰函数"><a href="#3-constexpr修饰函数" class="headerlink" title="3. constexpr修饰函数"></a>3. constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。但需要注意，constexpr 并非可以修改任意函数的返回值，一个函数要想成为常量表达式函数，必须满足如下 4 个条件：</p><p>1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。如下是正确的定义 display() 常量表达式函数的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p><p>2) 该函数必须有返回值，即函数的返回值类型不能是 void。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p><p>3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; noconst_dis(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：可尝试将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p></blockquote><p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p><p>4) return 返回的表达式必须是常量表达式，举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p><blockquote><p>注意：在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的。</p></blockquote><h2 id="4-constexpr修饰类的构造函数"><a href="#4-constexpr修饰类的构造函数" class="headerlink" title="4. constexpr修饰类的构造函数"></a>4. constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。<br>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p><p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    constexpr myType(char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p><blockquote><p>注意：constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p></blockquote><p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr myType(const char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.getname();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.getage();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p></blockquote><h2 id="5-constexpr修饰模板函数"><a href="#5-constexpr修饰模板函数" class="headerlink" title="5. constexpr修饰模板函数"></a>5. constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> = <span class="title">dispaly</span>(<span class="title">stu</span>);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret.name &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = dispaly(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p><ul><li>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li><li>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-C-常量表达式&quot;&gt;&lt;a href=&quot;#1-C-常量表达式&quot; class=&quot;headerlink&quot; title=&quot;1. C++常量表达式&quot;&gt;&lt;/a&gt;1. C++常量表达式&lt;/h2&gt;&lt;p&gt;constexpr 是 C++ 11 标准新引入的关键字，在学习其具体用法和功能之前，我们需要先搞清楚 C++ 常量表达式的含义。&lt;/p&gt;
&lt;p&gt;所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：for循环（基于范围的循环）</title>
    <link href="http://yoursite.com/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/29/C-11%EF%BC%9Afor%E5%BE%AA%E7%8E%AF%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%EF%BC%89/</id>
    <published>2022-12-29T01:18:12.000Z</published>
    <updated>2022-12-29T12:18:25.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-C-98-03标准的for循环"><a href="#1-C-98-03标准的for循环" class="headerlink" title="1. C++ 98/03标准的for循环"></a>1. C++ 98/03标准的for循环</h2><p>在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如，下面程序演示了用上述结构遍历数组和容器的具体实现过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc,arc+<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (iter = myvector.<span class="built_in">begin</span>(); iter != myvector.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/</span></span><br></pre></td></tr></table></figure><h2 id="2-C-11标准的for循环"><a href="#2-C-11标准的for循环" class="headerlink" title="2. C++ 11标准的for循环"></a>2. C++ 11标准的for循环</h2><p>在 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">  <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li><li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li></ul><p>可以看到，同 C++ 98/03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p><p>下面程序演示了如何用 C++ 11 标准中的 for 循环遍历上面程序定义的 arc 数组和 myvector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"http://c.biancheng.net/cplus/11/"</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : arc) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/cplus/11/ !</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/!</span></span><br></pre></td></tr></table></figure><p>这里有以下 2 点需要说明：<br>1) 程序中在遍历 myvector 容器时，定义了 auto 类型的 ch 变量，当编译器编译程序时，会通过 myvector 容器中存储的元素类型自动推导出 ch 为 char 类型。注意，这里的 ch 不是迭代器类型，而表示的是 myvector 容器中存储的每个元素。</p><p>2) 仔细观察程序的输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为 myvector 容器中没有存储 ‘\0’。</p><h3 id="2-1-遍历用-大括号初始化的列表"><a href="#2-1-遍历用-大括号初始化的列表" class="headerlink" title="2.1 遍历用{}大括号初始化的列表"></a>2.1 遍历用<code>{}</code>大括号初始化的列表</h3><p>新语法格式的 for 循环还支持遍历用<code>{}</code>大括号初始化的列表，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2-2-declaration-参数处定义引用形式的变量"><a href="#2-2-declaration-参数处定义引用形式的变量" class="headerlink" title="2.2 declaration 参数处定义引用形式的变量"></a>2.2 declaration 参数处定义引用形式的变量</h3><p>在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arc[] = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;myvector(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdef</span><br></pre></td></tr></table></figure><p>此程序中先后使用了 2 个新语法格式的 for 循环，其中前者用于修改 myvector 容器中各个元素的值，后者用于输出修改后的 myvector 容器中的各个元素。</p><p>既然 declaration 参数既可以定义普通形式的变量，也可以定义引用形式的变量，应该如何选择呢？其实很简单，如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-C-98-03标准的for循环&quot;&gt;&lt;a href=&quot;#1-C-98-03标准的for循环&quot; class=&quot;headerlink&quot; title=&quot;1. C++ 98/03标准的for循环&quot;&gt;&lt;/a&gt;1. C++ 98/03标准的for循环&lt;/h2&gt;&lt;p&gt;在C++ 98/03标准中，如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(表达式 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; 表达式 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; 表达式 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//循环体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：非受限联合体（union）</title>
    <link href="http://yoursite.com/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/28/C-11%EF%BC%9A%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89/</id>
    <published>2022-12-28T01:54:11.000Z</published>
    <updated>2022-12-28T02:31:44.155Z</updated>
    
    <content type="html"><![CDATA[<p>在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p><a id="more"></a><p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> T&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p><h2 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h2><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++11 取消了这种限制。</p><p>POD 是 C++ 中一个比较重要的概念，POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：<br>1) 没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</p><p>2) 不能包含虚函数和虚基类。</p><p>3) 非静态成员必须声明为 public。</p><p>4) 类中的第一个非静态成员的类型与其基类不同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure><p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p><p>5) 在类或者结构体继承时，满足以下两种情况之一：</p><ul><li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li><li>基类有非静态成员，而派生类没有非静态成员。</li></ul><p>比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; <span class="keyword">int</span> n1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span> :</span> B2 &#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure><p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p><p>6) 所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p><p>7) 此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p><h2 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h2><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p><h2 id="3-非受限联合体的赋值注意事项"><a href="#3-非受限联合体的赋值注意事项" class="headerlink" title="3. 非受限联合体的赋值注意事项"></a>3. 非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。这条规则可能导致对象构造失败，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p><p>解决上面问题的一般需要用到 placement new，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U() &#123; <span class="keyword">new</span>(&amp;s) <span class="built_in">string</span>; &#125;</span><br><span class="line">    ~U() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p><h3 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h3><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。placement new 的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) ClassConstruct(...)</span><br></pre></td></tr></table></figure><p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p><h2 id="4-非受限联合体的匿名声明和“枚举式类”"><a href="#4-非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="4. 非受限联合体的匿名声明和“枚举式类”"></a>4. 非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U&#123;</span><br><span class="line">  <span class="keyword">union</span> &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p><p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Type &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    Singer(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : s(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    Singer(<span class="keyword">int</span> i) : id(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, <span class="built_in">size</span>);</span><br><span class="line">        name[s] = <span class="string">'\0'</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singer(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    Singer(<span class="number">310217</span>);</span><br><span class="line">    Singer(<span class="string">"J Michael"</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C/C++ 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：列表初始化</title>
    <link href="http://yoursite.com/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2022/12/27/C-11%EF%BC%9A%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-12-27T01:23:31.000Z</published>
    <updated>2022-12-27T02:29:03.262Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++98/03 中，对象初始化方法有很多种，如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。<a id="more"></a></p><blockquote><p>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p></blockquote><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98/03 可以使用初始化列表（initializer list）进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，比如下面的代码：通过初始化列表初始化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: 'Foo::Foo(const Foo &amp;)' is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。<br>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。<br>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。<br>a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p><p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure><blockquote><p>在初始化时，<code>{}</code>前面的等于号是否书写对初始化行为没有影响。</p></blockquote><p>另外，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。<br>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。<br>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p><p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span>, <span class="keyword">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p><p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++98/03 中，对象初始化方法有很多种，如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始化列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i_arr[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;;  &lt;span class=&quot;comment&quot;&gt;//普通数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; a = &amp;#123; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;#123; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125; &amp;#125;;  &lt;span class=&quot;comment&quot;&gt;//POD类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//拷贝初始化（copy-initialization）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Foo(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; foo = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//需要拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//直接初始化（direct-initialization）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Foo &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：tuple元组</title>
    <link href="http://yoursite.com/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/"/>
    <id>http://yoursite.com/2022/12/26/C-11%EF%BC%9Atuple%E5%85%83%E7%BB%84/</id>
    <published>2022-12-26T02:48:05.000Z</published>
    <updated>2022-12-26T02:57:51.952Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p><p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p><a id="more"></a><h2 id="1-tuple对象的创建"><a href="#1-tuple对象的创建" class="headerlink" title="1. tuple对象的创建"></a>1. tuple对象的创建</h2><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</tuple></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br></pre></td></tr></table></figure><p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p><h4 id="1-1-类的构造函数"><a href="#1-1-类的构造函数" class="headerlink" title="1.1 类的构造函数"></a>1.1 类的构造函数</h4><p>tuple 模板类提供有很多构造函数，包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line">tuple (<span class="keyword">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line">tuple (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">tuple</span>&lt;UTypes...&gt;&amp; <span class="title">tpl</span>);</span> <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">tuple</span>&lt;UTypes...&gt;&amp;&amp; <span class="title">tpl</span>);</span>      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="keyword">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">UTypes</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">tuple</span> (<span class="title">UTypes</span>&amp;&amp;... <span class="title">elems</span>);</span>  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">const</span> <span class="title">pair</span>&lt;U1,U2&gt;&amp; <span class="title">pr</span>);</span>       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">tuple</span> (<span class="title">pair</span>&lt;U1,U2&gt;&amp;&amp; <span class="title">pr</span>);</span>            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::tuple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    std::tuple&lt;int, char&gt; second(first);                     // 2)   second&#123;&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; third(std::make_tuple(20, 'b'));   // 3)   third&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;long, char&gt; fourth(third);                    // 4)的左值方式, fourth&#123;20,'b'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; fifth(10, 'a');                    // 5)的右值方式, fifth&#123;10.'a'&#125;</span><br><span class="line">    std::tuple&lt;int, char&gt; sixth(std::make_pair(30, 'c'));    // 6)的右值方式, sixth&#123;30,''c&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-make-tuple-函数"><a href="#1-2-make-tuple-函数" class="headerlink" title="1.2 make_tuple()函数"></a>1.2 make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</tuple></p><p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>,<span class="string">'a'</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>; <span class="keyword">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = <span class="built_in">std</span>::make_tuple (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure><p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p><h2 id="2-tuple常用函数"><a href="#2-tuple常用函数" class="headerlink" title="2. tuple常用函数"></a>2. tuple常用函数</h2><p>为了方便在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数，<tuple> 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如下表所示：</tuple></p><div class="table-container"><table><thead><tr><th>函数或类模板</th><th>描 述</th></tr></thead><tbody><tr><td>tup1.swap(tup2) swap(tup1, tup2)</td><td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。</tuple></td></tr><tr><td>get<num>(tup)</num></td><td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</tuple></td></tr><tr><td>tuple_size<type>::value</type></td><td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</tuple></td></tr><tr><td>tuple_element<I, type>::type</I,></td><td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</tuple></td></tr><tr><td>forward_as_tuple<args...></args...></td><td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td></tr><tr><td>tie(args…) = tup</td><td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</tuple></td></tr><tr><td>tuple_cat(args…)</td><td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</tuple></td></tr></tbody></table></div><blockquote><p>tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、&lt;、&gt;、&gt;=、&lt;= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。</p></blockquote><p>以下程序演示了上表中一部分函数模板和类模板的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 'x'</span></span><br><span class="line">    std::tuple&lt;int, char&gt; mytuple(10, 'x');</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_tuple(<span class="string">"test"</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">double</span> mydou;</span><br><span class="line">    <span class="keyword">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    <span class="built_in">std</span>::tie(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = <span class="built_in">std</span>::tuple_cat(mytuple, bar);</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> x</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11 标准新引入了一种类模板，命名为 tuple（元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。&lt;/p&gt;
&lt;p&gt;tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：支持函数模板的默认模板参数</title>
    <link href="http://yoursite.com/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2022/12/25/C-11%EF%BC%9A%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/</id>
    <published>2022-12-25T11:13:04.000Z</published>
    <updated>2022-12-25T11:19:10.033Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++98/03 标准中，类模板可以有默认的模板参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line">struct Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是却不支持函数的默认模板参数：<a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;  <span class="comment">// error in C++98/03: default template arguments</span></span><br><span class="line"><span class="keyword">void</span> func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p><p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p><p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R func(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    func&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int；最后 func<double,int>(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</double,int></char></p><p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">double</span>&gt;</span><br><span class="line"><span class="keyword">void</span> func(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    func(<span class="string">'c'</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    func();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T=char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。由此不难看出，编译器的自动推导能力并没有想象的那么强大。</p><p>总的来说，C++11 支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 C++98/03 标准中，类模板可以有默认的模板参数，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; U = &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, U N = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct Foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是却不支持函数的默认模板参数：&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：返回值类型后置（跟踪返回值类型）</title>
    <link href="http://yoursite.com/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2022/12/24/C-11%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89/</id>
    <published>2022-12-24T02:54:10.000Z</published>
    <updated>2022-12-24T03:03:36.357Z</updated>
    
    <content type="html"><![CDATA[<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。</p><a id="more"></a><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。比如如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure><p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p><p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) add(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，直接像上面这样写是编译不过的。因为 t、u 在参数列表中，而 C++ 的返回值是前置语法，在返回值定义的时候参数变量还不存在。<br>可行的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(T() + U()) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) add(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。因此，<strong>在 C++11 中增加了返回类型后置（trailing-return-type，又称跟踪返回类型）语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</strong></p><p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进一步说明这个语法，再看另一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto func(T&amp; val) -&gt; decltype(foo(val))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说前一个例子中的 add 使用 C++98/03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>图像轮廓提取</title>
    <link href="http://yoursite.com/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"/>
    <id>http://yoursite.com/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/</id>
    <published>2022-12-23T09:11:13.000Z</published>
    <updated>2022-12-23T09:33:19.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、轮廓提取"><a href="#1、轮廓提取" class="headerlink" title="1、轮廓提取"></a>1、轮廓提取</h2><p>轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。<a id="more"></a></p><h2 id="2、轮廓提取方法及Python实现"><a href="#2、轮廓提取方法及Python实现" class="headerlink" title="2、轮廓提取方法及Python实现"></a>2、轮廓提取方法及Python实现</h2><h3 id="2-1-掏空内部点法"><a href="#2-1-掏空内部点法" class="headerlink" title="2.1 掏空内部点法"></a>2.1 掏空内部点法</h3><p>掏空内部点法的原理非常简单：如果原图中有一点为黑，且它的8个相邻点皆为黑色，则将该点删除，否则认为该点在图像的边缘，需要保留。依次处理图像中每一个像素，则最后留下来的就是图像的轮廓。对于非二值图像，需要先进行二值化处理。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_contour</span><span class="params">(bin_img)</span>:</span></span><br><span class="line">    contour_img = np.zeros(shape=(bin_img.shape),dtype=np.uint8)</span><br><span class="line">    contour_img += <span class="number">255</span></span><br><span class="line">    h = bin_img.shape[<span class="number">0</span>]</span><br><span class="line">    w = bin_img.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,h<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,w<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span>(bin_img[i][j]==<span class="number">0</span>):</span><br><span class="line">                contour_img[i][j] = <span class="number">0</span></span><br><span class="line">                sum = <span class="number">0</span></span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j + <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j]</span><br><span class="line">                sum += bin_img[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i][j - <span class="number">1</span>]</span><br><span class="line">                sum += bin_img[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> sum ==  <span class="number">0</span>:</span><br><span class="line">                    contour_img[i][j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contour_img</span><br></pre></td></tr></table></figure><p>效果如下（左侧是Otsu二值化图像；右侧是轮廓图像）：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/1.png" alt></p><h3 id="2-2-opencv-python中轮廓提取方法的应用"><a href="#2-2-opencv-python中轮廓提取方法的应用" class="headerlink" title="2.2 opencv-python中轮廓提取方法的应用"></a>2.2 opencv-python中轮廓提取方法的应用</h3><p>（1）opencv-python中使用cv2.findContours函数来检测图像的边缘，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</span><br></pre></td></tr></table></figure><p><strong>参数说明如下：</strong><br>image：输入图像；<br>mode：轮廓检索模式；<br>method：轮廓逼近方法；<br>contours：返回的轮廓；<br>hierachy：每条轮廓对应的属性；<br>offset：每个轮廓点移动的可选偏移量。<br>备注：image参数需要是二值图，而不是灰度图，返回结果是等高线和层次结构。</p><p><strong>轮廓检索模式：</strong><br>cv2.RETR_EXTERNAL：表示只检测外轮廓；<br>cv2.RETR_LIST：检测的轮廓，不建立等级关系；<br>cv2.RETR_CCOMP：建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层；<br>cv2.RETR_TREE：建立一个等级树结构的轮廓。</p><p><strong>轮廓逼近方法：</strong><br>cv2.CHAIN_APPROX_NONE：存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即 max(abs(x1-x2),abs(y2-y1))==1，一般不会用到；<br>cv2.CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息；<br>cv2.CHAIN_APPROX_TC89_L1，cv2.CV_CHAIN_APPROX_TC89_KCOS：使用teh-Chinl chain近似算法。</p><p>（2）轮廓发现之后，还要通过cv2.drawContours函数绘制轮廓，其函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])</span><br></pre></td></tr></table></figure><p><strong>参数说明如下：</strong><br>image：输入图像；<br>contours：轮廓，在Python中是一个list，就是cv2.findContours函数找出来的点集，一个列表；<br>contourIdx：轮廓的索引，指定绘制轮廓list中的哪条轮廓，要绘制所有轮廓，传递-1；<br>color：颜色；<br>thickness：厚度，如果是-1，表示填充；<br>lineType：线型；<br>hierarchy：层次结构的可选信息；<br>maxLevel：绘制轮廓的最大级别，0：仅绘制指定的轮廓，1：绘制轮廓和所有嵌套轮廓，2：绘制轮廓，所有嵌套轮廓，所有嵌套到嵌套的轮廓；<br>offset：轮廓偏移参数。</p><p>根据上面两个函数，测试代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：读入图像</span></span><br><span class="line">img = cv2.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：对图像做灰度处理</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：对图像做二值化处理</span></span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：获得图像的轮廓值</span></span><br><span class="line">contours, heriachy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步：绘制图像轮廓</span></span><br><span class="line">img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">res = cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(res, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'contour'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/2022/12/23/%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/2.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、轮廓提取&quot;&gt;&lt;a href=&quot;#1、轮廓提取&quot; class=&quot;headerlink&quot; title=&quot;1、轮廓提取&quot;&gt;&lt;/a&gt;1、轮廓提取&lt;/h2&gt;&lt;p&gt;轮廓提取是提取出图像的外部轮廓特征，轮廓可能是边缘的一部分。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="轮廓提取" scheme="http://yoursite.com/tags/%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>C++11：lambda匿名函数</title>
    <link href="http://yoursite.com/2022/11/27/C-11%EF%BC%9Alambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2022/11/27/C-11%EF%BC%9Alambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</id>
    <published>2022-11-27T14:55:41.000Z</published>
    <updated>2022-11-28T08:02:25.271Z</updated>
    
    <content type="html"><![CDATA[<p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p><a id="more"></a><h2 id="1-lambda匿名函数的定义"><a href="#1-lambda匿名函数的定义" class="headerlink" title="1. lambda匿名函数的定义"></a>1. lambda匿名函数的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)<span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type&#123;statement&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>[capture]：捕捉列表，[] 是lambda引出符，编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表用于捕捉父域中的变量以供lambda函数使用，捕捉列表可以由多个项组成，用”,”分割。[var]表示以值传递方式捕捉父域中的变量var，[=]表示以值传递方式捕捉父域中的所有变量（包括this），[&amp;var]表示以引用传递方式捕捉父域中的变量var，[&amp;]表示以引用传递方式捕捉父域中的所有变量（包括this）,[this]表示以值传递方式捕捉当前的this指针。</li><li>(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号()一起省略。</li><li>mutable：mutable修饰符，默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li><li>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，不需要返回值的时候可以连同符号-&gt;一起省略。在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li><li>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li></ul><h3 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h3><div class="table-container"><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td></tr><tr><td>[=]</td><td>只有一个 = 等号，表示以值传递的方式导入所有外部变量；</td></tr><tr><td>[&amp;]</td><td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td></tr><tr><td>[val1,val2,…]</td><td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td>[&amp;val1,&amp;val2,…]</td><td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td>[val,&amp;val2,…]</td><td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr><tr><td>[=,&amp;val1,…]</td><td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的 this 指针。</td></tr></tbody></table></div><blockquote><p> 注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p></blockquote><h3 id="最简单的lambda匿名函数"><a href="#最简单的lambda匿名函数" class="headerlink" title="最简单的lambda匿名函数"></a>最简单的lambda匿名函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure><p>此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，这是一个没有任何功能的 lambda 匿名函数。</p><h2 id="2-lambda匿名函数的使用"><a href="#2-lambda匿名函数的使用" class="headerlink" title="2. lambda匿名函数的使用"></a>2. lambda匿名函数的使用</h2><h3 id="2-1-lambda匿名函数的定义和使用"><a href="#2-1-lambda匿名函数的定义和使用" class="headerlink" title="2.1 lambda匿名函数的定义和使用"></a>2.1 lambda匿名函数的定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 对数组 num 中的元素进行升序排序</span></span><br><span class="line">    sort(num, num + <span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> x &lt; y; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。而如果使用普通函数，需以如下代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_up</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">// 对数组 num 中的元素进行升序排序</span></span><br><span class="line">    sort(num, num + <span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序中 sort_up() 函数的功能和上一个程序中的 lambda 匿名函数完全相同。显然在类似的场景中，使用 lambda 匿名函数更有优势。</p><p>除此之外，虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">display</span> = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; <span class="keyword">void</span>&#123;<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">// 调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 输出：10 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p><h3 id="2-2-值传递和引用传递的区别"><a href="#2-2-值传递和引用传递的区别" class="headerlink" title="2.2 值传递和引用传递的区别"></a>2.2 值传递和引用传递的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda1:\n"</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=] &#123;</span><br><span class="line">        <span class="comment">// 全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda1();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"lambda2:\n"</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;] &#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda2();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; all_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lambda1:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">lambda2:</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。其中，lambda1 匿名函数是以 [=] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num_1 &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</p><h3 id="2-3-执行抛出异常类型"><a href="#2-3-执行抛出异常类型" class="headerlink" title="2.3 执行抛出异常类型"></a>2.3 执行抛出异常类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="keyword">throw</span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        except();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获到了整形异常"</span>;<span class="comment">// 输出：捕获到了整形异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p><p>在此基础上，再看一下反例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="keyword">throw</span>(<span class="keyword">char</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        except1();</span><br><span class="line">        except2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获到了整形异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p><blockquote><p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。&lt;/p&gt;</summary>
    
    
    
    <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>图像滤波</title>
    <link href="http://yoursite.com/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/"/>
    <id>http://yoursite.com/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/</id>
    <published>2022-10-12T09:04:16.000Z</published>
    <updated>2022-10-12T09:15:52.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图像滤波"><a href="#1-图像滤波" class="headerlink" title="1. 图像滤波"></a>1. 图像滤波</h1><p>图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</p><p>图像滤波按图像域可分为两种类型：</p><p>邻域滤波(Spatial Domain Filter)，其本质是数字窗口上的数学运算。一般用于图像平滑、图像锐化、特征提取(如纹理测量、边缘检测)等，邻域滤波使用邻域算子——利用给定像素周围像素值以决定此像素最终输出的一种算子。邻域滤波方式又分为线性滤波和非线性滤波，其中线性滤波包括均值滤波、方框滤波和高斯滤波等，非线性滤波包括中值滤波和双边滤波等。</p><p>频域滤波(Frequency Domain Filter)，其本质是对像素频率的修改。一般用于降噪、重采样、图像压缩等。按图像频率滤除效果主要分为两种类型：低通滤波（滤除原图像的高频成分，即模糊图像边缘与细节）和高通滤波（滤除原图像的低频成分，即图像锐化）。</p><a id="more"></a><h1 id="2-图像滤波的常用方法"><a href="#2-图像滤波的常用方法" class="headerlink" title="2. 图像滤波的常用方法"></a>2. 图像滤波的常用方法</h1><h2 id="2-1-均值滤波"><a href="#2-1-均值滤波" class="headerlink" title="2.1 均值滤波"></a>2.1 均值滤波</h2><p>均值滤波采用多次测量取平均值的思想，用每一个像素周围的像素的平均值代替自身。均值滤波是方框滤波归一化后的特殊情况。</p><p>取卷积核（Kernel）区域下所有像素的平均值并替换中心元素，如下公式：</p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.1.png" alt></p><p>优点：能够将受到噪声影响的像素使用该噪声周围的像素值进行修复，对椒盐噪声的滤除比较好。<br>缺点：不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊。</p><h2 id="2-2-方框滤波"><a href="#2-2-方框滤波" class="headerlink" title="2.2 方框滤波"></a>2.2 方框滤波</h2><p>与均值滤波不同的是，方框滤波不会计算像素的均值。在均值滤波中，滤波结果的像素值是任意一个点的邻域平均值，等于各邻域像素值之和除以邻域面积。而在方框滤波中，可以自由选择是否对均值滤波的结果进行归一化，即可以自由选择滤波结果是邻域像素值之和的平均值，还是邻域像素值之和。</p><p>公式如下：</p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.2.png" alt></p><p>当normalize=True时，与均值滤波结果相同；<br>当normalize=False时，表示对加和后的结果不进行平均操作，大于255的使用255表示。</p><h2 id="2-3-高斯滤波"><a href="#2-3-高斯滤波" class="headerlink" title="2.3 高斯滤波"></a>2.3 高斯滤波</h2><p>高斯滤波(Gauss Filter)基于二维高斯核函数。用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。高斯滤波主要用来去除高斯噪声。</p><p>高斯滤波具有在保持细节的条件下进行噪声滤波的能力，因此广泛应用于图像降噪中，但其效率比均值滤波低。</p><h2 id="2-4-中值滤波"><a href="#2-4-中值滤波" class="headerlink" title="2.4 中值滤波"></a>2.4 中值滤波</h2><p>中值滤波将待处理的像素周围像素从小到大排序，取中值代替该像素。</p><p>优点：去除脉冲噪声、椒盐噪声的同时又能保留图像边缘细节。<br>缺点：当卷积核较大时，仍然使得图像变得模糊，而且计算量很大。</p><h2 id="2-5-双边滤波"><a href="#2-5-双边滤波" class="headerlink" title="2.5 双边滤波"></a>2.5 双边滤波</h2><p>因为高斯滤波把距离设为权重，设计滤波模板作为滤波系数，并且只考虑像素之间的空间位置关系，所以滤波结果丢失了边缘信息。</p><p>双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。</p><h2 id="2-6-低通滤波"><a href="#2-6-低通滤波" class="headerlink" title="2.6 低通滤波"></a>2.6 低通滤波</h2><p>规则为低频信息能正常通过，而超过设定临界值的高频信息则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序（目的）而改变。</p><p>低通滤波，通过了低频信息，保留了图像背景和基本内容，图像边缘被阻挡，图像变模糊。</p><h2 id="2-7-高通滤波"><a href="#2-7-高通滤波" class="headerlink" title="2.7 高通滤波"></a>2.7 高通滤波</h2><p>规则为高频信息能正常通过，而低于设定临界值的低频信息则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序(目的)而改变。</p><p>高通滤波，通过了高频信息，提取了图像边缘和噪声。</p><h1 id="3-opencv-python中各种滤波方法的应用"><a href="#3-opencv-python中各种滤波方法的应用" class="headerlink" title="3. opencv-python中各种滤波方法的应用"></a>3. opencv-python中各种滤波方法的应用</h1><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line">img_blur = cv.blur(img, (<span class="number">3</span>,<span class="number">3</span>)) <span class="comment"># (3,3)代表卷积核尺寸，随着尺寸变大，图像会越来越模糊</span></span><br><span class="line">img_blur = cv.cvtColor(img_blur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方框滤波</span></span><br><span class="line">img_boxFilter1 = cv.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>,<span class="number">3</span>), normalize=<span class="literal">True</span>) <span class="comment"># 当 normalize=True 时，与均值滤波结果相同</span></span><br><span class="line">img_boxFilter1 = cv.cvtColor(img_boxFilter1, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line">img_boxFilter2 = cv.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>,<span class="number">3</span>), normalize=<span class="literal">False</span>)</span><br><span class="line">img_boxFilter2 = cv.cvtColor(img_boxFilter2, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line">img_GaussianBlur= cv.GaussianBlur(img, (<span class="number">3</span>,<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 参数说明：(源图像，核大小，x方向的标准差，y方向的标准差)</span></span><br><span class="line">img_GaussianBlur = cv.cvtColor(img_GaussianBlur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line">img_medianBlur = cv.medianBlur(img, <span class="number">3</span>)</span><br><span class="line">img_medianBlur = cv.cvtColor(img_medianBlur, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双边滤波</span></span><br><span class="line"><span class="comment"># 参数说明：(源图像，核大小，sigmaColor，sigmaSpace)</span></span><br><span class="line">img_bilateralFilter=cv.bilateralFilter(img, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">img_bilateralFilter = cv.cvtColor(img_bilateralFilter, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'img_blur'</span>, <span class="string">'img_boxFilter1'</span>, <span class="string">'img_boxFilter2'</span>,</span><br><span class="line">          <span class="string">'img_GaussianBlur'</span>, <span class="string">'img_medianBlur'</span>, <span class="string">'img_bilateralFilter'</span>]</span><br><span class="line">images = [img_blur, img_boxFilter1, img_boxFilter2, img_GaussianBlur, img_medianBlur, img_bilateralFilter]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i+<span class="number">1</span>), plt.imshow(images[i]), plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通滤波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Low_Pass_Filter</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    <span class="comment">#img = cv.imread('srcImg_path', 0)</span></span><br><span class="line">    img = np.array(Image.open(srcImg_path))</span><br><span class="line">    img = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶变换</span></span><br><span class="line">    dft = cv.dft(np.float32(img), flags = cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    fshift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置低通滤波器</span></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment"># 中心位置</span></span><br><span class="line">    mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 掩膜图像和频谱图像乘积</span></span><br><span class="line">    f = fshift * mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶逆变换</span></span><br><span class="line">    ishift = np.fft.ifftshift(f)</span><br><span class="line">    iimg = cv.idft(ishift)</span><br><span class="line">    res = cv.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">High_Pass_Filter</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    <span class="comment">#img = cv.imread(srcImg_path, 0)</span></span><br><span class="line">    img = np.array(Image.open(srcImg_path))</span><br><span class="line">    img = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶变换</span></span><br><span class="line">    dft = cv.dft(np.float32(img), flags = cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    fshift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置高通滤波器</span></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = int(rows/<span class="number">2</span>), int(cols/<span class="number">2</span>) <span class="comment"># 中心位置</span></span><br><span class="line">    mask = np.ones((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow<span class="number">-30</span>:crow+<span class="number">30</span>, ccol<span class="number">-30</span>:ccol+<span class="number">30</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 掩膜图像和频谱图像乘积</span></span><br><span class="line">    f = fshift * mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 傅里叶逆变换</span></span><br><span class="line">    ishift = np.fft.ifftshift(f)</span><br><span class="line">    iimg = cv.idft(ishift)</span><br><span class="line">    res = cv.magnitude(iimg[:,:,<span class="number">0</span>], iimg[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">img_Low_Pass_Filter = Low_Pass_Filter(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img_Low_Pass_Filter, <span class="string">'gray'</span>), plt.title(<span class="string">'img_Low_Pass_Filter'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">img_High_Pass_Filter = High_Pass_Filter(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(img_High_Pass_Filter, <span class="string">'gray'</span>), plt.title(<span class="string">'img_High_Pass_Filter'</span>)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>滤波图像如下：</p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.8.1.png" alt></p><p><img src="/2022/10/12/%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/2.8.2.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-图像滤波&quot;&gt;&lt;a href=&quot;#1-图像滤波&quot; class=&quot;headerlink&quot; title=&quot;1. 图像滤波&quot;&gt;&lt;/a&gt;1. 图像滤波&lt;/h1&gt;&lt;p&gt;图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。&lt;/p&gt;
&lt;p&gt;图像滤波按图像域可分为两种类型：&lt;/p&gt;
&lt;p&gt;邻域滤波(Spatial Domain Filter)，其本质是数字窗口上的数学运算。一般用于图像平滑、图像锐化、特征提取(如纹理测量、边缘检测)等，邻域滤波使用邻域算子——利用给定像素周围像素值以决定此像素最终输出的一种算子。邻域滤波方式又分为线性滤波和非线性滤波，其中线性滤波包括均值滤波、方框滤波和高斯滤波等，非线性滤波包括中值滤波和双边滤波等。&lt;/p&gt;
&lt;p&gt;频域滤波(Frequency Domain Filter)，其本质是对像素频率的修改。一般用于降噪、重采样、图像压缩等。按图像频率滤除效果主要分为两种类型：低通滤波（滤除原图像的高频成分，即模糊图像边缘与细节）和高通滤波（滤除原图像的低频成分，即图像锐化）。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像二值化</title>
    <link href="http://yoursite.com/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/"/>
    <id>http://yoursite.com/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/</id>
    <published>2022-10-11T10:26:05.000Z</published>
    <updated>2022-10-11T11:50:42.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图像二值化"><a href="#1-图像二值化" class="headerlink" title="1. 图像二值化"></a>1. 图像二值化</h1><p>图像二值化就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。</p><p>要得到二值化图像，首先要把图像灰度化，然后将256个亮度等级的灰度图像通过适当的阈值选取而获得仍然可以反映图像整体和局部特征的二值化图像。所有灰度大于或等于阈值的像素被判定为属于特定物体，其灰度值为255，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。</p><a id="more"></a><h1 id="2-图像二值化方法及Python实现"><a href="#2-图像二值化方法及Python实现" class="headerlink" title="2. 图像二值化方法及Python实现"></a>2. 图像二值化方法及Python实现</h1><p>比较常用的二值化方法有：简单二值法，平均值法，双峰法和OTSU法等。</p><h2 id="2-1-简单二值法"><a href="#2-1-简单二值法" class="headerlink" title="2.1 简单二值法"></a>2.1 简单二值法</h2><p>将图像灰度化后，我们选择127(灰度值范围的一半)作为阈值，即将像素值大于127的像素值全部设为255，小于127的全部设为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Easy_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    img_gray[img_gray&gt;<span class="number">127</span>] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=<span class="number">127</span>] = <span class="number">0</span></span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Easy_Binarization'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.1.png" alt></p><h2 id="2-2-平均值法"><a href="#2-2-平均值法" class="headerlink" title="2.2 平均值法"></a>2.2 平均值法</h2><p>为了应对每张图片的灰度值大不相同，阈值取为图像本身的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mean_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    threshold = np.mean(img_gray)</span><br><span class="line">    print(threshold)</span><br><span class="line">    img_gray[img_gray&gt;threshold] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=threshold] = <span class="number">0</span></span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Mean_Binarization'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.2.png" alt></p><p>实验中该方法计算的阈值为123。</p><h2 id="2-3-双峰法"><a href="#2-3-双峰法" class="headerlink" title="2.3 双峰法"></a>2.3 双峰法</h2><p>直方图是图像的重要特质，它可以帮助我们分析图像中的灰度变化。因此，如果物体与背景的灰度值对比明显，直方图就会包含双峰，它们分别为图像的前景和背景，而它们之间的谷底即为边缘附近相对较少数目的像素点，一般来讲，这个最小值就为最优二值化的分界点，通过这个点可以把前景和背景很好地分开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hist_Binarization</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    hist = img_gray.flatten()</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.hist(hist,<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    cnt_hist = Counter(hist)</span><br><span class="line">    print(cnt_hist)</span><br><span class="line">    begin,end = cnt_hist.most_common(<span class="number">2</span>)[<span class="number">0</span>][<span class="number">0</span>],cnt_hist.most_common(<span class="number">2</span>)[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> begin &gt; end:</span><br><span class="line">        begin, end = end, begin</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;begin&#125;</span>: <span class="subst">&#123;end&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    cnt = np.iinfo(np.int16).max</span><br><span class="line">    threshold = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin,end+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> cnt_hist[i]&lt;cnt:</span><br><span class="line">            cnt = cnt_hist[i]</span><br><span class="line">            threshold = i</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;threshold&#125;</span>: <span class="subst">&#123;cnt&#125;</span>'</span>)</span><br><span class="line">    img_gray[img_gray&gt;threshold] = <span class="number">255</span></span><br><span class="line">    img_gray[img_gray&lt;=threshold] = <span class="number">0</span></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.imshow(img_gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.3.png" alt></p><p>实验中该方法得到的双峰为(145,154)，阈值为150。</p><h2 id="2-4-OTSU法"><a href="#2-4-OTSU法" class="headerlink" title="2.4 OTSU法"></a>2.4 OTSU法</h2><p>双峰法具有明显的缺陷，因为直方图是不连续的，有非常多尖峰和抖动，要找到准确的极值点十分困难。日本工程师大津展之为这个波谷找到了一个合适的数学表达，并于1979年发表。这个二值化方法称为大津算法（Otsu’s method）。</p><p>OTSU法也称作最大类间方差法，因为按照大津法求得的阈值进行图像二值化分割后，前景与背景图像的类间方差最大。它被认为是图像分割中阈值选取的最佳算法，计算简单，不受图像亮度和对比度的影响，因此在数字图像处理上得到了广泛的应用。它是按图像的灰度特性，将图像分成背景和前景两部分。因方差是灰度分布均匀性的一种度量,背景和前景之间的类间方差越大,说明构成图像的两部分的差别越大,当部分前景错分为背景或部分背景错分为前景都会导致类间差别变小。因此,使类间方差最大的分割意味着错分概率最小。</p><p>具体计算阈值方法如下：<br>设阈值为t, 将原图转化成灰度图后，将其高与宽存于h,w，并将小于阈值的灰度值存储在前景front中，大于等于阈值的存在背景back中。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阈值：t</span></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">front = img[img &lt; t]</span><br><span class="line">back = img[img &gt;= t]</span><br></pre></td></tr></table></figure><p> 显然，前景与背景的长度和应与h, w的乘积相等，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(front) + len(back) == h * w.</span><br></pre></td></tr></table></figure><p>设前景像素数量占总像素数量的比重为frontP，背景像素数量占总像素数量的比重为backP，前景和背景的灰度平均值分别为frontMean和backMean，总平均灰度值为m，则方差公式可写成：</p><script type="math/tex; mode=display">v=frontP*(frontMean-m)^2+backP*(backMean-m)^2</script><p>又因为：</p><script type="math/tex; mode=display">m=frontP*frontMean+backP*backMean</script><p>上式可化简为：</p><script type="math/tex; mode=display">v=frontP*backP*(frontMean-backMean)^2</script><p>实验代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Otsu</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    threshold_t = <span class="number">0</span></span><br><span class="line">    max_g = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">        front = img[img &lt; t]</span><br><span class="line">        back = img[img &gt;= t]</span><br><span class="line">        front_p = len(front) / (h * w)</span><br><span class="line">        back_p = len(back) / (h * w)</span><br><span class="line">        front_mean = np.mean(front) <span class="keyword">if</span> len(front) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.</span></span><br><span class="line">        back_mean = np.mean(back) <span class="keyword">if</span> len(back) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.</span></span><br><span class="line">        </span><br><span class="line">        g = front_p * back_p * ((front_mean - back_mean)**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> g &gt; max_g:</span><br><span class="line">            max_g = g</span><br><span class="line">            threshold_t = t</span><br><span class="line">    print(<span class="string">f"threshold = <span class="subst">&#123;threshold_t&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    img[img &lt; threshold_t] = <span class="number">0</span></span><br><span class="line">    img[img &gt;= threshold_t] = <span class="number">255</span></span><br><span class="line">    plt.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(<span class="string">'Otsu'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>二值化图像如下：</p><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/2.4.png" alt></p><p><strong>对比以上四种方法可以发现，Otsu方法得到的二值化图像细节更多，图像更细腻。</strong></p><h1 id="3-opencv-python中二值化方法的应用"><a href="#3-opencv-python中二值化方法的应用" class="headerlink" title="3. opencv-python中二值化方法的应用"></a>3. opencv-python中二值化方法的应用</h1><p>在OpenCV中，分为简单的阈值分割与自适应阈值分割。</p><h2 id="3-1-简单阈值分割（Simple-Thresholding）"><a href="#3-1-简单阈值分割（Simple-Thresholding）" class="headerlink" title="3.1 简单阈值分割（Simple Thresholding）"></a>3.1 简单阈值分割（Simple Thresholding）</h2><p>函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval, dst = cv.threshold(src, thresh, maxval, type[, dst])</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一个参数src为原图，需要注意的是输入的图像需为灰度图。</span><br><span class="line">第二个参数thresh即为阈值，用于对像素值的分类(一般定义为<span class="number">127</span>)。</span><br><span class="line">第三个参数maxval是最大值，即超过阈值后所定义的值(<span class="number">255</span>)。</span><br><span class="line">第四个参数type，在Simple Thresholding中一共有五种不同的方式：</span><br><span class="line">cv.THRESH_BINARY</span><br><span class="line">cv.THRESH_BINARY_INV</span><br><span class="line">cv.THRESH_TRUNC</span><br><span class="line">cv.THRESH_TOZERO</span><br><span class="line">cv.THRESH_TOZERO_INV</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)</span><br><span class="line">ret,thresh1 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下图是5种方式的实际效果：</p><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/3.1.png" alt></p><h2 id="3-2-自适应阈值分割（Adaptive-Thresholding）"><a href="#3-2-自适应阈值分割（Adaptive-Thresholding）" class="headerlink" title="3.2 自适应阈值分割（Adaptive Thresholding）"></a>3.2 自适应阈值分割（Adaptive Thresholding）</h2><p>函数原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])</span><br></pre></td></tr></table></figure><p>其中src, maxValue和thresholdType与Simple Thresholding相同。</p><p>在自适应阈值分割中，adaptive method(阈值的计算方式)有两种：<br>cv.ADAPTIVE_THRESH_MEAN_C: 邻域面积(blockSize * blockSize)的平均值并减去C.<br>cv.ADAPTIVE_THRESH_GAUSSIAN_C: 邻域面积的高斯加权总和然后减去C.</p><p>下面是它们的实际效果(对于thresholdType在这里选择cv.THRESH_BINARY），测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.jpg'</span>)</span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)</span><br><span class="line">ret,th1 = cv.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,\</span><br><span class="line">            cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img_gray,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,\</span><br><span class="line">            cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>, <span class="string">'Simple Thresholding'</span>,</span><br><span class="line">            <span class="string">'Adaptive Mean Thresholding'</span>, <span class="string">'Adaptive Gaussian Thresholding'</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2022/10/11/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/3.2.png" alt></p><p>发现没有像之前otsu那样输出一张类似的图片，但是，它将图像中的边框描绘了出来，实际应用中这样的方式更适合处理文字形式的图片。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-图像二值化&quot;&gt;&lt;a href=&quot;#1-图像二值化&quot; class=&quot;headerlink&quot; title=&quot;1. 图像二值化&quot;&gt;&lt;/a&gt;1. 图像二值化&lt;/h1&gt;&lt;p&gt;图像二值化就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。&lt;/p&gt;
&lt;p&gt;要得到二值化图像，首先要把图像灰度化，然后将256个亮度等级的灰度图像通过适当的阈值选取而获得仍然可以反映图像整体和局部特征的二值化图像。所有灰度大于或等于阈值的像素被判定为属于特定物体，其灰度值为255，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图像灰度化处理</title>
    <link href="http://yoursite.com/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/</id>
    <published>2022-10-10T12:29:56.000Z</published>
    <updated>2022-10-11T11:50:30.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-图像灰度化"><a href="#1-图像灰度化" class="headerlink" title="1. 图像灰度化"></a>1. 图像灰度化</h1><p>在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255，当灰度为255的时候，表示最亮（纯白）；当灰度为0的时候，表示最暗（纯黑）。</p><p>灰度化的好处是：相较于彩色图像灰度图像占内存更小，运行速度更快；灰度图像后可以在视觉上增加对比，突出目标区域。</p><a id="more"></a><h1 id="2-图像灰度化处理方法"><a href="#2-图像灰度化处理方法" class="headerlink" title="2. 图像灰度化处理方法"></a>2. 图像灰度化处理方法</h1><p>图像灰度化处理有三种常用方法：最大值法、平均值法和加权平均法。</p><h2 id="2-1-最大值法"><a href="#2-1-最大值法" class="headerlink" title="2.1 最大值法"></a>2.1 最大值法</h2><p>最大值法，即直接取R,B,G三个分量中数值最大的分量的数值（0视为最小，255视为最大）。公式为：R=G=B=max(R,G,B)。</p><h2 id="2-2-平均值法"><a href="#2-2-平均值法" class="headerlink" title="2.2 平均值法"></a>2.2 平均值法</h2><p>平均值法，即取R,B,G三个分量中数值的均值。公式为：R=G=B=(R+G+B)/3。</p><h2 id="2-3-加权平均法"><a href="#2-3-加权平均法" class="headerlink" title="2.3 加权平均法"></a>2.3 加权平均法</h2><p>根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度图像：</p><script type="math/tex; mode=display">Gray(i,j)=0.299*R(i,j)+0.578*G(i,j)+0.114*B(i,j)</script><h1 id="3-图像灰度化处理方法的Python实现"><a href="#3-图像灰度化处理方法的Python实现" class="headerlink" title="3. 图像灰度化处理方法的Python实现"></a>3. 图像灰度化处理方法的Python实现</h1><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">'lenna.png'</span>)</span><br><span class="line">img1 = cv.cvtColor(img, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(<span class="string">'Src_img'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.0.1.png" alt></p><h2 id="3-1-最大值法"><a href="#3-1-最大值法" class="headerlink" title="3.1 最大值法"></a>3.1 最大值法</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Max_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = max(img[i,j,<span class="number">0</span>],img[i,j,<span class="number">1</span>],img[i,j,<span class="number">2</span>]) <span class="comment"># 求3通道中最大值</span></span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'Max_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.1.1.png" alt></p><h2 id="3-2-平均值法"><a href="#3-2-平均值法" class="headerlink" title="3.2 平均值法"></a>3.2 平均值法</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Avrage_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = (int(img[i,j,<span class="number">0</span>])+int(img[i,j,<span class="number">1</span>])+int(img[i,j,<span class="number">2</span>]))/<span class="number">3</span> <span class="comment"># 求3通道像素的平均值作为灰度值</span></span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'Avrage_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.2.1.png" alt></p><h2 id="3-3-加权平均法"><a href="#3-3-加权平均法" class="headerlink" title="3.3 加权平均法"></a>3.3 加权平均法</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WeightedAvrage_Gray</span><span class="params">(srcImg_path)</span>:</span></span><br><span class="line">    img = cv.imread(srcImg_path)</span><br><span class="line">    h,w = img.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    gray = np.zeros((h,w),dtype=img.dtype) <span class="comment"># 自定义空白单通道图像，用于存放灰度图</span></span><br><span class="line">    <span class="comment"># 对原图像进行遍历，然后分别灰度化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            gray[i,j] = <span class="number">0.114</span>*int(img[i,j,<span class="number">0</span>])+<span class="number">0.578</span>*int(img[i,j,<span class="number">1</span>])+<span class="number">0.299</span>*int(img[i,j,<span class="number">2</span>])</span><br><span class="line">    gray = cv.cvtColor(gray,cv.COLOR_BGR2RGB)</span><br><span class="line">    plt.imshow(gray)</span><br><span class="line">    plt.title(<span class="string">'WeightedAvrage_Gray'</span>)</span><br><span class="line">    <span class="comment">#plt.axis('on')</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.3.1.png" alt></p><h2 id="3-4-最大值法、平均值法和加权平均法的比较"><a href="#3-4-最大值法、平均值法和加权平均法的比较" class="headerlink" title="3.4 最大值法、平均值法和加权平均法的比较"></a>3.4 最大值法、平均值法和加权平均法的比较</h2><p>综上，3种方法的灰度处理图像如下所示：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.4.png" alt></p><p>可以发现，最大值法转换的灰度图亮度最高，平均值法产生的灰度图像较暗，加权平均法得到的灰度图像明暗介于两者之间。</p><h2 id="3-5-opencv-python中灰度处理方法的应用"><a href="#3-5-opencv-python中灰度处理方法的应用" class="headerlink" title="3.5 opencv-python中灰度处理方法的应用"></a>3.5 opencv-python中灰度处理方法的应用</h2><p>opencv-python中有图像灰度处理的接口，直接调用即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">'lenna.png'</span>)</span><br><span class="line">img1 = cv.cvtColor(img, cv.COLOR_BGR2RGB) <span class="comment"># BGR转化为RGB格式</span></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img1)</span><br><span class="line">plt.title(<span class="string">'Src_img'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度转换</span></span><br><span class="line">image2 = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(image2, plt.cm.gray)</span><br><span class="line">plt.title(<span class="string">'Gray_img'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> 图像如下：</p><p><img src="/2022/10/10/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/3.5.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-图像灰度化&quot;&gt;&lt;a href=&quot;#1-图像灰度化&quot; class=&quot;headerlink&quot; title=&quot;1. 图像灰度化&quot;&gt;&lt;/a&gt;1. 图像灰度化&lt;/h1&gt;&lt;p&gt;在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255，当灰度为255的时候，表示最亮（纯白）；当灰度为0的时候，表示最暗（纯黑）。&lt;/p&gt;
&lt;p&gt;灰度化的好处是：相较于彩色图像灰度图像占内存更小，运行速度更快；灰度图像后可以在视觉上增加对比，突出目标区域。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
