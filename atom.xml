<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crossoverpptx&#39;s Blog</title>
  
  <subtitle>黑夜给了我黑色的眼睛，我却用它寻找光明</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-04-26T03:42:49.469Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>crossoverpptx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++STL：顺序容器</title>
    <link href="http://yoursite.com/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-04-26T02:35:34.000Z</published>
    <updated>2022-04-26T03:42:49.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h3><p>所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p><p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p><ul><li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li>vector&lt;T&gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li>deque&lt;T&gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li>list&lt;T&gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li>forward_list&lt;T&gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><blockquote><p>注意，其实除此之外，stack 和 queue 本质上也属于顺序容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。</p></blockquote><p>下图说明了各种顺序容器及它们之间的区别：</p><p><img src="/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/pic1.jpg" alt></p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array 容器是 C++ 11 标准中新增的顺序容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p><p>Array 容器以类模板的形式定义在 &lt;array&gt; 头文件，并位于命名空间 std 中，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>在 array&lt;T,N&gt; 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。</p><p>Array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p><p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>使用该语句，容器中所有的元素都会被初始化为 0.0。</p><p>当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="http://c.biancheng.net/c/80/" target="_blank" rel="noopener">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>另外，在 &lt;array&gt; 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>STL 为 array 容器配备了随机访问迭代器，该类迭代器是功能最强大的迭代器。在 array 容器的模板类中，和随机访问迭代器相关的成员函数如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准新增的 begin() 和 end() 函数，当操作对象为 array 容器时，也和迭代器有关，其功能分别和上表中的 begin()、end() 成员函数相同。</p><h5 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()/end() 和 cbegin()/cend()"></a>begin()/end() 和 cbegin()/cend()</h5><p>array 容器模板类中的 begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p><p>例如，可以在循环中显式地使用迭代器来初始化 values 容器的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样上使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，因为当操作对象为 array 容器时，它们和 begin()/end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>这样，容器中的一段元素可以由迭代器指定，这让我们有了对它们使用算法的可能。</p><blockquote><p>需要注意的是，STL 标准库，不是只有 array 容器，当迭代器指向容器中的一个特定元素时，它们不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，它是指向 array 容器还是指向 vector 容器。</p></blockquote><p>除此之外，array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.cend();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于 *first 为 const 类型，不能用来修改元素</span></span><br><span class="line">    <span class="comment">//*first = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="comment">//可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rbegin-rend-和-crbegin-crend"><a href="#rbegin-rend-和-crbegin-crend" class="headerlink" title="rbegin()/rend() 和 crbegin()/crend()"></a>rbegin()/rend() 和 crbegin()/crend()</h5><p>array 模板类中还提供了 rbegin()/rend() 和 crbegin()/crend() 成员函数，它们每对都可以分别得到指向最一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。</p><blockquote><p>需要注意的是，在使用反向迭代器进行 ++ 或 – 运算时，++ 指的是迭代器向左移动一位，– 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p></blockquote><p>反向迭代器用于以逆序的方式处理元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.rend();</span><br><span class="line">    <span class="comment">//初始化 values 容器为 &#123;5,4,3,2,1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新遍历容器，并输入各个元素</span></span><br><span class="line">    first = values.rbegin();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，不仅完成了容器的初始化，还遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><blockquote><p>在反向迭代器上使用 ++ 递增运算符，会让迭代器用一种和普通正向迭代器移动方向相反的方式移动。</p></blockquote><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/crend() 组合的功能唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><h5 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h5><p>首先，可以通过容器名[]的方式直接访问和使用容器中的元素，这和 C++ 标准数组访问元素的方式相同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.at (<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2.</span>O*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p><blockquote><p>可能有这样一个疑问，即为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>除此之外，array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</n></p><p>下面代码展示了如何使用 get&lt;n&gt; 模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">string</span>, 5&gt; words&#123; <span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Output words[3]</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; // 越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的指针。通过该指针，我们可以获得容器中的各个元素，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *( words.data()+<span class="number">1</span>); <span class="comment">// 输出结果：2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h5><p>我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p><p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has no elements.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has "</span>&lt;&lt; values.<span class="built_in">size</span>()&lt;&lt;<span class="string">"elements.\n"</span>;</span><br></pre></td></tr></table></figure><p>然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p><blockquote><p>array 容器之所以提供 empty() 成员函数的原因，对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p></blockquote><p>除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;顺序容器概述&quot;&gt;&lt;a href=&quot;#顺序容器概述&quot; class=&quot;headerlink&quot; title=&quot;顺序容器概述&quot;&gt;&lt;/a&gt;顺序容器概述&lt;/h3&gt;&lt;p&gt;所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数</summary>
      
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL：容器与迭代器</title>
    <link href="http://yoursite.com/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-04-25T05:23:19.000Z</published>
    <updated>2022-04-25T08:46:03.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。<a id="more"></a>STL 提供有 3 类标准容器，分别是顺序容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示：</p><table><thead><tr><th align="left">容器种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">顺序容器</td><td align="center">主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td align="left">排序容器</td><td align="center">包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td></tr><tr><td align="left">哈希容器</td><td align="center">C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是顺序容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p><p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p><p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p><p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p><h4 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h4><p>STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。其中，输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。</p><ul><li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p></li><li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p></li><li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p+=i：使得 p 往后移动 i 个元素。</span><br><span class="line">p-=i：使得 p 往前移动 i 个元素。</span><br><span class="line">p+i：返回 p 后面第 i 个元素的迭代器。</span><br><span class="line">p-i：返回 p 前面第 i 个元素的迭代器。</span><br><span class="line">p[i]：返回 p 后面第 i 个元素的引用。</span><br></pre></td></tr></table></figure><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p></li></ul><p>下表所示，是 C++ 11 标准中不同容器指定使用的迭代器类型。</p><table><thead><tr><th align="left">容器</th><th align="left">对应的迭代器类型</th></tr></thead><tbody><tr><td align="left">array</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">vector</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">deque</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">list</td><td align="left">双向迭代器</td></tr><tr><td align="left">set / multiset</td><td align="left">双向迭代器</td></tr><tr><td align="left">map / multimap</td><td align="left">双向迭代器</td></tr><tr><td align="left">forward_list</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_map / unordered_multimap</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_set / unordered_multiset</td><td align="left">前向迭代器</td></tr><tr><td align="left">stack</td><td align="left">不支持迭代器</td></tr><tr><td align="left">queue</td><td align="left">不支持迭代器</td></tr></tbody></table><p>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h4><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如下表所示。</p><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator  迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator  迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator  迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator  迭代器名;</td></tr></tbody></table><p>值得一提的是，上表中的反向迭代器全称为 “反向迭代器适配器”。</p><p>通过定义以上几种迭代器，就可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</p><p>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p><h4 id="迭代器实例"><a href="#迭代器实例" class="headerlink" title="迭代器实例"></a>迭代器实例</h4><p>以上对迭代器做了很详细的介绍，下面就以 vector 容器为例，实际感受迭代器的用法和功能。通过前面的学习，vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;; <span class="comment">// v被初始化成有10个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个正向迭代器，当然，vector 也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第二种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第三种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第四种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        i += <span class="number">1</span>; <span class="comment">// 随机访问迭代器支持 "+= 整数" 的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第二种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第三种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第四种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>再举一个例子，我们知道，list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法，因为双向迭代器不支持用“&lt;”进行比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><p>其实在 C++ 中，数组也是容器，数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h3&gt;&lt;p&gt;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="http://yoursite.com/2022/04/25/C-STL/"/>
    <id>http://yoursite.com/2022/04/25/C-STL/</id>
    <published>2022-04-25T04:37:18.000Z</published>
    <updated>2022-04-25T05:18:04.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-STL"><a href="#什么是-STL" class="headerlink" title="什么是 STL"></a>什么是 STL</h3><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 <a id="more"></a></p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 标准库的重要组成部分。如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装。STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等。</p><h3 id="STL-的组成"><a href="#STL-的组成" class="headerlink" title="STL 的组成"></a>STL 的组成</h3><p>通常认为，STL 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的，如表 1 STL 组成结构：</p><table><thead><tr><th align="left">STL的组成</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">容器</td><td align="center">一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td></tr><tr><td align="left">算法</td><td align="center">STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 algorithm 中，少部分位于头文件 numeric 中。</td></tr><tr><td align="left">迭代器</td><td align="center">在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td></tr><tr><td align="left">函数对象</td><td align="center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td></tr><tr><td align="left">适配器</td><td align="center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td></tr><tr><td align="left">内存分配器</td><td align="center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td></tr></tbody></table><p>另外，在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++ 标准中，它们被重新组织为 13 个头文件，分别是：iterator、functional、vector、deque、list、queue、stack、set、map、algorithm、numeric、memory和utility。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是-STL&quot;&gt;&lt;a href=&quot;#什么是-STL&quot; class=&quot;headerlink&quot; title=&quot;什么是 STL&quot;&gt;&lt;/a&gt;什么是 STL&lt;/h3&gt;&lt;p&gt;STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。&lt;/p&gt;</summary>
    
    
    
    <category term="C++STL" scheme="http://yoursite.com/categories/C-STL/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++:引用计数</title>
    <link href="http://yoursite.com/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</id>
    <published>2022-01-11T09:43:43.000Z</published>
    <updated>2022-01-11T11:44:23.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是引用计数"><a href="#什么是引用计数" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h3><p>引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：</p><ul><li><p>简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。</p></li><li><p>节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中<strong>string</strong>类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。<a id="more"></a></p></li></ul><h3 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h3><p>使用引用计数实现智能指针的关键是，引用计数应该存在哪里。引用计数应该是某个类对象和其复制对象共享的， 而指针成员恰好有这样的特性， 故可以在类中多声明一个size_t* 的成员，用来表示引用计数。</p><ul><li>构造函数中创建类的新对象时，初始化引用计数为1；</li><li>拷贝构造函数复制指针，并使相应的引用计数增加1；</li><li>赋值操作减少左操作数所指对象的引用计数，增加右操作数所指对象的引用计数；</li><li>析构函数使引用计数减少1，并且当引用计数为1时，释放指针所指向的对象；</li></ul><p><img src="/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/1.png" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>; <span class="keyword">using</span> <span class="built_in">std</span>::ostream; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// string()：构造空的string类对象，既空字符串</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125; <span class="comment">// constructor</span></span><br><span class="line">~HasPtr(); <span class="comment">// 析构函数</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> HasPtr&amp; rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++* use; &#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;); <span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span>* ps; <span class="comment">// ps是一个指针，指向string类型</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span>* use; <span class="comment">// use是一个指针，指向size_t类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数的定义</span></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 如果引用计数为变0</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 释放string内存</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放计数器内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载的定义</span></span><br><span class="line">HasPtr&amp;</span><br><span class="line">HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">++* rhs.use;<span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 如果没有其他用户</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">&#125;</span><br><span class="line">ps = rhs.ps;<span class="comment">// 将数据从rhs拷贝到本对象</span></span><br><span class="line">i = rhs.i;</span><br><span class="line">use = rhs.use;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的定义</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">os &lt;&lt; p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.use;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HasPtr temp;</span><br><span class="line">temp = p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, p) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"temp: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, temp) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr str1(\"copy me\"), str2;\n"</span>;</span><br><span class="line">HasPtr str1("copy me"), str2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr2 = str1;\n"</span>;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nfunc(str1);\n"</span>;</span><br><span class="line">func(str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HasPtr str1(<span class="string">"copy me"</span>), str2;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">1</span></span><br><span class="line">str2: <span class="number">011654E8</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">str2 = str1;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line"></span><br><span class="line">func(str1);</span><br><span class="line">p: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line">temp: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line"></span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是引用计数&quot;&gt;&lt;a href=&quot;#什么是引用计数&quot; class=&quot;headerlink&quot; title=&quot;什么是引用计数&quot;&gt;&lt;/a&gt;什么是引用计数&lt;/h3&gt;&lt;p&gt;引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中&lt;strong&gt;string&lt;/strong&gt;类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>python+selenium实现自动刷新网页</title>
    <link href="http://yoursite.com/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/</id>
    <published>2022-01-06T09:03:52.000Z</published>
    <updated>2022-04-08T04:59:21.671Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。</strong></p><a id="more"></a><hr><p>一、安装 selenium</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>二、下载并导入浏览器驱动</p><p>1、查看Chrome浏览器版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://version</span><br></pre></td></tr></table></figure><p>2、根据版本下载对应浏览器驱动</p><p>下载网址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>3、将下载的驱动放入python安装目录Scripts文件夹下。</p><p>三、示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    driver.refresh()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>《信》-东野圭吾</title>
    <link href="http://yoursite.com/2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    <id>http://yoursite.com/2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/</id>
    <published>2022-01-04T02:07:59.000Z</published>
    <updated>2022-04-08T03:54:08.580Z</updated>
    
    <content type="html"><![CDATA[<p>看完了东野圭吾的《信》，这不是一部推理题材的小说，只是讲述了一个关于人性的故事。故事围绕“犯罪者的家属该不该受到歧视”展开，主人公的哥哥犯下了盗窃杀人罪，留下他独自一人，没有钱上大学只能去打工，却在被老板知道自己的哥哥是罪犯后遭遇辞退，一次次想隐瞒却又终究暴露，连自己的女朋友也因此分手，好不容易结婚生了孩子，竟连孩子也要饱受歧视。于是，他的心理也在这一件件事中发生改变，甚至扭曲，终于无法忍受，写信告诉自己的哥哥要断绝关系，不再相见……<a id="more"></a></p><p>以前，我只觉得犯罪者的家属因犯罪者而受到歧视似乎有失公允，至少不能一概而论，但大家的做法也无可厚非，因为没有人愿意跟犯罪扯上关系。现在看来，这里面还有一层含义，那就是这些家属所受的歧视其实也是犯罪成本的一部分，以此来警告那些试图犯罪者，犯罪的结果不只牵涉本人，也会给亲人带来麻烦。可是，我又有了一个疑问。犯罪者在犯罪时可能会想到这么多吗？即使像这篇小说中，主人公的哥哥是为了替他凑够上大学的学费才去盗窃，也不是一开始就计划杀人，他也没能想到由此可能带给弟弟的痛苦，更不必说那些穷凶极恶之徒了。所以，这种警告跟欲犯罪者自身素养和对犯罪后果的了解有很大关系，但总的来说，这并不是一件可以讨论谁对谁错的事。</p><p>至于主人公，让我想起了一部电视剧《琅琊榜：风起长林》中的反派人物萧元启。他作为犯罪者的儿子，遭遇了人间冷暖，世态炎凉，本来是一个可怜之人，却最终一步步跌入仇恨的深渊。在他完全黑化前，与长林老王爷的一段对话让我记忆犹新，这也是曾经可能挽救他的良药。</p><blockquote><p>萧元启：境遇冷暖，自然会影响人的性情。性情若是变了，本心会变吗？</p><p>老王爷：如果你觉得这世态炎凉，那是因为你还没有经历过真正的地狱，一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p></blockquote><p>但萧元启终究没能找回他的赤子之心。现实中也是如此，一个人无疑是容易被周遭环境所影响的，特别是在如今的社会，复杂的人际关系，各种各样的诱惑，我们也许在不知不觉中就已经走在背离本心的路上，或是在某些情况下，我们不得不做出违背初心的行为，所以，我们应该时常问问自己是否还坚持着初心，这也许很难，但应该坚守。若是真的做出了违背初心的事，是否就一定会堕入深渊呢？也许会，也许不会。人世间的很多事很难得出对与错的结论，毕竟我们中的大多数都是普通人，我们常常站在道德的制高点趾高气昂，评头论足，却没有深入探究事件本身的勇气与能力。那么，我们究竟应该怎么做呢？还是那句话：一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看完了东野圭吾的《信》，这不是一部推理题材的小说，只是讲述了一个关于人性的故事。故事围绕“犯罪者的家属该不该受到歧视”展开，主人公的哥哥犯下了盗窃杀人罪，留下他独自一人，没有钱上大学只能去打工，却在被老板知道自己的哥哥是罪犯后遭遇辞退，一次次想隐瞒却又终究暴露，连自己的女朋友也因此分手，好不容易结婚生了孩子，竟连孩子也要饱受歧视。于是，他的心理也在这一件件事中发生改变，甚至扭曲，终于无法忍受，写信告诉自己的哥哥要断绝关系，不再相见……&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>文件重定向</title>
    <link href="http://yoursite.com/2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2021-12-26T10:09:20.000Z</published>
    <updated>2021-12-26T10:25:27.922Z</updated>
    
    <content type="html"><![CDATA[<p>当测试程序时，反复从键盘敲入测试数据作为程序的输入，是非常乏味且低效的。<a id="more"></a>大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与文件命名关联起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure><p>假定$是操作系统提示符，程序已经编译为名为addItems.exe的可执行文件（在UNIX操作系统中是addItems），则上述命令会从一个名为infile的文件读取数据，并将结果写入到一个名为outfile的文件中，两个文件都处于当前目录中。</p><p>以在Windows下为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\C++Primer\Debug&gt;<span class="string">"C++Primer.exe"</span> &lt;infile.txt&gt;outfile.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当测试程序时，反复从键盘敲入测试数据作为程序的输入，是非常乏味且低效的。&lt;/p&gt;</summary>
    
    
    
    <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>我的研究生之旅</title>
    <link href="http://yoursite.com/2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/</id>
    <published>2021-12-19T03:33:22.000Z</published>
    <updated>2022-04-08T02:56:40.776Z</updated>
    
    <content type="html"><![CDATA[<p>应该是三月吧，时间记不清了，初试成绩出来的那一刻我觉得应该进不了复试了。<a id="more"></a>又逢家中的一些变故，那时只想离开家，所以我骗家人不想调剂，决定出去找工作，其实我的内心是想调剂的。</p><p>离开家，回到曾经工作的地方一直准备调剂，却又感觉希望渺茫，心想实在调剂不上就继续工作吧。调剂系统出来的第一天，由于没有调剂经验，很快填完了3个名额，填的学校都是比较好的学校，导致填完就没有了下文，最多就是被查看，一直没有复试通知。错过了前期的黄金调剂期，后面调剂越来越难，幸运的是，在最后时刻终于被录取了，虽然是一所很一般的学校。心是有不甘，但这已经是比较好的结局。</p><p>九月入学，第一次来到东北，有些陌生，有些新鲜。很快适应了大学生活，就像我只是放假后又重新回到学校，不过还是有了很多不一样的感受。再一次在秋天凉爽的夜晚漫步在学校的马路操场上，看着熙熙攘攘的学生，踩着滑板，唱着歌，一幅幅青春的模样，一年前的我怎么也不会想到今天的自己又回到了校园，以一个学生的身份。没错，我又回到了校园，没有生活的琐碎，工作的烦恼，只有无忧无虑的学习、生活和娱乐，可以有大量的时间做自己想做的事，我感到无比幸运，因为就连这样的散步都是工作后奢侈的享受。我又走进了图书馆，去阶梯教室上课，去食堂吃饭，睡四人寝……每一件事都是熟悉的样子，恍如昨日，这些曾经离开校园后最美好的回忆，我正在体验着，也更加珍惜，果然人总是在失去后才会懂得拥有的珍贵。</p><p>一学期的学习生活很快结束，考试周的考试也结束了，又松了口气，可以继续做自己想做的事，看自己喜欢的书，马上就可以放假飞到想去的城市见见许久未见的老友。生活很平淡，有时甚至很艰难，可是总有什么是我们期待的，总有什么是值得我们期待的，不知不觉中，我们都在朝着更好的方向努力，明天的生活不知道会怎样，可是我们要珍惜现在的我们和现在的时光。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;应该是三月吧，时间记不清了，初试成绩出来的那一刻我觉得应该进不了复试了。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>追赶法求解线性方程组</title>
    <link href="http://yoursite.com/2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2021-10-12T12:58:49.000Z</published>
    <updated>2022-04-08T04:35:17.308Z</updated>
    
    <content type="html"><![CDATA[<p><strong>利用追赶法求解线性方程组，基于C语言实现。</strong></p><p><strong>追赶法是LU分解法的一种特例，其系数矩阵是一种稀疏矩阵，除主对角线及相邻的两条对角线为非零元素，其余元素值均为0，称为三对角矩阵。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> c[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> d[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>, i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]/b[i<span class="number">-1</span>];</span><br><span class="line">        b[i]=b[i]-c[i<span class="number">-1</span>]*a[i];</span><br><span class="line">        d[i]=d[i]-a[i]*d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    d[n]=d[n]/b[n];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=(d[i]-c[i]*d[i+<span class="number">1</span>])/b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.100000</span></span><br><span class="line"><span class="number">2.200000</span></span><br><span class="line"><span class="number">2.300000</span></span><br><span class="line"><span class="number">2.400000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;利用追赶法求解线性方程组，基于C语言实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;追赶法是LU分解法的一种特例，其系数矩阵是一种稀疏矩阵，除主对角线及相邻的两条对角线为非零元素，其余元素值均为0，称为三对角矩阵。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数值分析" scheme="http://yoursite.com/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="数值分析" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>LU分解法求解线性方程组</title>
    <link href="http://yoursite.com/2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://yoursite.com/2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2021-10-11T07:27:13.000Z</published>
    <updated>2022-04-08T04:33:39.223Z</updated>
    
    <content type="html"><![CDATA[<p><strong>利用LU分解法求解线性方程组，基于C++语言实现。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵的ALU分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALU</span><span class="params">(<span class="keyword">double</span> a[n][n], <span class="keyword">double</span> b[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> u[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行U的第一行的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[<span class="number">0</span>][i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行L的第一列的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i][<span class="number">0</span>] = a[i][<span class="number">0</span>] / u[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算U的剩下的行数和L的剩下的列数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 计算U的行</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum1 += l[i][k] * u[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            u[i][j] = a[i][j] - sum1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算L的列</span></span><br><span class="line">        <span class="keyword">if</span>(i!=n)</span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2 += l[j][k] * u[k][i];</span><br><span class="line">&#125;</span><br><span class="line">l[j][i] = (a[j][i] - sum2) / u[i][i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出L和U</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵L为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵U为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求y</span></span><br><span class="line">    <span class="keyword">double</span> y[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    y[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            sum3 += l[i][j] * y[j];</span><br><span class="line">        y[i] = b[i] - sum3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求x</span></span><br><span class="line">    <span class="keyword">double</span> x[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    x[n - <span class="number">1</span>] = y[n - <span class="number">1</span>] / u[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            sum4 += u[i][j] * x[j];</span><br><span class="line">        x[i] = (y[i] - sum4) / u[i][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"该线性方程组的解为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x["</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"]="</span> &lt;&lt; x[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[<span class="number">3</span>] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    ALU(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">矩阵L为：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">-0.333333</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0.333333</span> <span class="number">-0.357143</span> <span class="number">0</span></span><br><span class="line">矩阵U为：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">4.66667</span> <span class="number">4.66667</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">x[<span class="number">1</span>]=<span class="number">0.5</span></span><br><span class="line">x[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">x[<span class="number">3</span>]=<span class="number">0.5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;利用LU分解法求解线性方程组，基于C++语言实现。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数值分析" scheme="http://yoursite.com/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="数值分析" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>高斯消去法求解线性方程组</title>
    <link href="http://yoursite.com/2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://yoursite.com/2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2021-09-28T12:18:11.000Z</published>
    <updated>2022-04-08T04:34:34.809Z</updated>
    
    <content type="html"><![CDATA[<p><strong>利用高斯消去法求解线性方程组，基于C语言实现。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A[MAX][MAX];</span><br><span class="line"><span class="keyword">double</span> b[MAX];</span><br><span class="line"><span class="keyword">double</span> X[MAX];</span><br><span class="line"><span class="keyword">int</span> NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的阶数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;NUM);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的第%d行元素:"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=NUM; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;A[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入右端项b:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的系数矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">float</span> mik;<span class="comment">//消元过程所用变量</span></span><br><span class="line">    <span class="keyword">float</span> S;<span class="comment">//回代过程所用变量</span></span><br><span class="line"></span><br><span class="line">    inputMatrix();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消元</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;NUM<span class="number">-1</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!A[k][k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">1</span>; i&lt;NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mik=A[i][k]/A[k][k];</span><br><span class="line">b[i]=b[i]-mik*b[k];</span><br><span class="line">            <span class="keyword">for</span>(j=k; j&lt;NUM; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j]=A[i][j]-mik*A[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回代</span></span><br><span class="line">    X[NUM<span class="number">-1</span>]=b[NUM<span class="number">-1</span>]/A[NUM<span class="number">-1</span>][NUM<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(k=NUM<span class="number">-2</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        S=b[k];</span><br><span class="line">        <span class="keyword">for</span>(j=k+<span class="number">1</span>; j&lt;NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            S=S-A[k][j]*X[j];</span><br><span class="line">        &#125;</span><br><span class="line">        X[k]=S/A[k][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该线性方程组的解为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"X%d=%lf\n"</span>,i+<span class="number">1</span>,X[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入系数矩阵A的阶数:<span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">1</span>行元素:<span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">输入系数矩阵A的第<span class="number">2</span>行元素:<span class="number">12</span> <span class="number">-3</span> <span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">3</span>行元素:<span class="number">-18</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line">输入右端项b:<span class="number">6</span> <span class="number">15</span> <span class="number">-15</span></span><br><span class="line"></span><br><span class="line">输入的系数矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">12.000000</span> <span class="number">-3.000000</span> <span class="number">3.000000</span></span><br><span class="line"><span class="number">-18.000000</span> <span class="number">3.000000</span> <span class="number">-1.000000</span></span><br><span class="line">输入的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">15.000000</span></span><br><span class="line"><span class="number">-15.000000</span></span><br><span class="line"></span><br><span class="line">消元后的矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">-15.000000</span> <span class="number">-9.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">4.400000</span></span><br><span class="line">消元后的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">-57.000000</span></span><br><span class="line"><span class="number">13.200001</span></span><br><span class="line"></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">X1=<span class="number">1.000000</span></span><br><span class="line">X2=<span class="number">2.000000</span></span><br><span class="line">X3=<span class="number">3.000000</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;利用高斯消去法求解线性方程组，基于C语言实现。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数值分析" scheme="http://yoursite.com/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="数值分析" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>void*的用法</title>
    <link href="http://yoursite.com/2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-08-22T09:27:08.000Z</published>
    <updated>2022-04-08T02:40:54.869Z</updated>
    
    <content type="html"><![CDATA[<p><strong>void*是一种特殊的指针类型，可用于存放任意对象的地址。</strong></p><a id="more"></a><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, * pd = &amp;obj;</span><br><span class="line"><span class="keyword">void</span>* pv = pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*pd 的值为："</span> &lt;&lt; *pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "*pv 的值为：" &lt;&lt; *pv &lt;&lt; endl; // 错误，不能直接操作 void* 所指的对象，因为我们并不知道这个对象到底是什么类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pd 的值为：<span class="number">3.14</span></span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;void*是一种特殊的指针类型，可用于存放任意对象的地址。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>海街日记</title>
    <link href="http://yoursite.com/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/</id>
    <published>2021-03-20T04:17:47.000Z</published>
    <updated>2022-04-08T02:30:57.114Z</updated>
    
    <content type="html"><![CDATA[<p>“虽然知道自己马上就要死了，但是依然能感受到美丽的东西是美的，很开心。”</p><p>电影开头铃的父亲和电影结尾二宫女士的去世，告诉我们无尽温柔的人也无法抵挡死亡；海上的烟花会和盛开的樱花，在绽放后转瞬消逝……这些无一不蕴含对美好易逝的感叹。</p><p>但这部电影的主题却不是宣扬悲观，而是在告诉人们，死亡和失去并不可怕，重要的是珍惜身边的人，珍惜现在，好好生活。</p><p><img src="/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“虽然知道自己马上就要死了，但是依然能感受到美丽的东西是美的，很开心。”&lt;/p&gt;
&lt;p&gt;电影开头铃的父亲和电影结尾二宫女士的去世，告诉我们无尽温柔的人也无法抵挡死亡；海上的烟花会和盛开的樱花，在绽放后转瞬消逝……这些无一不蕴含对美好易逝的感叹。&lt;/p&gt;
&lt;p&gt;但这部电影的主</summary>
      
    
    
    
    <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现及应用-改进1</title>
    <link href="http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/"/>
    <id>http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/</id>
    <published>2021-02-23T06:39:32.000Z</published>
    <updated>2021-12-30T05:48:01.624Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <a href="https://crossoverpptx.github.io/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener"><strong>二叉树的实现及应用</strong></a> 的改进，源程序被拆分为四个子程序：Status.h（状态码头文件）、BiTree.h（二叉树数据结构及函数声明头文件）、BiTree.c（函数定义）、BiTree-main.c（主程序）。</p><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Status.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STATUS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OVERFLOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW    -2  <span class="comment">//堆栈上溢</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BITREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树元素类型定义，这里假设其元素类型为char */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树结点定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    TElemType data;             <span class="comment">// 结点元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>;</span>     <span class="comment">// 左孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">rchild</span>;</span>     <span class="comment">// 右孩子指针</span></span><br><span class="line">&#125; BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向二叉树结点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BiTNode* BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************声明部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span>;<span class="comment">//初始化，构造空二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span>;<span class="comment">//若二叉树T为空，则返回TRUE，否则FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span>;<span class="comment">//返回二叉树T的深度</span></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span>;<span class="comment">//返回T的根</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span>;<span class="comment">//按先序输入二叉树中结点的值（一个字符），‘#’字符表示空树</span></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span>;<span class="comment">//对数据元素操作的应用函数</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//先序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//中序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//后序递归遍历二叉树T的递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************函数部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        L = BiTreeDepth(T-&gt;lchild);</span><br><span class="line">        R = BiTreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span>(L &gt; R ? L:R)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span>(!(*T))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\t"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">            <span class="keyword">if</span>(PreOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(PreOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(InOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                <span class="keyword">if</span>(InOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PostOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(PostOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree-main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InitBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始化空二叉树 T。\n"</span>);</span><br><span class="line">        InitBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"CreateBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"按先序序列创建二叉树 T："</span>);</span><br><span class="line">        CreateBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PreOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树 T："</span>);</span><br><span class="line">        PreOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nInOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树 T："</span>);</span><br><span class="line">        InOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nPostOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树 T："</span>);</span><br><span class="line">        PostOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitBiTree</span><br><span class="line">初始化空二叉树 T。</span><br><span class="line">CreateBiTree</span><br><span class="line">按先序序列创建二叉树 T：ABD<span class="comment">###C#F##</span></span><br><span class="line">PreOrderTraverse</span><br><span class="line">前序遍历二叉树 T：A     B       D       C       F</span><br><span class="line">InOrderTraverse</span><br><span class="line">中序遍历二叉树 T：D     B       A       C       F</span><br><span class="line">PostOrderTraverse</span><br><span class="line">后序遍历二叉树 T：D     B       F       C       A</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对 &lt;a href=&quot;https://crossoverpptx.github.io/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;二叉树的实现及应用&lt;/strong&gt;&lt;/a&gt; 的改进，源程序被拆分为四个子程序：Status.h（状态码头文件）、BiTree.h（二叉树数据结构及函数声明头文件）、BiTree.c（函数定义）、BiTree-main.c（主程序）。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现及应用</title>
    <link href="http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-23T05:45:32.000Z</published>
    <updated>2021-02-24T03:49:50.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录二叉树的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>)&#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraversal (T-&gt;lchild);</span><br><span class="line">        PreOrderTraversal (T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InOrderTraversal( T-&gt;lchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        InOrderTraversal( T-&gt;rchild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        PostOrderTraversal( T-&gt;lchild );</span><br><span class="line">        PostOrderTraversal( T-&gt;rchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create  Binary Tree:"</span>);</span><br><span class="line">CreatBiTree(&amp;T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PreOrder:"</span>);</span><br><span class="line">PreOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InOrder:"</span>);</span><br><span class="line">InOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PostOrder:"</span>);</span><br><span class="line">PostOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Create  Binary Tree:ABD<span class="comment">###C#F##</span></span><br><span class="line"></span><br><span class="line">PreOrder:ABDCF</span><br><span class="line"></span><br><span class="line">InOrder:DBACF</span><br><span class="line"></span><br><span class="line">PostOrder:DBFCA</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录二叉树的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>顺序串的实现及应用</title>
    <link href="http://yoursite.com/2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-18T10:42:14.000Z</published>
    <updated>2021-02-24T04:17:58.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录顺序串的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SString.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 10                                 <span class="comment">// 顺序串的最大串长</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串的顺序存储类型定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN + <span class="number">1</span>];         <span class="comment">// 0号单元存放串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span></span>;       <span class="comment">//构造一个值为chars的串T</span></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span></span>;  <span class="comment">//用T返回由S1和S2联结而成的新串。若未截断，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span></span>;                      <span class="comment">// 测试函数，打印字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, len;</span><br><span class="line">    </span><br><span class="line">    len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(chars);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// chars过长</span></span><br><span class="line">    <span class="keyword">if</span>(len &gt; MAXSTRLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T[<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        T[i] = chars[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> uncut;  <span class="comment">// 新串是否完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完全不需要裁剪</span></span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>] + S2[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制S2到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>] + S2[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 未裁剪，完整</span></span><br><span class="line">        uncut = TRUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要裁剪S2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(S1[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将S2的一部分复制到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只需要复制S1的一部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连同长度信息一起复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> uncut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"████████ Concat \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        SString Tmp1, Tmp2, Tmp3, Tmp4, S1, S2, S3, S4, S5, S6, S7, S8;</span><br><span class="line">        </span><br><span class="line">        StrAssign(S1, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S2, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S1和S2形成 Tmp1 ...\n"</span>);</span><br><span class="line">        Concat(Tmp1, S1, S2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp1 = "</span>);</span><br><span class="line">        PrintElem(Tmp1);</span><br><span class="line"></span><br><span class="line">StrAssign(S3, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S4, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S3和S4形成 Tmp2 ...\n"</span>);</span><br><span class="line">        Concat(Tmp2, S3, S4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp2 = "</span>);</span><br><span class="line">        PrintElem(Tmp2);</span><br><span class="line"></span><br><span class="line">StrAssign(S5, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S6, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S5和S6形成 Tmp3 ...\n"</span>);</span><br><span class="line">        Concat(Tmp3, S5, S6);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp3 = "</span>);</span><br><span class="line">        PrintElem(Tmp3);</span><br><span class="line"></span><br><span class="line">StrAssign(S7, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S8, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S7和S8形成 Tmp4 ...\n"</span>);</span><br><span class="line">        Concat(Tmp4, S7, S8);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp4 = "</span>);</span><br><span class="line">        PrintElem(Tmp4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">████████ Concat</span><br><span class="line">█ 联接S1和S2形成 Tmp1 ...</span><br><span class="line">█ Tmp1 = +++++-----</span><br><span class="line">█ 联接S3和S4形成 Tmp2 ...</span><br><span class="line">█ Tmp2 = +++++++---</span><br><span class="line">█ 联接S5和S6形成 Tmp3 ...</span><br><span class="line">█ Tmp3 = +++++-----</span><br><span class="line">█ 联接S7和S8形成 Tmp4 ...</span><br><span class="line">█ Tmp4 = +++++++---</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录顺序串的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈的实现及应用</title>
    <link href="http://yoursite.com/2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-10T09:32:28.000Z</published>
    <updated>2021-02-24T04:18:29.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录顺序栈的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">SElemType *base;</span><br><span class="line">SElemType *top;</span><br><span class="line"><span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空栈S</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">S.top=S.base;</span><br><span class="line">S.stacksize=STACK_INIT_SIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈S，栈S不再存在</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(S.base);</span><br><span class="line">S.base=<span class="literal">NULL</span>;</span><br><span class="line">S.top=<span class="literal">NULL</span>;</span><br><span class="line">S.stacksize=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈S置为空栈</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.top=S.base;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈S为空栈，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈S的元素个数，即栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S.top-S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈不空，则用e返回S的栈顶元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top&gt;S.base)</span><br><span class="line">&#123;</span><br><span class="line">e=*(S.top<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈：插入元素e作为新的栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)</span><br><span class="line">&#123;</span><br><span class="line">S.base=(SElemType *)<span class="built_in">realloc</span>(S.base,</span><br><span class="line">(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">S.top=S.base+S.stacksize;</span><br><span class="line">S.stacksize+=STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++=e;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈：若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">e=*--S.top;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.1：10进制转化为8进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conversion_3_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack s;</span><br><span class="line"><span class="keyword">unsigned</span> n;</span><br><span class="line">SElemType e;</span><br><span class="line"></span><br><span class="line">InitStack(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入一个非负10进制整数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">Push(s,n%<span class="number">8</span>);</span><br><span class="line">n/=<span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"与其等值的8进制数为："</span>);</span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(s))</span><br><span class="line">&#123;</span><br><span class="line">Pop(s,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.2：括号匹配</span></span><br><span class="line"><span class="function">Status <span class="title">Conversion_3_2</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack s;</span><br><span class="line">SElemType e;</span><br><span class="line"></span><br><span class="line">InitStack(s);</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p=str;*p;++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">'('</span> || *p==<span class="string">'['</span> || *p==<span class="string">'&#123;'</span>)</span><br><span class="line">Push(s,*p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">')'</span> || *p==<span class="string">']'</span> || *p==<span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(s))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Pop(s,e);</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">')'</span> &amp;&amp; e!=<span class="string">'('</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">']'</span> &amp;&amp; e!=<span class="string">'['</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">'&#125;'</span> &amp;&amp; e!=<span class="string">'&#123;'</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!StackEmpty(s))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"算法3.1：\n"</span>);</span><br><span class="line">Conversion_3_1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"算法3.2：\n"</span>);</span><br><span class="line"><span class="keyword">char</span> str[]=<span class="string">"(((1+b)-(a+3)))&#123;12[&#125;[]*4@]"</span>;</span><br><span class="line"><span class="keyword">if</span>(Conversion_3_2(str))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"括号匹配！\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"括号不匹配！\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法<span class="number">3.1</span>：</span><br><span class="line">输入一个非负<span class="number">10</span>进制整数：<span class="number">1348</span></span><br><span class="line">与其等值的<span class="number">8</span>进制数为：<span class="number">2504</span></span><br><span class="line">算法<span class="number">3.2</span>：</span><br><span class="line">括号不匹配！</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录顺序栈的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现，其中应用了少数C++特性，比如引用等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链队列的实现及应用</title>
    <link href="http://yoursite.com/2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-02-10T03:59:41.000Z</published>
    <updated>2021-02-24T04:09:46.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>本文记录单链队列（队列的链式存储结构）的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q.front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Q.front)</span><br><span class="line">&#123;</span><br><span class="line">Q.rear=Q.front-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(Q.front);</span><br><span class="line">Q.front=Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Q清为空队列</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">q=p;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列Q为空队列，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Q的元素个数，即队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line"><span class="keyword">while</span>(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则用e返回Q的队头元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e作为新的队尾元素</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next=p;</span><br><span class="line">Q.rear=p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">Q.rear=Q.front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit失败，则操作失败</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q,<span class="keyword">void</span> (*visit)(QElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(QElemType i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">QElemType d;</span><br><span class="line">LinkQueue q;</span><br><span class="line">i=InitQueue(q);</span><br><span class="line"><span class="keyword">if</span>(i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"成功地构造了一个空队列！\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"初始化队列后，队列空否？%d(1：空 0：否)，"</span>,QueueEmpty(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line">EnQueue(q,<span class="number">-5</span>);</span><br><span class="line">EnQueue(q,<span class="number">5</span>);</span><br><span class="line">EnQueue(q,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入3个元素（-5,5,10）后，队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在队列空否？%d(1：空 0：否)\n"</span>,QueueEmpty(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在队列中的元素为："</span>);</span><br><span class="line">QueueTraverse(q,visit);</span><br><span class="line">i=GetHead(q,d);</span><br><span class="line"><span class="keyword">if</span>(i==OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队头元素为：%d\n"</span>,d);</span><br><span class="line">DeQueue(q,d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除了队头元素：%d\n"</span>,d);</span><br><span class="line">i=GetHead(q,d);</span><br><span class="line"><span class="keyword">if</span>(i==OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"新的队头元素为：%d\n"</span>,d);</span><br><span class="line">ClearQueue(q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"清空队列后，q.front=%u q.rear=%u q.front-&gt;next=%u\n"</span>,q.front,q.rear,q.front-&gt;next);</span><br><span class="line">DestroyQueue(q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"销毁队列后，q.front=%u q.rear=%u\n"</span>,q.front,q.rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">成功地构造了一个空队列！</span><br><span class="line">初始化队列后，队列空否？<span class="number">1</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)，队列长度为：<span class="number">0</span></span><br><span class="line">插入<span class="number">3</span>个元素（<span class="number">-5</span>,<span class="number">5</span>,<span class="number">10</span>）后，队列长度为：<span class="number">3</span></span><br><span class="line">现在队列空否？<span class="number">0</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)</span><br><span class="line">现在队列中的元素为：<span class="number">-5</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line">队头元素为：<span class="number">-5</span></span><br><span class="line">删除了队头元素：<span class="number">-5</span></span><br><span class="line">新的队头元素为：<span class="number">5</span></span><br><span class="line">清空队列后，q.front=10555928 q.rear=10555928 q.front-&gt;next=0</span><br><span class="line">销毁队列后，q.front=<span class="number">0</span> q.rear=<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文记录单链队列（队列的链式存储结构）的数据结构定义及基本操作的算法描述，并对算法进行简单应用。&lt;/li&gt;
&lt;li&gt;采用C语言实现，其中应用了少数C++特性，比如引用等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>论持久战</title>
    <link href="http://yoursite.com/2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/"/>
    <id>http://yoursite.com/2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/</id>
    <published>2021-01-16T04:41:35.000Z</published>
    <updated>2021-02-24T04:21:46.913Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193805b.htm" target="_blank" rel="noopener"><strong>在线阅读网址一</strong></a><br><a href="http://chinatide.net/xiachao/3-2.html" target="_blank" rel="noopener"><strong>在线阅读网址二</strong></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193805b.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;在线阅读网址一&lt;/</summary>
      
    
    
    
    <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Rsync简介</title>
    <link href="http://yoursite.com/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/</id>
    <published>2021-01-07T03:23:20.000Z</published>
    <updated>2022-04-08T02:19:47.672Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Rsync是一个远程数据同步工具，可以实现Windows系统间、Linux系统间以及Windows和Linux系统间的数据同步。</strong><br><strong>本文具体介绍Windows to Windows的使用。</strong></p><a id="more"></a><hr><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>服务端：win2008R2 64bit<br>ip：10.10.4.175<br>数据库：mysql</li><li>客户端：win2008R2 64bit<br>ip：10.10.4.75<br>数据库：mysql</li></ul><p><strong>注意：关闭防火墙，保证服务端和客户端网络相通。</strong></p><hr><h2 id="软件安装及配置"><a href="#软件安装及配置" class="headerlink" title="软件安装及配置"></a>软件安装及配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li>解压服务端软件cwRsyncServer_4.0.5_Installe.zip安装，安装过程选择默认即可。</li><li>打开cwRsyncServer安装路径C:\Program Files(x86)\ICW，其中rsyncd.conf是cwRsyncServer配置文件。修改文件内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use chroot = false</span><br><span class="line">strict modes = false</span><br><span class="line">hosts allow = <span class="number">10.10</span><span class="number">.4</span><span class="number">.75</span> <span class="comment">#限制了只允许10.10.4.75进行连接</span></span><br><span class="line">uid = <span class="number">0</span></span><br><span class="line">gid = <span class="number">0</span></span><br><span class="line">max connections = <span class="number">10</span></span><br><span class="line">strict modes = false</span><br><span class="line">log file = rsyncd.log</span><br><span class="line">lock file = rsyncd.lock</span><br><span class="line">[test] <span class="comment">#模块名称，可自定义</span></span><br><span class="line">path = /cygdrive/e/MySQL Server <span class="number">5.1</span>/data <span class="comment">#需要同步的文件目录</span></span><br><span class="line">read only = false</span><br><span class="line">transfer logging = yes</span><br><span class="line">auth users = test <span class="comment">#用户名</span></span><br><span class="line">secrets file = /cygdrive/c/Program Files (x86)/ICW/rsyncd.secrets <span class="comment">#用户和密码文件，内容为：test:111111</span></span><br><span class="line">comment = test</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：默认rsync使用873端口，自行开启windows 873端口，如果想使用其他端口自行添加port参数。</strong><br>3. 在服务中找到RsyncServer，更改成自动启动，然后确认即可。</p><p>  <img src="/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/1.png" alt></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>将客户端软件cwRsyncClient.rar解压到E盘cwRsync目录下。</li><li>在E:\cwRsync目录下创建一个密码文件password.txt，内容为111111。</li><li>在E:\cwRsync目录下创建一个bat文件rsync.bat。批处理文件内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:\cwRsync</span><br><span class="line">rsync -artzvP --delete --password-file=/cygdrive/e/cwRsync/password.txt unary@<span class="number">10.10</span><span class="number">.4</span><span class="number">.175</span>::test <span class="string">"/cygdrive/e/MySQL Server 5.1/data"</span></span><br></pre></td></tr></table></figure>bat脚本命令说明：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 客户端软件解压目录</span><br><span class="line">rsync -artzvP --delete --password-file=客户端密码文件路径 用户名@服务端ip::模块名称 客户端数据同步目录</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="执行同步"><a href="#执行同步" class="headerlink" title="执行同步"></a>执行同步</h2><p>执行rsync.bat即可执行同步任务。</p><p><img src="/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/2.png" alt></p><p>同步完成后，客户端目录下即可看到服务端同步过来的数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Rsync是一个远程数据同步工具，可以实现Windows系统间、Linux系统间以及Windows和Linux系统间的数据同步。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;本文具体介绍Windows to Windows的使用。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高可用" scheme="http://yoursite.com/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    
    <category term="高可用" scheme="http://yoursite.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
</feed>
