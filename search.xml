<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++STL：顺序容器之deque</title>
      <link href="2022/04/29/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/"/>
      <url>2022/04/29/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>deque 是 double-ended queue 的缩写，又称双端队列容器。<a id="more"></a>deque 容器和 vecotr 容器有很多相似之处，比如：</p><ul><li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</li><li>deque 容器也可以根据需要修改自身的容量和大小。</li></ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><p>deque 容器以模板类 deque&lt;T&gt;（T 为存储元素的类型）的形式在 &lt;deque&gt; 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>基于 deque 双端队列的特点，该容器包含一些 array、vector 容器都没有的成员函数。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素。</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移除一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td></tr></tbody></table><blockquote><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p></blockquote><p>和 array、vector 相同，C++ 11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2 个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><h3 id="创建deque容器的几种方式"><a href="#创建deque容器的几种方式" class="headerlink" title="创建deque容器的几种方式"></a>创建deque容器的几种方式</h3><p>创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。</p><p>1) 创建一个没有任何元素的空 deque 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br></pre></td></tr></table></figure><p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p><p>2) 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p><p>3) 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure><p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p><p>4) 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br></pre></td></tr></table></figure><p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p><p>5) 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝普通数组，创建 deque 容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于所有类型的容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(arr.<span class="built_in">begin</span>() + <span class="number">2</span>, arr.<span class="built_in">end</span>())</span></span>; <span class="comment">// 拷贝 arr 容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>deque 容器迭代器的类型为随机访问迭代器，deque 模板类提供了下表所示这些成员函数，通过调用这些函数，可以获得表示不同含义的随机访问迭代器。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 deque 容器。即当操作对象为 deque 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p><p>同样的，这些成员函数通常也是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p><blockquote><p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p></blockquote><h4 id="deque容器迭代器的基本用法"><a href="#deque容器迭代器的基本用法" class="headerlink" title="deque容器迭代器的基本用法"></a>deque容器迭代器的基本用法</h4><p>deque 容器迭代器常用来遍历容器中存储的各个元素。</p><p>begin() 和 end() 分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 deque 容器并输出其中的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 从容器首元素，遍历至最后一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.<span class="built_in">begin</span>(); i &lt; d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>前面提到，STL 还提供有全局的 begin() 和 end() 函数，当操作对象为容器时，它们的功能是上面的 begin()/end() 成员函数一样。例如，将上面程序中的第 9~11 行代码可以用如下代码替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">begin</span>(d); i &lt; <span class="built_in">end</span>(d); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行程序，会发现输出结果和上面一致。</p><p>cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = d.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = d.cend();</span><br><span class="line">    <span class="comment">// 常量迭代器不能用来修改容器中的元素值</span></span><br><span class="line">    <span class="comment">//*(first + 1) = 6; // 尝试修改容器中元素 2 的值</span></span><br><span class="line">    <span class="comment">//*(end - 1) = 10; // 尝试修改容器中元素 5 的值</span></span><br><span class="line">    <span class="comment">// 常量迭代器可以用来遍历容器、访问容器中的元素</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>程序中，由于 first 和 end 都是常量迭代器，因此第 11、12 行修改容器内元素值的操作都是非法的。</p><p>deque 模板类中还提供了 rbegin() 和 rend() 成员函数，它们分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又常称为反向迭代器。</p><blockquote><p>需要注意的是，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p></blockquote><p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.rbegin(); i &lt; d.rend(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型迭代器，不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="deque容器迭代器的使用注意事项"><a href="#deque容器迭代器的使用注意事项" class="headerlink" title="deque容器迭代器的使用注意事项"></a>deque容器迭代器的使用注意事项</h4><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p><p>例如，如下代码中注释部分是错误的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//*first = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于空的 deque 容器来说，可以通过 push_back()、push_front() 或者 resize() 成员函数实现向（空）deque 容器中添加元素。</p></blockquote><p>除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 添加元素，会导致 first 失效</span></span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中第 13 行代码，会导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。</p><blockquote><p>在对容器做添加元素的操作之后，如果仍需要使用之前以创建好的迭代器，为了保险起见，一定要重新生成。</p></blockquote><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>1) 和 array、vector 容器一样，可以采用普通数组访问存储元素的方式，访问 deque 容器中的元素，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改指定下标位置处的元素</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>容器名[n]</code>的这种方式，不仅可以访问容器中的元素，还可以对其进行修改。但需要注意的是，使用此方法需确保下标 n 的值不会超过容器中存储元素的个数，否则会发生越界访问的错误。</p><p>如果想有效地避免越界访问，可以使用 deque 模板类提供的 at() 成员函数，由于该函数会返回容器中指定位置处元素的引用形式，因此利用该函数的返回值，既可以访问指定位置处的元素，如果需要还可以对其进行修改。</p><p>不仅如此，at() 成员函数会自行判定访问位置是否越界，如果越界则抛出<code>std::out_of_range</code>异常。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    d.at(<span class="number">1</span>) = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这条语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; d.at(10) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>可能有这样一个疑问，即为什么 deque 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>2) 除此之外，deque 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用它们的返回值，可以访问（甚至修改）容器中的首尾元素。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;int&gt; d&#123; 1,2,3,4,5 &#125;;</span><br><span class="line">    cout &lt;&lt; &quot;deque 首元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;deque 尾元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 修改首元素</span><br><span class="line">    d.front() &#x3D; 10;</span><br><span class="line">    cout &lt;&lt; &quot;deque 新的首元素为：&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 修改尾元素</span><br><span class="line">    d.back() &#x3D; 20;</span><br><span class="line">    cout &lt;&lt; &quot;deque 新的尾元素为：&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque 首元素为：<span class="number">1</span></span><br><span class="line">deque 尾元素为：<span class="number">5</span></span><br><span class="line">deque 新的首元素为：<span class="number">10</span></span><br><span class="line">deque 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure><p>3) 注意，和 vector 容器不同，deque 容器没有提供 data() 成员函数，同时 deque 容器在存储元素时，也无法保证其会将元素存储在连续的内存空间中，因此尝试使用指针去访问 deque 容器中指定位置处的元素，是非常危险的。</p><p>4) 另外，结合 deque 模板类中和迭代器相关的成员函数，可以实现遍历 deque 容器中指定区域元素的方法。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 从元素 2 开始遍历</span></span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历至 5 结束（不包括 5）</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = d.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h3><p>deque 容器中，无论是添加元素还是删除元素，都只能借助 deque 模板类提供的成员函数。下表中罗列的是所有和添加或删除容器内元素相关的 deque 模板类中的成员函数。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的一个元素。</td></tr><tr><td>push_front()</td><td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部。</td></tr><tr><td>pop_front()</td><td>移除容器尾部的一个元素。</td></tr><tr><td>emplace_back()</td><td><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td></tr><tr><td>emplace_front()</td><td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程。</td></tr><tr><td>insert()</td><td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置。</td></tr><tr><td>emplace()</td><td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程。</td></tr><tr><td>erase()</td><td>移除一个元素或某一区域内的多个元素。</td></tr><tr><td>clear()</td><td>删除容器中所有的元素。</td></tr></tbody></table><blockquote><p>在实际应用中，常用 emplace()、emplace_front() 和 emplace_back() 分别代替 insert()、push_front() 和 push_back()。</p></blockquote><p>以上这些成员函数中，除了 insert() 函数的语法格式比较多，其他函数都只有一种用法（erase() 有 2 种语法格式），下面这段程序演示了它们的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="comment">// 调用push_back()向容器尾部添加数据。</span></span><br><span class="line">    d.push_back(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 调用pop_back()移除容器尾部的一个数据。</span></span><br><span class="line">    d.pop_back(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 调用push_front()向容器头部添加数据。</span></span><br><span class="line">    d.push_front(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 调用pop_front()移除容器头部的一个数据。</span></span><br><span class="line">    d.pop_front(); <span class="comment">// &#123;&#125;</span></span><br><span class="line">    <span class="comment">// 调用 emplace 系列函数，向容器中直接生成数据。</span></span><br><span class="line">    d.emplace_back(<span class="number">2</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    d.emplace_front(<span class="number">3</span>); <span class="comment">// &#123;3,2&#125;</span></span><br><span class="line">    <span class="comment">// emplace() 需要 2 个参数，第一个为指定插入位置的迭代器，第二个是插入的值。</span></span><br><span class="line">    d.emplace(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// &#123;3,4,2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// erase()可以接受一个迭代器表示要删除元素所在位置</span></span><br><span class="line">    <span class="comment">// 也可以接受 2 个迭代器，表示要删除元素所在的区域。</span></span><br><span class="line">    d.erase(d.<span class="built_in">begin</span>()); <span class="comment">// &#123;4,2&#125;</span></span><br><span class="line">    d.erase(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()); <span class="comment">// &#123;&#125;，等同于 d.clear()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>这里重点讲一下 insert() 函数的用法。insert() 函数的功能是在 deque 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示。</p><table><thead><tr><th>语法格式</th><th>功能</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的程序演示了 insert() 函数的这几种用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    d.insert(d.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="emplace系列函数的优势"><a href="#emplace系列函数的优势" class="headerlink" title="emplace系列函数的优势"></a>emplace系列函数的优势</h4><p>有关 emplace()、emplace_front() 和 emplace_back() 分别和 insert()、push_front() 和 push_back() 在运行效率上的对比，可以通过下面的程序体现出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// emplace和insert</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), <span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// emplace_front和push_front</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo3;</span><br><span class="line">    demo3.emplace_front(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_front:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo4;</span><br><span class="line">    demo4.push_front(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// emplace_back()和push_back()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo5;</span><br><span class="line">    demo5.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;testDemo&gt; demo6;</span><br><span class="line">    demo6.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace_front:</span><br><span class="line">调用构造函数</span><br><span class="line">push_front:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>可以看到，相比和它同功能的函数，emplace 系列函数都只调用了构造函数，而没有调用移动构造函数，这无疑提高了代码的运行效率。</p>]]></content>
      
      
      <categories>
          
          <category> C++STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4月27日晚散步有感</title>
      <link href="2022/04/27/4%E6%9C%8827%E6%97%A5%E6%99%9A%E6%95%A3%E6%AD%A5%E6%9C%89%E6%84%9F/"/>
      <url>2022/04/27/4%E6%9C%8827%E6%97%A5%E6%99%9A%E6%95%A3%E6%AD%A5%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>春天的夜晚，晚饭后，独自一人漫步在街道旁的小路上。<a id="more"></a></p><p>曾经就读的高中还是灯火通明，路人熙熙攘攘，我戴着耳机，听着喜欢的音乐，时而低头看路，时而抬头看着灰蒙蒙的天和散发着黄色光晕的路灯。每当这时，我都感到内心无比的宁静，精神无比的放松，因为我可以暂时将所有的烦恼都抛之脑后，让思绪飞扬，或者一片空白。</p><p>我就这样一路走着，穿过大街小巷，却怎么也不会感觉到累。街边的小店还在营业，主人坐在柜台看着手机发呆，他的孩子在一旁的小桌上写着作业；隔壁服装店有两位姐姐在做着运动，不会是“刘畊宏女孩”吧？再往前走，一家几口正坐在自家门口，露天吃着晚饭……突然想起已经很久没有在露天吃过晚饭了，那还是记忆中年少时住在乡下的场景，特别是在夏天的傍晚，吃着晚饭，纳着凉，听着知了和蛙叫个不停。</p><p>前一阵子还看到的路边树上盛开的叫不出名字的花，今天再看已经凋谢了很多，花瓣散落一地，让人惋惜，不过可能没有几个人注意吧，但它们还是年复一年地按时盛开，仿佛只要有那么一两个人知道，那么它们的盛开就有意义。不觉间就想到了自己，想到了爸爸妈妈，想到了很久以后，也许50年后（如果我能活到那个年纪的话），当我再次一个人走在这样的夜晚，走在这样的街道上时，夜色没有多大变化，但是爸爸妈妈可能已经不在了，我独自一人走在这样的路上，家里没有爸爸妈妈，只有一个空空的房子，那时，我应该会很伤心吧。不过转念又想，那时的我也许历尽岁月的沧桑后，早已变得无比强大，能够承受那样的悲伤和孤独，可是会不会不免感到些许难过呢？应该会吧，肯定会吧。回过神来，突然发现现在的自己真的很幸福，我才20几岁，有着大好的年华，有在家等待着我的爸爸妈妈。</p><p>回到家，爸爸在房间刷着抖音，妈妈躺在客厅的沙发看着电视，虽然她睡着了。我坐到沙发上，看着电视，感受着此刻的美好，用心铭记这一刻。多年以后，当我回想起这一刻时，一定会无比怀念吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL：顺序容器之vector</title>
      <link href="2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
      <url>2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>vector 容器是 STL 中最常用的容器之一，它和 array 容器非常类似，都可以看做是对 C++ 普通数组的“升级版”。不同之处在于，array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。<a id="more"></a></p><p>vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为O(1)；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶O(n)。</p><p>vector 容器以类模板 vector&lt;T&gt;（ T 表示存储元素的类型）的形式定义在 &lt;vector&gt; 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>capacity()</td><td>返回当前容量。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>reserve()</td><td>增加容器的容量。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 vector 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>vector 容器还有一个 std::swap(x , y) 非成员函数（其中 x 和 y 是存储相同类型元素的  vector 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><h3 id="创建vector容器的几种方式"><a href="#创建vector容器的几种方式" class="headerlink" title="创建vector容器的几种方式"></a>创建vector容器的几种方式</h3><p>创建 vector 容器的方式有很多，大致可分为以下几种。</p><p>1) 如下代码展示了如何创建存储 double 类型元素的一个 vector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure><p>注意，这是一个空的 vector 容器，因为容器中没有元素，所以没有为其分配空间。当添加第一个元素（比如使用 push_back() 函数）时，vector 会自动分配内存。</p><p>在创建好空容器的基础上，还可以像下面这样通过调用 reserve() 成员函数来增加容器的容量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.reserve(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>这样就设置了容器的内存分配，即至少可以容纳 20 个元素。注意，如果 vector 的容量在执行此语句之前，已经大于或等于 20 个元素，那么这条语句什么也不做；另外，调用 reserve() 不会影响已存储的元素，也不会生成任何元素，即 values 容器内此时仍然没有任何元素。</p><blockquote><p>还需注意的是，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector&lt;T&gt; 容器的元素可能已经被复制或移到了新的内存地址。所以后续再使用这些迭代器时，最好重新生成一下。</p></blockquote><p>2) 除了创建空 vector 容器外，还可以在创建的同时指定初始值以及元素个数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; primes&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br></pre></td></tr></table></figure><p>这样就创建了一个含有 8 个素数的 vector 容器。</p><p>3) 在创建 vector 容器时，也可以指定元素个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如此，values 容器开始时就有 20 个元素，它们的默认初始值都为 0。</p><blockquote><p>注意，圆括号 () 和大括号 {} 是有区别的，前者（例如 (20) ）表示元素的个数，而后者（例如 {20} ） 则表示 vector 容器中只有一个元素 20。</p></blockquote><p>如果不想用 0 作为默认值，也可以指定一个其它值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个参数指定了所有元素的初始值，因此这 20 个元素的值都是 1.0。</p><p>值得一提的是，圆括号 () 中的 2 个参数，既可以是常量，也可以用变量来表示，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br></pre></td></tr></table></figure><p>4) 通过存储元素类型相同的其它 vector 容器，也可以创建新的 vector 容器，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">5</span>, <span class="string">'c'</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br></pre></td></tr></table></figure><p>由此，value2 容器中也具有 5 个字符 ‘c’。在此基础上，如果不想复制其它容器中所有的元素，可以用一对指针或者迭代器来指定初始值的范围，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>)</span></span>; <span class="comment">// values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">begin</span>(value1),<span class="built_in">std</span>::<span class="built_in">begin</span>(value1)+<span class="number">3</span>)</span></span>; <span class="comment">// value2保存&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><p>由此，value2 容器中就包含了 {1,2,3} 这 3 个元素。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>vector 支持迭代器的成员函数和功能如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 新添加的 begin() 和 end() 全局函数也同样适用于 vector 容器。即当操作对象为 vector 容器时，其功能分别和上表中的 begin()、end() 成员函数相同。</p><p>这些成员函数的具体功能如下图所示：</p><p><img src="/2022/04/27/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/pic1.jpg" alt></p><p>从上图可以看出，这些成员函数通常是成对使用的，即 begin()/end()、rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 各自成对搭配使用。其中，begin()/end() 和 cbegin/cend() 的功能是类似的，同样 rbegin()/rend() 和 crbegin()/crend() 的功能是类似的。</p><blockquote><p>值得一提的是，以上函数在实际使用时，其返回值类型都可以使用 auto 关键字代替，编译器可以自行判断出该迭代器的类型。</p></blockquote><h4 id="vector容器迭代器的基本用法"><a href="#vector容器迭代器的基本用法" class="headerlink" title="vector容器迭代器的基本用法"></a>vector容器迭代器的基本用法</h4><p>vector 容器迭代器最常用的功能就是遍历访问容器中存储的元素。</p><p>首先来看 begin() 和 end() 成员函数，它们分别用于指向「首元素」和「尾元素+1」 的位置，下面程序演示了如何使用 begin() 和 end() 遍历 vector 容器并输出其中的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，迭代器对象是由 vector 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样上使用它们。比如代码中，在保存了元素值后，使用前缀<code>++</code>运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，比如将上面代码中第 8、9 行代码用如下代码替换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>cbegin()/cend() 成员函数和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，由 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.cend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*first = 10;不能修改元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序第 12 行，由于 first 是 const 类型的迭代器，因此不能用于修改容器中元素的值。</p><p>vector 模板类中还提供了 rbegin() 和 rend() 成员函数，分别表示指向最后一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。也就是说，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p><p>反向迭代器用于以逆序的方式遍历容器中的元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.rend();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：5 4 3 2 1</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/crend() 组合唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="vector容器迭代器的独特之处"><a href="#vector容器迭代器的独特之处" class="headerlink" title="vector容器迭代器的独特之处"></a>vector容器迭代器的独特之处</h4><p>和 array 容器不同，vector 容器可以随着存储元素的增加，自行申请更多的存储空间。因此，在创建 vector 对象时，我们可以直接创建一个空的 vector 容器，并不会影响后续使用该容器。</p><p>但这会产生一个问题，即在初始化空的 vector 容器时，不能使用迭代器。也就是说，如下初始化 vector 容器的方法是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="comment">// 初始化的同时输出值</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序可以看到，什么也没有输出。这是因为，对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。</p><blockquote><p>所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。</p></blockquote><p>除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，显示如下信息并崩溃：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0096</span>DFE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">00965560</span></span><br></pre></td></tr></table></figure><p>可以看到，values 容器在增加容量之后，首个元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的。因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 增加 values 的容量</span></span><br><span class="line">    values.reserve(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 容器首个元素的地址："</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">end</span> = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values 容器首个元素的地址：<span class="number">0164</span>DBE8</span><br><span class="line">values 容器首个元素的地址：<span class="number">01645560</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><h4 id="访问vector容器中单个元素"><a href="#访问vector容器中单个元素" class="headerlink" title="访问vector容器中单个元素"></a>访问vector容器中单个元素</h4><p>1) 首先，vector 容器可以向普通数组那样访问存储的元素，甚至对指定下标处的元素进行修改，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values[<span class="number">0</span>] = values[<span class="number">1</span>] + values[<span class="number">2</span>] + values[<span class="number">3</span>] + values[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>显然，vector 的索引从 0 开始，这和普通数组一样。通过使用索引，总是可以访问到 vector 容器中现有的元素。</p><p>值得一提的是，<code>容器名[n]</code>这种获取元素的方式，需要确保下标 n 的值不会超过容器的容量（可以通过 capacity() 成员函数获取），否则会发生越界访问的错误。幸运的是，和 array 容器一样，vector 容器也提供了 at() 成员函数，当传给 at() 的索引会造成越界时，会抛出<code>std::out_of_range</code>异常。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 获取容器中首个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中下标为 0 的元素的值</span></span><br><span class="line">    values.at(<span class="number">0</span>) = values.at(<span class="number">1</span>) + values.at(<span class="number">2</span>) + values.at(<span class="number">3</span>) + values.at(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; values.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这条语句会发生 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; values.at(5) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><blockquote><p>可能有这样一个疑问，即为什么 vector 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>2) 除此之外，vector 容器还提供了 2 个成员函数，即 front() 和 back()，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"values 尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改首元素</span></span><br><span class="line">    values.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的首元素为："</span> &lt;&lt; values.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改尾元素</span></span><br><span class="line">    values.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"values 新的尾元素为："</span> &lt;&lt; values.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values 首元素为：<span class="number">1</span></span><br><span class="line">values 尾元素为：<span class="number">5</span></span><br><span class="line">values 新的首元素为：<span class="number">10</span></span><br><span class="line">values 新的尾元素为：<span class="number">20</span></span><br></pre></td></tr></table></figure><p>3) 另外，vector 容器还提供了 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 输出容器中第 3 个元素的值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改容器中第 2 个元素的值</span></span><br><span class="line">    *(values.data() + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(values.data() + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="访问vector容器中多个元素"><a href="#访问vector容器中多个元素" class="headerlink" title="访问vector容器中多个元素"></a>访问vector容器中多个元素</h4><p>如果想访问 vector 容器中多个元素，可以借助 size() 成员函数，该函数可以返回 vector 容器中实际存储的元素个数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不要使用 capacity() 成员函数，因为它返回的是 vector 容器的容量，而不是实际存储元素的个数，这两者是有差别的。</p><p>或者也可以使用基于范围的循环，此方式将会逐个遍历容器中的元素。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还可以使用 vector 迭代器遍历 vector 容器，这里以 begin()/end() 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.<span class="built_in">begin</span>(); first &lt; values.<span class="built_in">end</span>(); ++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为： 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，这里也可以使用 rbegin()/rend()、cbegin()/cend()、crbegin()/crend() 以及全局函数 begin()/end() ，它们都可以实现对容器中元素的访问。</p></blockquote><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中，第 8 行代码表示向 values 容器尾部添加一个元素，但由于当前 values 容器是空的，因此新添加的元素 1 无疑成为了容器中首个元素；第 9 行代码实现的功能是在现有元素 1 的后面，添加元素 2。</p><p>运行程序，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back()"></a>emplace_back()</h4><p>该函数是 C++ 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。</p><p>emplace_back() 成员函数的用法也很简单，这里直接举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.emplace_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>读者可能会发现，以上 2 段代码，只是用 emplace_back() 替换了 push_back()，既然它们实现的功能是一样的，那么 C++ 11 标准中为什么要多此一举呢？</p><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>为了清楚的了解它们之间的区别，创建一个包含类对象的 vector 容器，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace_back(<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.push_back(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure><p>在此基础上，读者可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure><p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p>显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议优先选用 emplace_back()。</p><blockquote><p>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</p></blockquote><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如下表所示。</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 第一种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// &#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">// 第二种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// &#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">// 第三种格式用法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>()); <span class="comment">// &#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">// 第四种格式用法</span></span><br><span class="line">    demo.insert(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;); <span class="comment">// &#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><p>emplace() 是 C++ 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p><blockquote><p>强调：emplace() 每次只能插入一个元素，而不是多个。</p></blockquote><p>该函数的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator pos, args...)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p><blockquote><p>简单的理解 args…，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是：emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num) :num(num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用移动构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.insert(demo2.<span class="built_in">begin</span>(), testDemo(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.emplace(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure><blockquote><p>注意，当拷贝构造函数和移动构造函数同时存在时，insert() 会优先调用移动构造函数。</p></blockquote><p>可以看到，通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。</p><p>简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐优先使用 emplace()。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>前面提到，无论是向现有 vector 容器中访问元素、添加元素还是插入元素，都只能借助 vector 模板类提供的成员函数，但删除 vector 容器的元素例外，完成此操作除了可以借助本身提供的成员函数，还可以借助一些全局函数。</p><p>基于不同场景的需要，删除 vecotr 容器的元素，可以使用下表中所示的函数（或者函数组合）。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。</td></tr><tr><td>swap(beg)、pop_back()</td><td>先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。</td></tr><tr><td>erase(beg,end)</td><td>删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。</td></tr><tr><td>remove()</td><td>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</td></tr><tr><td>clear()</td><td>删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。</td></tr></tbody></table><p>1) pop_back() 成员函数的用法非常简单，它不需要传入任何的参数，也没有返回值。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="comment">// 输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以发现，相比原 demo 容器，新的 demo 容器删除了最后一个元素 5，容器的大小减了 1，但容量没变。</p><p>2) 如果想删除 vector 容器中指定位置处的元素，可以使用 erase() 成员函数，该函数的语法格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(pos)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，pos 为指定被删除元素位置的迭代器，同时该函数会返回一个指向删除元素所在位置下一个位置的迭代器。</p><p>下面的例子演示了 erase() 函数的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除元素 2</span></span><br><span class="line">    <span class="comment">// 输出 dmeo 容器新的size</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 demo 容器新的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// iter迭代器指向元素 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>通过结果不能看出，erase() 函数在删除元素时，会将删除位置后续的元素陆续前移，并将容器的大小减 1。</p><p>另外，如果不在意容器中元素的排列顺序，可以结合 swap() 和 pop_back() 函数，同样可以实现删除容器中指定位置元素的目的。</p><blockquote><p>注意，swap() 函数在头文件 <code>&lt;algorithm&gt;</code> 和 <code>&lt;utility&gt;</code> 中都有定义，使用时引入其中一个即可。</p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    swap(*(<span class="built_in">std</span>::<span class="built_in">begin</span>(demo)+<span class="number">1</span>),*(<span class="built_in">std</span>::<span class="built_in">end</span>(demo)<span class="number">-1</span>));<span class="comment">//等同于 swap(demo[1],demo[4])</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 交换位置后的demo容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    demo.pop_back();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出demo 容器中剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line">size <span class="keyword">is</span> :<span class="number">4</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>当然，除了删除容器中单个元素，还可以删除容器中某个指定区域内的所有元素，同样可以使用 erase() 成员函数实现。该函数有 2 种基本格式，前面介绍了一种，这里使用另一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 是指定被删除元素区域的迭代器，同时该函数会返回指向此区域之后一个位置的迭代器。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 删除 2、3</span></span><br><span class="line">    <span class="keyword">auto</span> iter = demo.erase(demo.<span class="built_in">begin</span>()+<span class="number">1</span>, demo.<span class="built_in">end</span>() - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，和删除单个元素一样，删除指定区域内的元素时，也会将该区域后续的元素前移，并缩小容器的大小。</p><p>3) 如果要删除容器中和指定元素值相同的所有元素，可以使用 remove() 函数，该函数定义在 <code>&lt;algorithm&gt;</code> 头文件中。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = demo.<span class="built_in">begin</span>(); first &lt; iter;++first) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>注意，在对容器执行完 remove() 函数之后，由于该函数并没有改变容器原来的大小和容量，因此无法使用之前的方法遍历容器，而是需要向程序中那样，借助 remove() 返回的迭代器完成正确的遍历。</p><blockquote><p>remove() 的实现原理是，在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，直到找到一个非目标元素，即用此元素将最先做标记的位置覆盖掉，同时将此非目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。因此，如果将上面程序中 demo 容器的元素全部输出，得到的结果为 <code>1 4 5 4 3 5</code>。</p></blockquote><p>另外还可以看到，既然通过 remove() 函数删除掉 demo 容器中的多个指定元素，该容器的大小和容量都没有改变，其剩余位置还保留了之前存储的元素。我们可以使用 erase() 成员函数删掉这些 “无用” 的元素。</p><p>比如，修改上面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    demo.erase(iter, demo.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出剩余的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">3</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用。</p></blockquote><p>4) 如果想删除容器中所有的元素，则可以使用 clear() 成员函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size is :"</span> &lt;&lt; demo.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity is :"</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size <span class="keyword">is</span> :<span class="number">0</span></span><br><span class="line">capacity <span class="keyword">is</span> :<span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL：顺序容器</title>
      <link href="2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
      <url>2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h3><p>所谓顺序容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。<a id="more"></a></p><p>顺序容器大致包含以下几类容器：</p><ul><li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li>vector&lt;T&gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li>deque&lt;T&gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li>list&lt;T&gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li>forward_list&lt;T&gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><blockquote><p>注意，其实除此之外，stack 和 queue 本质上也属于顺序容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器。</p></blockquote><p>下图说明了各种顺序容器及它们之间的区别：</p><p><img src="/2022/04/26/C-STL%EF%BC%9A%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/pic1.jpg" alt></p><hr><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array 容器是 C++ 11 标准中新增的顺序容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。</p><p>array 容器以类模板的形式定义在 &lt;array&gt; 头文件，并位于命名空间 std 中，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>在 array&lt;T,N&gt; 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。</p><p>1) array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p><p>2) 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>使用该语句，容器中所有的元素都会被初始化为 0.0。</p><p>3) 当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="http://c.biancheng.net/c/80/" target="_blank" rel="noopener">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>另外，在 &lt;array&gt; 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>STL 为 array 容器配备了随机访问迭代器，该类迭代器是功能最强大的迭代器。在 array 容器的模板类中，和随机访问迭代器相关的成员函数如下表所示：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p>除此之外，C++ 11 标准新增的 begin() 和 end() 函数，当操作对象为 array 容器时，也和迭代器有关，其功能分别和上表中的 begin()、end() 成员函数相同。</p><h5 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()/end() 和 cbegin()/cend()"></a>begin()/end() 和 cbegin()/cend()</h5><p>array 容器模板类中的 begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p><p>例如，可以在循环中显式地使用迭代器来初始化 values 容器的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通指针那样使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>与此同时，还可以使用全局的 begin() 和 end() 函数来从容器中获取迭代器，因为当操作对象为 array 容器时，它们和 begin()/end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = <span class="built_in">std</span>::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>这样，容器中的一段元素可以由迭代器指定，这让我们有了对它们使用算法的可能。</p><blockquote><p>需要注意的是，STL 标准库，不是只有 array 容器，当迭代器指向容器中的一个特定元素时，它们不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，它是指向 array 容器还是指向 vector 容器。</p></blockquote><p>除此之外，array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()/end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.cend();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 *first 为 const 类型，不能用来修改元素</span></span><br><span class="line">    <span class="comment">// *first = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="comment">// 可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rbegin-rend-和-crbegin-crend"><a href="#rbegin-rend-和-crbegin-crend" class="headerlink" title="rbegin()/rend() 和 crbegin()/crend()"></a>rbegin()/rend() 和 crbegin()/crend()</h5><p>array 模板类中还提供了 rbegin()/rend() 和 crbegin()/crend() 成员函数，它们每对都可以分别得到指向最一个元素和第一个元素前一个位置的随机访问迭代器，又称它们为反向迭代器。也就是说，在使用反向迭代器进行 <code>++</code> 或 <code>--</code> 运算时，<code>++</code> 指的是迭代器向左移动一位，<code>--</code> 指的是迭代器向右移动一位，即这两个运算符的功能也“互换”了。</p><p>反向迭代器用于以逆序的方式处理元素。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.rbegin();</span><br><span class="line">    <span class="keyword">auto</span> last = values.rend();</span><br><span class="line">    <span class="comment">// 初始化 values 容器为 &#123;5,4,3,2,1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历容器，并输入各个元素</span></span><br><span class="line">    first = values.rbegin();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出结果为：1 2 3 4 5</span></span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，从最后一个元素开始循环，不仅完成了容器的初始化，还遍历输出了容器中的所有元素。结束迭代器指向第一个元素之前的位置，所以当 first 指向第一个元素并 +1 后，循环就结朿了。</p><p>当然，在上面程序中，我们也可以使用 for 循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> first = values.rbegin(); first != values.rend(); ++first) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crbegin()/crend() 组合和 rbegin()/rend() 组合的功能唯一的区别在于，前者返回的迭代器为 const 类型，即不能用来修改容器中的元素，除此之外在使用上和后者完全相同。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><h5 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h5><p>1) 首先，可以通过容器名[]的方式直接访问和使用容器中的元素，这和 C++ 标准数组访问元素的方式相同，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.at (<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2.</span>O*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 <code>std::out_of_range</code> 异常。因此当需要访问容器中某个指定元素时，建议使用 at()，除非确定索引没有越界。</p><blockquote><p>可能有这样一个疑问，即为什么 array 容器在重载 [] 运算符时，没有实现边界检查的功能呢？答案很简单，因为性能。如果每次访问元素，都去检查索引值，无疑会产生很多开销。当不存在越界访问的可能时，就能避免这种开销。</p></blockquote><p>2) 除此之外，array 容器还提供了 get&lt;n&gt; 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</p><p>下面代码展示了如何使用 get&lt;n&gt; 模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">string</span>, 5&gt; words&#123; <span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Output words[3]</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; // 越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的指针。通过该指针，我们可以获得容器中的各个元素，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *( words.data()+<span class="number">1</span>); <span class="comment">// 输出结果：2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h5><p>1) 我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p><p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.empty())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has no elements.\n"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The container has "</span>&lt;&lt; values.<span class="built_in">size</span>()&lt;&lt;<span class="string">"elements.\n"</span>;</span><br></pre></td></tr></table></figure><p>然而，很少会创建空的 array 容器，因为当生成一个 array 容器时，它的元素个数就固定了，而且无法改变，所以生成空 array 容器的唯一方法是将模板的第二个参数指定为 0，但这种情况基本不可能发生。</p><blockquote><p>array 容器之所以提供 empty() 成员函数的原因，对于其他元素可变或者元素可删除的容器（例如 vector、deque 等）来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</p></blockquote><p>2) 除了借助 size() 外，对于任何可以使用迭代器的容器，都可以使用基于范围的循环，因此能够更加简便地计算容器中所有元素的和，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL：容器与迭代器</title>
      <link href="2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>2022/04/25/C-STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。<a id="more"></a>STL 提供有 3 类标准容器，分别是顺序容器、排序容器和哈希容器，其中后两类容器有时也统称为关联容器。它们各自的含义如下表所示：</p><table><thead><tr><th align="left">容器种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="left">顺序容器</td><td align="center">主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td align="left">排序容器</td><td align="center">包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td></tr><tr><td align="left">哈希容器</td><td align="center">C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>无论是顺序容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p><p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p><p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p><p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。</p><h4 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h4><p>STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。其中，输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。</p><ul><li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p></li><li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 <code>--p</code> 或者 <code>p--</code> 操作（即一次向后移动一个位置）。</p></li><li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p+=i：使得 p 往后移动 i 个元素。</span><br><span class="line">p-=i：使得 p 往前移动 i 个元素。</span><br><span class="line">p+i：返回 p 后面第 i 个元素的迭代器。</span><br><span class="line">p-i：返回 p 前面第 i 个元素的迭代器。</span><br><span class="line">p[i]：返回 p 后面第 i 个元素的引用。</span><br></pre></td></tr></table></figure><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减1）。</p></li></ul><p>下表所示，是 C++ 11 标准中不同容器指定使用的迭代器类型。</p><table><thead><tr><th align="left">容器</th><th align="left">对应的迭代器类型</th></tr></thead><tbody><tr><td align="left">array</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">vector</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">deque</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">list</td><td align="left">双向迭代器</td></tr><tr><td align="left">set / multiset</td><td align="left">双向迭代器</td></tr><tr><td align="left">map / multimap</td><td align="left">双向迭代器</td></tr><tr><td align="left">forward_list</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_map / unordered_multimap</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_set / unordered_multiset</td><td align="left">前向迭代器</td></tr><tr><td align="left">stack</td><td align="left">不支持迭代器</td></tr><tr><td align="left">queue</td><td align="left">不支持迭代器</td></tr></tbody></table><p>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</p><h4 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h4><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如下表所示。</p><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator  迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator  迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator  迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator  迭代器名;</td></tr></tbody></table><p>值得一提的是，上表中的反向迭代器全称为 “反向迭代器适配器”。</p><p>通过定义以上几种迭代器，就可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</p><p>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p><h4 id="迭代器实例"><a href="#迭代器实例" class="headerlink" title="迭代器实例"></a>迭代器实例</h4><p>1) 以上对迭代器做了很详细的介绍，下面就以 vector 容器为例，实际感受迭代器的用法和功能。通过前面的学习，vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;; <span class="comment">// v被初始化成有10个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 像普通数组一样使用vector容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个正向迭代器，当然，vector 也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第二种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第三种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">// 用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"第四种遍历方法："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        i += <span class="number">1</span>; <span class="comment">// 随机访问迭代器支持 "+= 整数" 的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第二种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第三种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">第四种遍历方法：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>2) 再举一个例子，我们知道，list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// 创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>则以下代码是合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码则不合法，因为双向迭代器不支持用“&lt;”进行比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><p>以下代码也不合法，因为双向迭代器不支持用下标随机访问元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p>其实在 C++ 中，数组也是容器，数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p>]]></content>
      
      
      <categories>
          
          <category> C++STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="2022/04/25/C-STL/"/>
      <url>2022/04/25/C-STL/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-STL"><a href="#什么是-STL" class="headerlink" title="什么是 STL"></a>什么是 STL</h3><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 <a id="more"></a></p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 标准库的重要组成部分。如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装。STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等。</p><h3 id="STL-的组成"><a href="#STL-的组成" class="headerlink" title="STL 的组成"></a>STL 的组成</h3><p>通常认为，STL 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的，如下表所示：</p><table><thead><tr><th align="left">STL的组成</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">容器</td><td align="center">一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td></tr><tr><td align="left">算法</td><td align="center">STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 &lt;algorithm&gt; 中，少部分位于头文件 &lt;numeric&gt; 中。</td></tr><tr><td align="left">迭代器</td><td align="center">在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td></tr><tr><td align="left">函数对象</td><td align="center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td></tr><tr><td align="left">适配器</td><td align="center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td></tr><tr><td align="left">内存分配器</td><td align="center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td></tr></tbody></table><p>另外，在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++ 标准中，它们被重新组织为 13 个头文件，分别是：&lt;iterator&gt;、&lt;functional&gt;、&lt;vector&gt;、&lt;deque&gt;、&lt;list&gt;、&lt;queue&gt;、&lt;stack&gt;、&lt;set&gt;、&lt;map&gt;、&lt;algorithm&gt;、&lt;numeric&gt;、&lt;memory&gt;和&lt;utility&gt;。</p>]]></content>
      
      
      <categories>
          
          <category> C++STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++:引用计数</title>
      <link href="2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是引用计数"><a href="#什么是引用计数" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h3><p>引用计数（reference count）的核心思想是使用一个计数器来标识当前指针指向的对象被多少类的对象所使用（即记录指针指向对象被引用的次数）。它允许有多个相同值的对象共享这个值的实现。引用计数的使用常有两个目的：</p><ul><li><p>简化跟踪堆中（也即C++中new出来的）的对象的过程。一旦一个对象通过调用new被分配出来，记录谁拥有这个对象是很重要的，因为其所有者要负责对它进行delete。但是对象所有者可以有多个，且所有权能够被传递，这就使得内存跟踪变得困难。引用计数可以跟踪对象所有权，并能够自动销毁对象。可以说引用计数是个简单的垃圾回收体系。</p></li><li><p>节省内存，提高程序运行效率。如果很多对象有相同的值，为这多个相同的值存储多个副本是很浪费空间的，所以最好做法是让左右对象都共享同一个值的实现。C++标准库中<strong>string</strong>类采取一种称为”写时复制“的技术，使得只有当字符串被修改的时候才创建各自的拷贝，否则可能（标准库允许使用但没强制要求）采用引用计数技术来管理共享对象的多个对象。<a id="more"></a></p></li></ul><h3 id="引用计数的实现"><a href="#引用计数的实现" class="headerlink" title="引用计数的实现"></a>引用计数的实现</h3><p>使用引用计数实现智能指针的关键是，引用计数应该存在哪里。引用计数应该是某个类对象和其复制对象共享的， 而指针成员恰好有这样的特性， 故可以在类中多声明一个size_t* 的成员，用来表示引用计数。</p><ul><li>构造函数中创建类的新对象时，初始化引用计数为1；</li><li>拷贝构造函数复制指针，并使相应的引用计数增加1；</li><li>赋值操作减少左操作数所指对象的引用计数，增加右操作数所指对象的引用计数；</li><li>析构函数使引用计数减少1，并且当引用计数为1时，释放指针所指向的对象；</li></ul><p><img src="/2022/01/11/C-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/1.png" alt></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>; <span class="keyword">using</span> <span class="built_in">std</span>::ostream; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// string()：构造空的string类对象，既空字符串</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123; &#125; <span class="comment">// constructor</span></span><br><span class="line">~HasPtr(); <span class="comment">// 析构函数</span></span><br><span class="line">HasPtr(<span class="keyword">const</span> HasPtr&amp; rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++* use; &#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;); <span class="comment">// 运算符重载</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span>* ps; <span class="comment">// ps是一个指针，指向string类型</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span>* use; <span class="comment">// use是一个指针，指向size_t类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数的定义</span></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 如果引用计数为变0</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 释放string内存</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放计数器内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载的定义</span></span><br><span class="line">HasPtr&amp;</span><br><span class="line">HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">++* rhs.use;<span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line"><span class="keyword">if</span> (-- * use == <span class="number">0</span>) &#123;<span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line"><span class="keyword">delete</span> ps;<span class="comment">// 如果没有其他用户</span></span><br><span class="line"><span class="keyword">delete</span> use;<span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">&#125;</span><br><span class="line">ps = rhs.ps;<span class="comment">// 将数据从rhs拷贝到本对象</span></span><br><span class="line">i = rhs.i;</span><br><span class="line">use = rhs.use;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的定义</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">os &lt;&lt; p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.ps &lt;&lt; <span class="string">' '</span> &lt;&lt; *p.use;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> HasPtr&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HasPtr temp;</span><br><span class="line">temp = p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, p) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"temp: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, temp) &lt;&lt; <span class="string">'\n'</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HasPtr str1(\"copy me\"), str2;\n"</span>;</span><br><span class="line">HasPtr str1("copy me"), str2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr2 = str1;\n"</span>;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nfunc(str1);\n"</span>;</span><br><span class="line">func(str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nstr1: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str1) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">cout</span>, str2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HasPtr str1(<span class="string">"copy me"</span>), str2;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">1</span></span><br><span class="line">str2: <span class="number">011654E8</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">str2 = str1;</span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line"></span><br><span class="line">func(str1);</span><br><span class="line">p: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line">temp: <span class="number">0116</span>D990 copy me <span class="number">3</span></span><br><span class="line"></span><br><span class="line">str1: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br><span class="line">str2: <span class="number">0116</span>D990 copy me <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+selenium实现自动刷新网页</title>
      <link href="2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/"/>
      <url>2022/01/06/python-selenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>Selenium是一个用于Web应用程序测试的工具，本文介绍利用python+selenium实现自动刷新网页。</strong></p><a id="more"></a><hr><p>一、安装 selenium</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>二、下载并导入浏览器驱动</p><p>1、查看Chrome浏览器版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://version</span><br></pre></td></tr></table></figure><p>2、根据版本下载对应浏览器驱动</p><p>下载网址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>3、将下载的驱动放入python安装目录Scripts文件夹下。</p><p>三、示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    driver.refresh()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《信》-东野圭吾</title>
      <link href="2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
      <url>2022/01/04/%E3%80%8A%E4%BF%A1%E3%80%8B-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/</url>
      
        <content type="html"><![CDATA[<p>看完了东野圭吾的《信》，这不是一部推理题材的小说，只是讲述了一个关于人性的故事。故事围绕“犯罪者的家属该不该受到歧视”展开，主人公的哥哥犯下了盗窃杀人罪，留下他独自一人，没有钱上大学只能去打工，却在被老板知道自己的哥哥是罪犯后遭遇辞退，一次次想隐瞒却又终究暴露，连自己的女朋友也因此分手，好不容易结婚生了孩子，竟连孩子也要饱受歧视。于是，他的心理也在这一件件事中发生改变，甚至扭曲，终于无法忍受，写信告诉自己的哥哥要断绝关系，不再相见……<a id="more"></a></p><p>以前，我只觉得犯罪者的家属因犯罪者而受到歧视似乎有失公允，至少不能一概而论，但大家的做法也无可厚非，因为没有人愿意跟犯罪扯上关系。现在看来，这里面还有一层含义，那就是这些家属所受的歧视其实也是犯罪成本的一部分，以此来警告那些试图犯罪者，犯罪的结果不只牵涉本人，也会给亲人带来麻烦。可是，我又有了一个疑问。犯罪者在犯罪时可能会想到这么多吗？即使像这篇小说中，主人公的哥哥是为了替他凑够上大学的学费才去盗窃，也不是一开始就计划杀人，他也没能想到由此可能带给弟弟的痛苦，更不必说那些穷凶极恶之徒了。所以，这种警告跟欲犯罪者自身素养和对犯罪后果的了解有很大关系，但总的来说，这并不是一件可以讨论谁对谁错的事。</p><p>至于主人公，让我想起了一部电视剧《琅琊榜：风起长林》中的反派人物萧元启。他作为犯罪者的儿子，遭遇了人间冷暖，世态炎凉，本来是一个可怜之人，却最终一步步跌入仇恨的深渊。在他完全黑化前，与长林老王爷的一段对话让我记忆犹新，这也是曾经可能挽救他的良药。</p><blockquote><p>萧元启：境遇冷暖，自然会影响人的性情。性情若是变了，本心会变吗？</p><p>老王爷：如果你觉得这世态炎凉，那是因为你还没有经历过真正的地狱，一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p></blockquote><p>但萧元启终究没能找回他的赤子之心。现实中也是如此，一个人无疑是容易被周遭环境所影响的，特别是在如今的社会，复杂的人际关系，各种各样的诱惑，我们也许在不知不觉中就已经走在背离本心的路上，或是在某些情况下，我们不得不做出违背初心的行为，所以，我们应该时常问问自己是否还坚持着初心，这也许很难，但应该坚守。若是真的做出了违背初心的事，是否就一定会堕入深渊呢？也许会，也许不会。人世间的很多事很难得出对与错的结论，毕竟我们中的大多数都是普通人，我们常常站在道德的制高点趾高气昂，评头论足，却没有深入探究事件本身的勇气与能力。那么，我们究竟应该怎么做呢？还是那句话：一个人本性若善，纵然是烈狱归来，其赤子之心亦可永生不死。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件重定向</title>
      <link href="2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>2021/12/26/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>当测试程序时，反复从键盘敲入测试数据作为程序的输入，是非常乏味且低效的。<a id="more"></a>大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与文件命名关联起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure><p>假定$是操作系统提示符，程序已经编译为名为addItems.exe的可执行文件（在UNIX操作系统中是addItems），则上述命令会从一个名为infile的文件读取数据，并将结果写入到一个名为outfile的文件中，两个文件都处于当前目录中。</p><p>以在Windows下为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\C++Primer\Debug&gt;<span class="string">"C++Primer.exe"</span> &lt;infile.txt&gt;outfile.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的研究生之旅</title>
      <link href="2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/"/>
      <url>2021/12/19/%E6%88%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>应该是三月吧，时间记不清了，初试成绩出来的那一刻我觉得应该进不了复试了。<a id="more"></a>又逢家中的一些变故，那时只想离开家，所以我骗家人不想调剂，决定出去找工作，其实我的内心是想调剂的。</p><p>离开家，回到曾经工作的地方一直准备调剂，却又感觉希望渺茫，心想实在调剂不上就继续工作吧。调剂系统出来的第一天，由于没有调剂经验，很快填完了3个名额，填的学校都是比较好的学校，导致填完就没有了下文，最多就是被查看，一直没有复试通知。错过了前期的黄金调剂期，后面调剂越来越难，幸运的是，在最后时刻终于被录取了，虽然是一所很一般的学校。心是有不甘，但这已经是比较好的结局。</p><p>九月入学，第一次来到东北，有些陌生，有些新鲜。很快适应了大学生活，就像我只是放假后又重新回到学校，不过还是有了很多不一样的感受。再一次在秋天凉爽的夜晚漫步在学校的马路操场上，看着熙熙攘攘的学生，踩着滑板，唱着歌，一幅幅青春的模样，一年前的我怎么也不会想到今天的自己又回到了校园，以一个学生的身份。没错，我又回到了校园，没有生活的琐碎，工作的烦恼，只有无忧无虑的学习、生活和娱乐，可以有大量的时间做自己想做的事，我感到无比幸运，因为就连这样的散步都是工作后奢侈的享受。我又走进了图书馆，去阶梯教室上课，去食堂吃饭，睡四人寝……每一件事都是熟悉的样子，恍如昨日，这些曾经离开校园后最美好的回忆，我正在体验着，也更加珍惜，果然人总是在失去后才会懂得拥有的珍贵。</p><p>一学期的学习生活很快结束，考试周的考试也结束了，又松了口气，可以继续做自己想做的事，看自己喜欢的书，马上就可以放假飞到想去的城市见见许久未见的老友。生活很平淡，有时甚至很艰难，可是总有什么是我们期待的，总有什么是值得我们期待的，不知不觉中，我们都在朝着更好的方向努力，明天的生活不知道会怎样，可是我们要珍惜现在的我们和现在的时光。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>追赶法求解线性方程组</title>
      <link href="2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>2021/10/12/%E8%BF%BD%E8%B5%B6%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>利用追赶法求解线性方程组，基于C语言实现。</strong></p><p><strong>追赶法是LU分解法的一种特例，其系数矩阵是一种稀疏矩阵，除主对角线及相邻的两条对角线为非零元素，其余元素值均为0，称为三对角矩阵。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> c[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> d[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2.5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>, i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i]/b[i<span class="number">-1</span>];</span><br><span class="line">        b[i]=b[i]-c[i<span class="number">-1</span>]*a[i];</span><br><span class="line">        d[i]=d[i]-a[i]*d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    d[n]=d[n]/b[n];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=(d[i]-c[i]*d[i+<span class="number">1</span>])/b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,d[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.100000</span></span><br><span class="line"><span class="number">2.200000</span></span><br><span class="line"><span class="number">2.300000</span></span><br><span class="line"><span class="number">2.400000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数值分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LU分解法求解线性方程组</title>
      <link href="2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>2021/10/11/LU%E5%88%86%E8%A7%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>利用LU分解法求解线性方程组，基于C++语言实现。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵的ALU分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALU</span><span class="params">(<span class="keyword">double</span> a[n][n], <span class="keyword">double</span> b[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> u[n][n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行U的第一行的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[<span class="number">0</span>][i] = a[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行L的第一列的赋值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i][<span class="number">0</span>] = a[i][<span class="number">0</span>] / u[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算U的剩下的行数和L的剩下的列数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 计算U的行</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum1 += l[i][k] * u[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">            u[i][j] = a[i][j] - sum1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算L的列</span></span><br><span class="line">        <span class="keyword">if</span>(i!=n)</span><br><span class="line"><span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2 += l[j][k] * u[k][i];</span><br><span class="line">&#125;</span><br><span class="line">l[j][i] = (a[j][i] - sum2) / u[i][i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出L和U</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵L为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"矩阵U为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求y</span></span><br><span class="line">    <span class="keyword">double</span> y[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    y[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">            sum3 += l[i][j] * y[j];</span><br><span class="line">        y[i] = b[i] - sum3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求x</span></span><br><span class="line">    <span class="keyword">double</span> x[n] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    x[n - <span class="number">1</span>] = y[n - <span class="number">1</span>] / u[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> sum4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            sum4 += u[i][j] * x[j];</span><br><span class="line">        x[i] = (y[i] - sum4) / u[i][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"该线性方程组的解为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x["</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"]="</span> &lt;&lt; x[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> b[<span class="number">3</span>] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    ALU(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">矩阵L为：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">-0.333333</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0.333333</span> <span class="number">-0.357143</span> <span class="number">0</span></span><br><span class="line">矩阵U为：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">4.66667</span> <span class="number">4.66667</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">x[<span class="number">1</span>]=<span class="number">0.5</span></span><br><span class="line">x[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">x[<span class="number">3</span>]=<span class="number">0.5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数值分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯消去法求解线性方程组</title>
      <link href="2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>2021/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>利用高斯消去法求解线性方程组，基于C语言实现。</strong></p><a id="more"></a><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A[MAX][MAX];</span><br><span class="line"><span class="keyword">double</span> b[MAX];</span><br><span class="line"><span class="keyword">double</span> X[MAX];</span><br><span class="line"><span class="keyword">int</span> NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的阶数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;NUM);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入系数矩阵A的第%d行元素:"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=NUM; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;A[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入右端项b:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=NUM; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的系数矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">float</span> mik;<span class="comment">//消元过程所用变量</span></span><br><span class="line">    <span class="keyword">float</span> S;<span class="comment">//回代过程所用变量</span></span><br><span class="line"></span><br><span class="line">    inputMatrix();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消元</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;NUM<span class="number">-1</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!A[k][k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=k+<span class="number">1</span>; i&lt;NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mik=A[i][k]/A[k][k];</span><br><span class="line">b[i]=b[i]-mik*b[k];</span><br><span class="line">            <span class="keyword">for</span>(j=k; j&lt;NUM; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A[i][j]=A[i][j]-mik*A[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的矩阵A为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;NUM; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lf "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消元后的右端项b为:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回代</span></span><br><span class="line">    X[NUM<span class="number">-1</span>]=b[NUM<span class="number">-1</span>]/A[NUM<span class="number">-1</span>][NUM<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(k=NUM<span class="number">-2</span>; k&gt;=<span class="number">0</span>; k--)</span><br><span class="line">    &#123;</span><br><span class="line">        S=b[k];</span><br><span class="line">        <span class="keyword">for</span>(j=k+<span class="number">1</span>; j&lt;NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            S=S-A[k][j]*X[j];</span><br><span class="line">        &#125;</span><br><span class="line">        X[k]=S/A[k][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出解</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该线性方程组的解为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NUM;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"X%d=%lf\n"</span>,i+<span class="number">1</span>,X[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入系数矩阵A的阶数:<span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">1</span>行元素:<span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">输入系数矩阵A的第<span class="number">2</span>行元素:<span class="number">12</span> <span class="number">-3</span> <span class="number">3</span></span><br><span class="line">输入系数矩阵A的第<span class="number">3</span>行元素:<span class="number">-18</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line">输入右端项b:<span class="number">6</span> <span class="number">15</span> <span class="number">-15</span></span><br><span class="line"></span><br><span class="line">输入的系数矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">12.000000</span> <span class="number">-3.000000</span> <span class="number">3.000000</span></span><br><span class="line"><span class="number">-18.000000</span> <span class="number">3.000000</span> <span class="number">-1.000000</span></span><br><span class="line">输入的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">15.000000</span></span><br><span class="line"><span class="number">-15.000000</span></span><br><span class="line"></span><br><span class="line">消元后的矩阵A为:</span><br><span class="line"><span class="number">1.000000</span> <span class="number">1.000000</span> <span class="number">1.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">-15.000000</span> <span class="number">-9.000000</span></span><br><span class="line"><span class="number">0.000000</span> <span class="number">0.000000</span> <span class="number">4.400000</span></span><br><span class="line">消元后的右端项b为:</span><br><span class="line"><span class="number">6.000000</span></span><br><span class="line"><span class="number">-57.000000</span></span><br><span class="line"><span class="number">13.200001</span></span><br><span class="line"></span><br><span class="line">该线性方程组的解为：</span><br><span class="line">X1=<span class="number">1.000000</span></span><br><span class="line">X2=<span class="number">2.000000</span></span><br><span class="line">X3=<span class="number">3.000000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数值分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>void*的用法</title>
      <link href="2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>2021/08/22/void-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>void*是一种特殊的指针类型，可用于存放任意对象的地址。</strong></p><a id="more"></a><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, * pd = &amp;obj;</span><br><span class="line"><span class="keyword">void</span>* pv = pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*pd 的值为："</span> &lt;&lt; *pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "*pv 的值为：" &lt;&lt; *pv &lt;&lt; endl; // 错误，不能直接操作 void* 所指的对象，因为我们并不知道这个对象到底是什么类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pd 的值为：<span class="number">3.14</span></span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br><span class="line"><span class="number">00000010596</span>FFC58</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海街日记</title>
      <link href="2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/"/>
      <url>2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>“虽然知道自己马上就要死了，但是依然能感受到美丽的东西是美的，很开心。”</p><p>电影开头铃的父亲和电影结尾二宫女士的去世，告诉我们无尽温柔的人也无法抵挡死亡；海上的烟花会和盛开的樱花，在绽放后转瞬消逝……这些无一不蕴含对美好易逝的感叹。</p><p>但这部电影的主题却不是宣扬悲观，而是在告诉人们，死亡和失去并不可怕，重要的是珍惜身边的人，珍惜现在，好好生活。</p><p><img src="/2021/03/20/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B0.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的实现及应用-改进1</title>
      <link href="2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/"/>
      <url>2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%94%B9%E8%BF%9B1/</url>
      
        <content type="html"><![CDATA[<p>本文是对 <a href="https://crossoverpptx.github.io/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener"><strong>二叉树的实现及应用</strong></a> 的改进，源程序被拆分为四个子程序：Status.h（状态码头文件）、BiTree.h（二叉树数据结构及函数声明头文件）、BiTree.c（函数定义）、BiTree-main.c（主程序）。</p><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Status.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STATUS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OVERFLOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW    -2  <span class="comment">//堆栈上溢</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统中已有此状态码定义，要防止冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BITREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树元素类型定义，这里假设其元素类型为char */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二叉树结点定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    TElemType data;             <span class="comment">// 结点元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>;</span>     <span class="comment">// 左孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">rchild</span>;</span>     <span class="comment">// 右孩子指针</span></span><br><span class="line">&#125; BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向二叉树结点的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BiTNode* BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************声明部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span>;<span class="comment">//初始化，构造空二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span>;<span class="comment">//若二叉树T为空，则返回TRUE，否则FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span>;<span class="comment">//返回二叉树T的深度</span></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span>;<span class="comment">//返回T的根</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span>;<span class="comment">//按先序输入二叉树中结点的值（一个字符），‘#’字符表示空树</span></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span>;<span class="comment">//对数据元素操作的应用函数</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//先序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//中序递归遍历二叉树T的递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span>;<span class="comment">//后序递归遍历二叉树T的递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************函数部分****************************************/</span></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L,R;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        L = BiTreeDepth(T-&gt;lchild);</span><br><span class="line">        R = BiTreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span>(L &gt; R ? L:R)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TElemType <span class="title">Root</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span>(!(*T))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\t"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">            <span class="keyword">if</span>(PreOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(PreOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(InOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                <span class="keyword">if</span>(InOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PostOrderTraverse(T-&gt;lchild,Visit))</span><br><span class="line">            <span class="keyword">if</span>(PostOrderTraverse(T-&gt;rchild,Visit))</span><br><span class="line">                <span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">                    <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree-main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Status.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BiTree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InitBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始化空二叉树 T。\n"</span>);</span><br><span class="line">        InitBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"CreateBiTree \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"按先序序列创建二叉树 T："</span>);</span><br><span class="line">        CreateBiTree(&amp;T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PreOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"前序遍历二叉树 T："</span>);</span><br><span class="line">        PreOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nInOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"中序遍历二叉树 T："</span>);</span><br><span class="line">        InOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nPostOrderTraverse \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"后序遍历二叉树 T："</span>);</span><br><span class="line">        PostOrderTraverse(T,Visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitBiTree</span><br><span class="line">初始化空二叉树 T。</span><br><span class="line">CreateBiTree</span><br><span class="line">按先序序列创建二叉树 T：ABD<span class="comment">###C#F##</span></span><br><span class="line">PreOrderTraverse</span><br><span class="line">前序遍历二叉树 T：A     B       D       C       F</span><br><span class="line">InOrderTraverse</span><br><span class="line">中序遍历二叉树 T：D     B       A       C       F</span><br><span class="line">PostOrderTraverse</span><br><span class="line">后序遍历二叉树 T：D     B       F       C       A</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的实现及应用</title>
      <link href="2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文记录二叉树的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BiTree.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>)&#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        PreOrderTraversal (T-&gt;lchild);</span><br><span class="line">        PreOrderTraversal (T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InOrderTraversal( T-&gt;lchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">        InOrderTraversal( T-&gt;rchild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span> <span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        PostOrderTraversal( T-&gt;lchild );</span><br><span class="line">        PostOrderTraversal( T-&gt;rchild );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiTree T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create  Binary Tree:"</span>);</span><br><span class="line">CreatBiTree(&amp;T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PreOrder:"</span>);</span><br><span class="line">PreOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InOrder:"</span>);</span><br><span class="line">InOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"PostOrder:"</span>);</span><br><span class="line">PostOrderTraversal(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Create  Binary Tree:ABD<span class="comment">###C#F##</span></span><br><span class="line"></span><br><span class="line">PreOrder:ABDCF</span><br><span class="line"></span><br><span class="line">InOrder:DBACF</span><br><span class="line"></span><br><span class="line">PostOrder:DBFCA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序串的实现及应用</title>
      <link href="2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2021/02/18/%E9%A1%BA%E5%BA%8F%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文记录顺序串的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SString.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE        1   <span class="comment">// 真/是</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE       0   <span class="comment">// 假/否</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK          1   <span class="comment">// 通过/成功</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR       0   <span class="comment">// 错误/失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 状态码类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRLEN 10                                 <span class="comment">// 顺序串的最大串长</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串的顺序存储类型定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN + <span class="number">1</span>];         <span class="comment">// 0号单元存放串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span></span>;       <span class="comment">//构造一个值为chars的串T</span></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span></span>;  <span class="comment">//用T返回由S1和S2联结而成的新串。若未截断，则返回TRUE，否则返回FALSE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span></span>;                      <span class="comment">// 测试函数，打印字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintElem</span><span class="params">(SString S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(SString T, <span class="keyword">const</span> <span class="keyword">char</span>* chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, len;</span><br><span class="line">    </span><br><span class="line">    len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(chars);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// chars过长</span></span><br><span class="line">    <span class="keyword">if</span>(len &gt; MAXSTRLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T[<span class="number">0</span>] = len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        T[i] = chars[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString T, SString S1, SString S2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> uncut;  <span class="comment">// 新串是否完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 完全不需要裁剪</span></span><br><span class="line">    <span class="keyword">if</span>(S1[<span class="number">0</span>] + S2[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制S2到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>] + S2[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = S1[<span class="number">0</span>] + S2[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 未裁剪，完整</span></span><br><span class="line">        uncut = TRUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要裁剪S2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(S1[<span class="number">0</span>] &lt;= MAXSTRLEN) &#123;</span><br><span class="line">        <span class="comment">// 复制S1到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= S1[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将S2的一部分复制到T中</span></span><br><span class="line">        <span class="keyword">for</span>(i = S1[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S2[i - S1[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新长度</span></span><br><span class="line">        T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只需要复制S1的一部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 连同长度信息一起复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= MAXSTRLEN; i++) &#123;</span><br><span class="line">            T[i] = S1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        uncut = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> uncut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"████████ Concat \n"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        SString Tmp1, Tmp2, Tmp3, Tmp4, S1, S2, S3, S4, S5, S6, S7, S8;</span><br><span class="line">        </span><br><span class="line">        StrAssign(S1, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S2, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S1和S2形成 Tmp1 ...\n"</span>);</span><br><span class="line">        Concat(Tmp1, S1, S2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp1 = "</span>);</span><br><span class="line">        PrintElem(Tmp1);</span><br><span class="line"></span><br><span class="line">StrAssign(S3, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S4, <span class="string">"-----"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S3和S4形成 Tmp2 ...\n"</span>);</span><br><span class="line">        Concat(Tmp2, S3, S4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp2 = "</span>);</span><br><span class="line">        PrintElem(Tmp2);</span><br><span class="line"></span><br><span class="line">StrAssign(S5, <span class="string">"+++++"</span>);</span><br><span class="line">        StrAssign(S6, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S5和S6形成 Tmp3 ...\n"</span>);</span><br><span class="line">        Concat(Tmp3, S5, S6);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp3 = "</span>);</span><br><span class="line">        PrintElem(Tmp3);</span><br><span class="line"></span><br><span class="line">StrAssign(S7, <span class="string">"+++++++"</span>);</span><br><span class="line">        StrAssign(S8, <span class="string">"-------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ 联接S7和S8形成 Tmp4 ...\n"</span>);</span><br><span class="line">        Concat(Tmp4, S7, S8);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"█ Tmp4 = "</span>);</span><br><span class="line">        PrintElem(Tmp4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">████████ Concat</span><br><span class="line">█ 联接S1和S2形成 Tmp1 ...</span><br><span class="line">█ Tmp1 = +++++-----</span><br><span class="line">█ 联接S3和S4形成 Tmp2 ...</span><br><span class="line">█ Tmp2 = +++++++---</span><br><span class="line">█ 联接S5和S6形成 Tmp3 ...</span><br><span class="line">█ Tmp3 = +++++-----</span><br><span class="line">█ 联接S7和S8形成 Tmp4 ...</span><br><span class="line">█ Tmp4 = +++++++---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈的实现及应用</title>
      <link href="2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2021/02/10/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文记录顺序栈的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">SElemType *base;</span><br><span class="line">SElemType *top;</span><br><span class="line"><span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空栈S</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">S.top=S.base;</span><br><span class="line">S.stacksize=STACK_INIT_SIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈S，栈S不再存在</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(S.base);</span><br><span class="line">S.base=<span class="literal">NULL</span>;</span><br><span class="line">S.top=<span class="literal">NULL</span>;</span><br><span class="line">S.stacksize=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把栈S置为空栈</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.top=S.base;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈S为空栈，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈S的元素个数，即栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S.top-S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若栈不空，则用e返回S的栈顶元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top&gt;S.base)</span><br><span class="line">&#123;</span><br><span class="line">e=*(S.top<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈：插入元素e作为新的栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)</span><br><span class="line">&#123;</span><br><span class="line">S.base=(SElemType *)<span class="built_in">realloc</span>(S.base,</span><br><span class="line">(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">S.top=S.base+S.stacksize;</span><br><span class="line">S.stacksize+=STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++=e;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈：若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">e=*--S.top;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.1：10进制转化为8进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Conversion_3_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack s;</span><br><span class="line"><span class="keyword">unsigned</span> n;</span><br><span class="line">SElemType e;</span><br><span class="line"></span><br><span class="line">InitStack(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入一个非负10进制整数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%u"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">Push(s,n%<span class="number">8</span>);</span><br><span class="line">n/=<span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"与其等值的8进制数为："</span>);</span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(s))</span><br><span class="line">&#123;</span><br><span class="line">Pop(s,e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法3.2：括号匹配</span></span><br><span class="line"><span class="function">Status <span class="title">Conversion_3_2</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack s;</span><br><span class="line">SElemType e;</span><br><span class="line"></span><br><span class="line">InitStack(s);</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">for</span>(p=str;*p;++p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">'('</span> || *p==<span class="string">'['</span> || *p==<span class="string">'&#123;'</span>)</span><br><span class="line">Push(s,*p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">')'</span> || *p==<span class="string">']'</span> || *p==<span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(s))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Pop(s,e);</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">')'</span> &amp;&amp; e!=<span class="string">'('</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">']'</span> &amp;&amp; e!=<span class="string">'['</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span>(*p==<span class="string">'&#125;'</span> &amp;&amp; e!=<span class="string">'&#123;'</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!StackEmpty(s))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"算法3.1：\n"</span>);</span><br><span class="line">Conversion_3_1();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"算法3.2：\n"</span>);</span><br><span class="line"><span class="keyword">char</span> str[]=<span class="string">"(((1+b)-(a+3)))&#123;12[&#125;[]*4@]"</span>;</span><br><span class="line"><span class="keyword">if</span>(Conversion_3_2(str))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"括号匹配！\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"括号不匹配！\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法<span class="number">3.1</span>：</span><br><span class="line">输入一个非负<span class="number">10</span>进制整数：<span class="number">1348</span></span><br><span class="line">与其等值的<span class="number">8</span>进制数为：<span class="number">2504</span></span><br><span class="line">算法<span class="number">3.2</span>：</span><br><span class="line">括号不匹配！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链队列的实现及应用</title>
      <link href="2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2021/02/10/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文记录单链队列（队列的链式存储结构）的数据结构定义及基本操作的算法描述，并对算法进行简单应用。</li><li>采用C语言实现，其中应用了少数C++特性，比如引用等。</li></ul></blockquote><a id="more"></a><hr><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkQueue.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front;</span><br><span class="line">QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front=Q.rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q.front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁队列Q</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Q.front)</span><br><span class="line">&#123;</span><br><span class="line">Q.rear=Q.front-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(Q.front);</span><br><span class="line">Q.front=Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Q清为空队列</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">q=p;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列Q为空队列，则返回TRUE,否则返回FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回Q的元素个数，即队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line"><span class="keyword">while</span>(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则用e返回Q的队头元素，并返回OK;否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素e作为新的队尾元素</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next=p;</span><br><span class="line">Q.rear=p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">e=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">Q.rear=Q.front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队头到队尾依次对队列Q中每个元素调用函数visit()。一旦visit失败，则操作失败</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(LinkQueue Q,<span class="keyword">void</span> (*visit)(QElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(QElemType i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">QElemType d;</span><br><span class="line">LinkQueue q;</span><br><span class="line">i=InitQueue(q);</span><br><span class="line"><span class="keyword">if</span>(i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"成功地构造了一个空队列！\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"初始化队列后，队列空否？%d(1：空 0：否)，"</span>,QueueEmpty(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line">EnQueue(q,<span class="number">-5</span>);</span><br><span class="line">EnQueue(q,<span class="number">5</span>);</span><br><span class="line">EnQueue(q,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入3个元素（-5,5,10）后，队列长度为：%d\n"</span>,QueueLength(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在队列空否？%d(1：空 0：否)\n"</span>,QueueEmpty(q));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"现在队列中的元素为："</span>);</span><br><span class="line">QueueTraverse(q,visit);</span><br><span class="line">i=GetHead(q,d);</span><br><span class="line"><span class="keyword">if</span>(i==OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队头元素为：%d\n"</span>,d);</span><br><span class="line">DeQueue(q,d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除了队头元素：%d\n"</span>,d);</span><br><span class="line">i=GetHead(q,d);</span><br><span class="line"><span class="keyword">if</span>(i==OK)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"新的队头元素为：%d\n"</span>,d);</span><br><span class="line">ClearQueue(q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"清空队列后，q.front=%u q.rear=%u q.front-&gt;next=%u\n"</span>,q.front,q.rear,q.front-&gt;next);</span><br><span class="line">DestroyQueue(q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"销毁队列后，q.front=%u q.rear=%u\n"</span>,q.front,q.rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">成功地构造了一个空队列！</span><br><span class="line">初始化队列后，队列空否？<span class="number">1</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)，队列长度为：<span class="number">0</span></span><br><span class="line">插入<span class="number">3</span>个元素（<span class="number">-5</span>,<span class="number">5</span>,<span class="number">10</span>）后，队列长度为：<span class="number">3</span></span><br><span class="line">现在队列空否？<span class="number">0</span>(<span class="number">1</span>：空 <span class="number">0</span>：否)</span><br><span class="line">现在队列中的元素为：<span class="number">-5</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line">队头元素为：<span class="number">-5</span></span><br><span class="line">删除了队头元素：<span class="number">-5</span></span><br><span class="line">新的队头元素为：<span class="number">5</span></span><br><span class="line">清空队列后，q.front=10555928 q.rear=10555928 q.front-&gt;next=0</span><br><span class="line">销毁队列后，q.front=<span class="number">0</span> q.rear=<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论持久战</title>
      <link href="2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/"/>
      <url>2021/01/16/%E8%AE%BA%E6%8C%81%E4%B9%85%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-193805b.htm" target="_blank" rel="noopener"><strong>在线阅读网址一</strong></a><br><a href="http://chinatide.net/xiachao/3-2.html" target="_blank" rel="noopener"><strong>在线阅读网址二</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rsync简介</title>
      <link href="2021/01/07/Rsync%E7%AE%80%E4%BB%8B/"/>
      <url>2021/01/07/Rsync%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>Rsync是一个远程数据同步工具，可以实现Windows系统间、Linux系统间以及Windows和Linux系统间的数据同步。</strong><br><strong>本文具体介绍Windows to Windows的使用。</strong></p><a id="more"></a><hr><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>服务端：win2008R2 64bit<br>ip：10.10.4.175<br>数据库：mysql</li><li>客户端：win2008R2 64bit<br>ip：10.10.4.75<br>数据库：mysql</li></ul><p><strong>注意：关闭防火墙，保证服务端和客户端网络相通。</strong></p><hr><h2 id="软件安装及配置"><a href="#软件安装及配置" class="headerlink" title="软件安装及配置"></a>软件安装及配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li>解压服务端软件cwRsyncServer_4.0.5_Installe.zip安装，安装过程选择默认即可。</li><li>打开cwRsyncServer安装路径C:\Program Files(x86)\ICW，其中rsyncd.conf是cwRsyncServer配置文件。修改文件内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use chroot = false</span><br><span class="line">strict modes = false</span><br><span class="line">hosts allow = <span class="number">10.10</span><span class="number">.4</span><span class="number">.75</span> <span class="comment">#限制了只允许10.10.4.75进行连接</span></span><br><span class="line">uid = <span class="number">0</span></span><br><span class="line">gid = <span class="number">0</span></span><br><span class="line">max connections = <span class="number">10</span></span><br><span class="line">strict modes = false</span><br><span class="line">log file = rsyncd.log</span><br><span class="line">lock file = rsyncd.lock</span><br><span class="line">[test] <span class="comment">#模块名称，可自定义</span></span><br><span class="line">path = /cygdrive/e/MySQL Server <span class="number">5.1</span>/data <span class="comment">#需要同步的文件目录</span></span><br><span class="line">read only = false</span><br><span class="line">transfer logging = yes</span><br><span class="line">auth users = test <span class="comment">#用户名</span></span><br><span class="line">secrets file = /cygdrive/c/Program Files (x86)/ICW/rsyncd.secrets <span class="comment">#用户和密码文件，内容为：test:111111</span></span><br><span class="line">comment = test</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：默认rsync使用873端口，自行开启windows 873端口，如果想使用其他端口自行添加port参数。</strong><br>3. 在服务中找到RsyncServer，更改成自动启动，然后确认即可。</p><p>  <img src="/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/1.png" alt></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>将客户端软件cwRsyncClient.rar解压到E盘cwRsync目录下。</li><li>在E:\cwRsync目录下创建一个密码文件password.txt，内容为111111。</li><li>在E:\cwRsync目录下创建一个bat文件rsync.bat。批处理文件内容如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:\cwRsync</span><br><span class="line">rsync -artzvP --delete --password-file=/cygdrive/e/cwRsync/password.txt unary@<span class="number">10.10</span><span class="number">.4</span><span class="number">.175</span>::test <span class="string">"/cygdrive/e/MySQL Server 5.1/data"</span></span><br></pre></td></tr></table></figure>bat脚本命令说明：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 客户端软件解压目录</span><br><span class="line">rsync -artzvP --delete --password-file=客户端密码文件路径 用户名@服务端ip::模块名称 客户端数据同步目录</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="执行同步"><a href="#执行同步" class="headerlink" title="执行同步"></a>执行同步</h2><p>执行rsync.bat即可执行同步任务。</p><p><img src="/2021/01/07/Rsync%E7%AE%80%E4%BB%8B/2.png" alt></p><p>同步完成后，客户端目录下即可看到服务端同步过来的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 高可用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>本文介绍几种常用的排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序。</strong></p><a id="more"></a><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    bubble_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">                temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（Selection Sort）：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    selection_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span>=i;                  <span class="comment">// 记录最小值，第一个元素默认最小</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)<span class="comment">// 访问未排序的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[<span class="built_in">min</span>])<span class="comment">// 找到目前最小值</span></span><br><span class="line">                <span class="built_in">min</span>=j;<span class="comment">// 记录最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[<span class="built_in">min</span>];<span class="comment">// 交换两个变量</span></span><br><span class="line">            a[<span class="built_in">min</span>]=a[i];</span><br><span class="line">            a[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（英语：Insertion Sort）：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    insertion_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">        temp=arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果：-2"><a href="#运行结果：-2" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5 9 22 32 34 35 37 50 55 64 70 82 89</span><br></pre></td></tr></table></figure><hr><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序（Shell Sort）：也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 </li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    shell_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap,i,j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(gap=len&gt;&gt;<span class="number">1</span>;gap&gt;<span class="number">0</span>;gap=gap&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=gap;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-gap;j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;temp;j-=gap)</span><br><span class="line">                arr[j+gap]=arr[j];</span><br><span class="line">            arr[j+gap]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果：-3"><a href="#运行结果：-3" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge Sort）：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>可从上到下或从下到上进行。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mini</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    merge_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mini</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a=arr;</span><br><span class="line">    <span class="keyword">int</span> *b=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> *temp,seg,start;</span><br><span class="line">    <span class="keyword">for</span>(seg=<span class="number">1</span>;seg&lt;len;seg+=seg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span>(start=<span class="number">0</span>;start&lt;len;start+=seg+seg)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">int</span> low=start;</span><br><span class="line"><span class="keyword">int</span> mid=mini(start+seg,len);</span><br><span class="line"><span class="keyword">int</span> high=mini(start+seg+seg,len);</span><br><span class="line">            <span class="keyword">int</span> k=low;</span><br><span class="line">            <span class="keyword">int</span> start1=low;</span><br><span class="line"><span class="keyword">int</span> end1=mid;</span><br><span class="line">            <span class="keyword">int</span> start2=mid;</span><br><span class="line"><span class="keyword">int</span> end2=high;</span><br><span class="line">            <span class="keyword">while</span>(start1&lt;end1&amp;&amp;start2&lt;end2)</span><br><span class="line">                b[k++]=a[start1]&lt;a[start2]?a[start1++]:a[start2++];</span><br><span class="line">            <span class="keyword">while</span>(start1&lt;end1)</span><br><span class="line">                b[k++]=a[start1++];</span><br><span class="line">            <span class="keyword">while</span>(start2&lt;end2)</span><br><span class="line">                b[k++]=a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        temp=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a!=arr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        b=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 14</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">int</span> [],<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> [],<span class="keyword">const</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">22</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">82</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">50</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">64</span>,<span class="number">35</span>,<span class="number">9</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len=(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    merge_sort(arr,len);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> reg[],<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k,len,mid,start1,start2,end1,end2;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=<span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    len=<span class="built_in">end</span>-start;</span><br><span class="line">mid=(len&gt;&gt;<span class="number">1</span>)+start;</span><br><span class="line">    start1=start;</span><br><span class="line">end1=mid;</span><br><span class="line">    start2=mid+<span class="number">1</span>;</span><br><span class="line">end2=<span class="built_in">end</span>;</span><br><span class="line">    merge_sort_recursive(arr,reg,start1,end1);</span><br><span class="line">    merge_sort_recursive(arr,reg,start2,end2);</span><br><span class="line">    k=start;</span><br><span class="line">    <span class="keyword">while</span>(start1&lt;=end1&amp;&amp;start2&lt;=end2)</span><br><span class="line">        reg[k++]=arr[start1]&lt;arr[start2]?arr[start1++]:arr[start2++];</span><br><span class="line">    <span class="keyword">while</span>(start1&lt;=end1)</span><br><span class="line">        reg[k++]=arr[start1++];</span><br><span class="line">    <span class="keyword">while</span>(start2&lt;=end2)</span><br><span class="line">        reg[k++]=arr[start2++];</span><br><span class="line">    <span class="keyword">for</span>(k=start;k&lt;=<span class="built_in">end</span>;k++)</span><br><span class="line">        arr[k]=reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[N];</span><br><span class="line">    merge_sort_recursive(arr,reg,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果：-4"><a href="#运行结果：-4" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">22</span> <span class="number">32</span> <span class="number">34</span> <span class="number">35</span> <span class="number">37</span> <span class="number">50</span> <span class="number">55</span> <span class="number">64</span> <span class="number">70</span> <span class="number">82</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><hr><h2 id="备注：常用排序算法的时间复杂度和空间复杂度"><a href="#备注：常用排序算法的时间复杂度和空间复杂度" class="headerlink" title="备注：常用排序算法的时间复杂度和空间复杂度"></a>备注：常用排序算法的时间复杂度和空间复杂度</h2><img src="/2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/总.png" style="zoom:50%;"><p><img src="/2021/01/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%80%BB1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下通过python的pymysql模块向mysql数据库持续插入图片数据</title>
      <link href="2021/01/05/Linux%E4%B8%8B%E9%80%9A%E8%BF%87python%E7%9A%84pymysql%E6%A8%A1%E5%9D%97%E5%90%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%81%E7%BB%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE/"/>
      <url>2021/01/05/Linux%E4%B8%8B%E9%80%9A%E8%BF%87python%E7%9A%84pymysql%E6%A8%A1%E5%9D%97%E5%90%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%81%E7%BB%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>在灾备软件的压力测试中，需要向客户服务器的数据库持续输入数据，来验证大量IO情况下服务器及灾备软件能否正常工作。本文介绍一种向mysql数据库持续插入图片数据的简单方法。</strong></p><a id="more"></a><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装pymysql模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure><hr><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#图片路径（根据实际情况修改）示例如下：</span></span><br><span class="line">picUrl = <span class="string">"/test/index.jpg"</span></span><br><span class="line"><span class="comment">#连接的数据库服务器主机名（根据实际情况修改）示例如下：</span></span><br><span class="line"><span class="comment">#conhost="127.0.0.1"</span></span><br><span class="line">conhost=<span class="string">"localhost"</span></span><br><span class="line"><span class="comment">#连接的数据库端口号（根据实际情况修改）示例如下：</span></span><br><span class="line">conport=<span class="number">3306</span></span><br><span class="line"><span class="comment">#连接的数据库的用户名（根据实际情况修改）示例如下：</span></span><br><span class="line">conuser=<span class="string">"root"</span></span><br><span class="line"><span class="comment">#连接的数据库密码（根据实际情况修改）示例如下：</span></span><br><span class="line">conpasswd=<span class="string">"111111"</span></span><br><span class="line"><span class="comment">#连接的数据库名（根据实际情况修改）示例如下：</span></span><br><span class="line">condb=<span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobDataTestor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#连接数据库</span></span><br><span class="line">        self.conn = pymysql.connect(host=conhost,port=conport, user=conuser,passwd=conpasswd,db=condb)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.conn.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self)</span>:</span></span><br><span class="line">        cursor = self.conn.cursor()</span><br><span class="line">        cursor.execute(<span class="string">"""  </span></span><br><span class="line"><span class="string">            CREATE TABLE IF NOT EXISTS `Dem_Picture` (  </span></span><br><span class="line"><span class="string">            `ID` int(11) NOT NULL auto_increment,</span></span><br><span class="line"><span class="string">            `time` timestamp  ,</span></span><br><span class="line"><span class="string">            `PicData` mediumblob,</span></span><br><span class="line"><span class="string">            `RandomNum` varchar(20),</span></span><br><span class="line"><span class="string">            PRIMARY KEY (`ID`)  </span></span><br><span class="line"><span class="string">            ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;  </span></span><br><span class="line"><span class="string">            """</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown</span><span class="params">(self)</span>:</span></span><br><span class="line">        cursor = self.conn.cursor()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(<span class="string">"Drop Table Dem_Picture"</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># self.conn.commit()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testRWBlobData</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 读取源图片数据</span></span><br><span class="line">        f = open(picUrl, <span class="string">"rb"</span>)</span><br><span class="line">        b = f.read()</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成随机数</span></span><br><span class="line">        s = <span class="string">''</span>.join(random.choice(string.ascii_uppercase + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据写入表</span></span><br><span class="line">        cursor = self.conn.cursor()</span><br><span class="line">        cursor.execute(<span class="string">"INSERT INTO Dem_Picture (time,PicData,RandomNum) VALUES (current_timestamp,%s,%s)"</span>,((pymysql.Binary(b)),s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    test = BlobDataTestor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#创建表</span></span><br><span class="line">        test.setup()</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            test.testRWBlobData()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"insert success"</span></span><br><span class="line">            <span class="comment">#time.sleep(1)#根据需要设置插入时间间隔</span></span><br><span class="line">        <span class="comment">#删除表</span></span><br><span class="line">        <span class="comment">#test.teardown()</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        test.closedb()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redhat7.6配置163yum源</title>
      <link href="2021/01/05/redhat7-6%E9%85%8D%E7%BD%AE163yum%E6%BA%90/"/>
      <url>2021/01/05/redhat7-6%E9%85%8D%E7%BD%AE163yum%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p><strong>本文介绍redhat7.6服务器上配置163yum源的方法。</strong></p><hr><h2 id="yum源简介"><a href="#yum源简介" class="headerlink" title="yum源简介"></a>yum源简介</h2><ul><li>yum需要一个yum库，也就是yum源。默认情况下，CentOS就有一个yum源，其配置文件在/etc/yum.repos.d/目录下。</li><li>当使用yum下载安装rpm包时，首先要找一个yum库（源），然后确保本地有一个客户端（yum这个命令就是客户端），由yum程序去连接服务器。连接的方式是由配置文件决定的。通过编辑/etc/yum.repos.d/CentOS-Base.repo文件，可以修改设置。</li></ul><a id="more"></a><hr><h2 id="确认版本"><a href="#确认版本" class="headerlink" title="确认版本"></a>确认版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@promote ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">Red Hat Enterprise Linux Server release <span class="number">7.6</span> (Maipo)</span><br></pre></td></tr></table></figure><hr><h2 id="卸载本地yum"><a href="#卸载本地yum" class="headerlink" title="卸载本地yum"></a>卸载本地yum</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep yum　　<span class="comment">#查看本地yum</span></span><br><span class="line">rpm -qa|grep yum|xargs rpm -e --nodeps　　<span class="comment">#卸载本地yum，不检查依赖性，卸载yum程序</span></span><br><span class="line">rpm -qa|grep yum    <span class="comment">#再次查看是否正确卸载</span></span><br></pre></td></tr></table></figure><hr><h2 id="下载yum相关程序"><a href="#下载yum相关程序" class="headerlink" title="下载yum相关程序"></a>下载yum相关程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/python-urlgrabber<span class="number">-3.10</span><span class="number">-10.</span>el7.noarch.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/rpm<span class="number">-4.11</span><span class="number">.3</span><span class="number">-45.</span>el7.x86_64.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum<span class="number">-3.4</span><span class="number">.3</span><span class="number">-168.</span>el7.centos.noarch.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum-metadata-parser<span class="number">-1.1</span><span class="number">.4</span><span class="number">-10.</span>el7.x86_64.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum-plugin-fastestmirror<span class="number">-1.1</span><span class="number">.31</span><span class="number">-54.</span>el7_8.noarch.rpm</span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/centos/<span class="number">7</span>/os/x86_64/Packages/yum-utils<span class="number">-1.1</span><span class="number">.31</span><span class="number">-54.</span>el7_8.noarch.rpm</span><br></pre></td></tr></table></figure><hr><h2 id="安装yum程序"><a href="#安装yum程序" class="headerlink" title="安装yum程序"></a>安装yum程序</h2><p>若提示依赖检测失败，执行以下命令强制安装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh * --force --nodeps <span class="comment">#--force 强制安装，--nodeps 不检查依赖</span></span><br></pre></td></tr></table></figure><hr><h2 id="修改repo文件"><a href="#修改repo文件" class="headerlink" title="修改repo文件"></a>修改repo文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/　　<span class="comment">#进入到yum配置文件目录</span></span><br><span class="line">mkdir repo_backup   <span class="comment">#创建yum备份目录</span></span><br><span class="line">mv *.repo repo_backup   <span class="comment">#备份</span></span><br><span class="line">wget http://mirrors<span class="number">.163</span>.com/.help/CentOS7-Base<span class="number">-163.</span>repo　　<span class="comment">#下载CentOS配置文件</span></span><br></pre></td></tr></table></figure><p>修改CentOS7-Base-163.repo文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi CentOS7-Base<span class="number">-163.</span>repo</span><br><span class="line">:%s/$releasever/<span class="number">7</span>/ge</span><br></pre></td></tr></table></figure><hr><h2 id="清除并更新yum缓存"><a href="#清除并更新yum缓存" class="headerlink" title="清除并更新yum缓存"></a>清除并更新yum缓存</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean all&amp;yum makecache</span><br><span class="line">yum update</span><br><span class="line">yum repolist <span class="comment">#验证结果</span></span><br></pre></td></tr></table></figure><hr><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>当发现仍无需要的软件时，CentOS还有一个源叫做EPEL(Extra Packages for Enterprise)，可尝试安装epel yum源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redhat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redhat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下修改mysql数据库密码的几种方法</title>
      <link href="2021/01/05/Linux%E4%B8%8B%E4%BF%AE%E6%94%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>2021/01/05/Linux%E4%B8%8B%E4%BF%AE%E6%94%B9mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>本文介绍几种常见情况下mysql数据库的密码修改方法。</strong></p><a id="more"></a><hr><h2 id="未设置密码，可以通过mysql直接登录数据库"><a href="#未设置密码，可以通过mysql直接登录数据库" class="headerlink" title="未设置密码，可以通过mysql直接登录数据库"></a>未设置密码，可以通过mysql直接登录数据库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set password=password(<span class="string">"111111"</span>) where user=<span class="string">'root'</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><hr><h2 id="若已知密码，需要修改密码"><a href="#若已知密码，需要修改密码" class="headerlink" title="若已知密码，需要修改密码"></a>若已知密码，需要修改密码</h2><p>除了上述方法，也可以在mysql系统外，使用mysqladmin。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p password <span class="string">"111111"</span></span><br><span class="line">Enter password: 【输入原来的密码】</span><br></pre></td></tr></table></figure><hr><h2 id="若忘记数据库密码，需要修改密码"><a href="#若忘记数据库密码，需要修改密码" class="headerlink" title="若忘记数据库密码，需要修改密码"></a>若忘记数据库密码，需要修改密码</h2><p>1、先停止数据库服务，修改/etc/my.cnf文件，在[mysqld]末尾添加skip-grant-tables；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>2、重新启动数据库，可以通过mysql直接登录数据库；<br>3、修改密码完成后，删除skip-grant-tables。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《热风·随感录四十一》</title>
      <link href="2021/01/04/%E3%80%8A%E7%83%AD%E9%A3%8E%C2%B7%E9%9A%8F%E6%84%9F%E5%BD%95%E5%9B%9B%E5%8D%81%E4%B8%80%E3%80%8B/"/>
      <url>2021/01/04/%E3%80%8A%E7%83%AD%E9%A3%8E%C2%B7%E9%9A%8F%E6%84%9F%E5%BD%95%E5%9B%9B%E5%8D%81%E4%B8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>从一封匿名信里看见一句话，是“数麻石片”(原注江苏方言)，大约是没有本领便不必提倡改革，不如去数石片的好的意思。因此又记起了本志通信栏内所载四川方言的“洗煤炭”。想来别省方言中，相类的话还多；守着这专劝人自暴自弃的格言的人，也怕并不少。</p> <a id="more"></a><p>凡中国人说一句话，做一件事，倘与传来的积习有若干抵触，须一个斤斗便告成功，才有立足的处所；而且被恭维得烙铁一般热。否则免不了标新立异的罪名，不许说话；或者竟成了大逆不道，为天地所不容。这一种人，从前本可以夷到九族，连累邻居；现在却不过是几封匿名信罢了。但意志略略薄弱的人便不免因此萎缩，不知不觉的也入了“数麻石片”党。 </p><p>所以现在的中国，社会上毫无改革，学术上没有发明，美术上也没有创作；至于多人继续的研究，前仆后继的探险，那更不必提了。国人的事业，大抵是专谋时式的成功的经营，以及对于一切的冷笑。 </p><p>但冷笑的人，虽然反对改革，却又未必有保守的能力：即如文字一面，白话固然看不上眼，古文也不甚提得起笔。照他的学说，本该去“数麻石片”了；他却又不然，只是莫名其妙的冷笑。 </p><p>中国的人，大抵在如此空气里成功，在如此空气里萎缩腐败，以至老死。 </p><p>我想，人猿同源的学说，大约可以毫无疑义了。但我不懂，何以从前的古猴子，不都努力变人，却到现在还留着子孙，变把戏给人看。还是那时竟没有一匹想站起来学说人话呢?还是虽然有了几匹，却终被猴子社会攻击他标新立异，都咬死了；所以终于不能进化呢? </p><p>尼采式的超人，虽然太觉渺茫，但就世界观有人种的事实看来，却可以确信将来总有尤为高尚尤近圆满的人类出现。到那时候，类人猿上面，怕要添出“类猿人”这一个名词。 </p><p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。 </p><p>此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。 </p><p>我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。尼采说：“真的，人是一个浊流。应该是海了，能容这浊流使他干净。 </p><p>“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”(《札拉图如是说》的《序言》第三节)<br>　　<br>纵令不过一洼浅水，也可以学学大海；横坚都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。 </p><p>这还算不到“大侮蔑”——因为大侮蔑也须有胆力。</p><p>​                                                                                                                                                                                                                  ——鲁迅</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM之virsh管理命令</title>
      <link href="2021/01/03/KVM%E4%B9%8Bvirsh%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>2021/01/03/KVM%E4%B9%8Bvirsh%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Virsh简介"><a href="#Virsh简介" class="headerlink" title="Virsh简介"></a>Virsh简介</h2><ul><li>virsh 是用来管理客户端及其管理程序的命令行界面工具。</li><li>virsh 工具是构建在 libvirt 管理 API 上，可作为 xm 命令和图形客户端管理程序（virt-manager）的替代工具。非特权用户只能以只读模式使用 virsh。您可使用 virsh 为客户端机器执行脚本。</li></ul><a id="more"></a><hr><h2 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h2><ol><li>安装虚拟化相关组件<br>安装qemu-kvm（用户态管理工具）<br>安装libvirt（命令行管理工具）<br>安装virt-install（安装kvm工具）<br>安装bridge-utils（桥接设备管理工具）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y qemu-kvm libvirt virt-install bridge-utils</span><br></pre></td></tr></table></figure></li><li>启动libvirtd服务<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable libvirtd</span><br><span class="line">systemctl start  libvirtd</span><br><span class="line">systemctl status  libvirtd</span><br></pre></td></tr></table></figure></li><li>安装virt-manager<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install virt-manager</span><br></pre></td></tr></table></figure></li></ol><p>使用可视化创建的虚拟机xml文件位置：/etc/libvirt/qemu/</p><hr><h2 id="常用的虚拟机管理命令"><a href="#常用的虚拟机管理命令" class="headerlink" title="常用的虚拟机管理命令"></a>常用的虚拟机管理命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的虚拟机</span></span><br><span class="line">virsh list --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示虚拟机信息</span></span><br><span class="line">virsh dominfo *( *为虚拟机名称 )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义虚拟机</span></span><br><span class="line">virsh define *.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动虚拟机</span></span><br><span class="line">virsh start *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制关闭虚拟机/关闭虚拟机</span></span><br><span class="line">virsh destroy */virsh shutdown *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除虚拟机</span></span><br><span class="line">virsh undefine *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂起虚拟机</span></span><br><span class="line">virsh suspend *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复被挂起的虚拟机</span></span><br><span class="line">virsh resume *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看虚拟机网卡信息</span></span><br><span class="line">virsh domiflist *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加网卡</span></span><br><span class="line">virsh attach-interface * --type * --source * --model * --live --config</span><br><span class="line">（第一个*为虚拟机名称，后三个*依次为Type Source Model）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除网卡</span></span><br><span class="line">virsh detach-interface * --type  * --mac  *  --live --config</span><br><span class="line">（第一个*为虚拟机名称，后两个*依次为Type MAC）</span><br></pre></td></tr></table></figure><hr><h2 id="通过xml文件创建虚拟机"><a href="#通过xml文件创建虚拟机" class="headerlink" title="通过xml文件创建虚拟机"></a>通过xml文件创建虚拟机</h2><ol><li>创建空镜像<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2  *.qcow2  <span class="number">100</span>G（*为虚拟机名称，大小自定义）</span><br></pre></td></tr></table></figure></li><li>配置xml并启动虚拟机，xml文件配置可通过可视化创建虚拟机生成的xml文件作为模板。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh define *.xml</span><br><span class="line">virsh start  *</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="通过存储池iSCSI创建虚拟机"><a href="#通过存储池iSCSI创建虚拟机" class="headerlink" title="通过存储池iSCSI创建虚拟机"></a>通过存储池iSCSI创建虚拟机</h2><ol><li>定义存储池<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh pool-define-<span class="keyword">as</span> --name unary --type iscsi --source-host <span class="number">10.10</span><span class="number">.4</span><span class="number">.75</span> --source-dev iqn<span class="number">.2020</span><span class="number">-01.</span>com.unary:<span class="number">208450552</span>df3636922c9fbb0b0c71f45.d41d8cd98f00b204e9800998ecf8427e.v<span class="number">.4</span>a2a26d3.st<span class="number">.20200102193701</span> --target /dev/disk/by-path</span><br></pre></td></tr></table></figure></li><li>创建存储池<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh pool-build unary</span><br></pre></td></tr></table></figure></li><li>激活存储池<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh pool-start unary</span><br></pre></td></tr></table></figure></li><li>查看存储池<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh pool-list –all</span><br></pre></td></tr></table></figure></li><li>创建空镜像</li><li>配置xml并启动虚拟机</li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM</title>
      <link href="2021/01/02/KVM/"/>
      <url>2021/01/02/KVM/</url>
      
        <content type="html"><![CDATA[<h2 id="KVM简介"><a href="#KVM简介" class="headerlink" title="KVM简介"></a>KVM简介</h2><p>Kernel-based Virtual Machine的简称，是一个开源的系统虚拟化模块，自Linux2.6.20之后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于Xen，其核心源码很少。KVM目前已成为学术界的主流VMM之一。</p><a id="more"></a><hr><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ol><li><p>Kvm的安装，需要一定的硬件和软件支持：</p><p>​    1.需要宿主机CPU支持完全虚拟化（如Intel VT技术或者AMD V技术）。<br>​    2.宿主机系统为64位的Linux系统且内核版本高于2.6.20，内核版本过低，需要进行升级。 </p></li><li><p>查看CPU是否支持完全虚拟化，在宿主机输入：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">egrep <span class="string">'vmx|svm'</span> /proc/cpuinfo</span><br><span class="line">...</span><br><span class="line">flags  : fpu vme de pse tsc msr pae mce cx8 apic mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm dca sse4_1 sse4_2 popcnt aes lahf_lm ida arat dts tpr_shadow vnmi flexpriority ept vpid</span><br></pre></td></tr></table></figure><p>​       回车后，出现以上结果，说明CPU支持虚拟化且已经开启。Vmx是intel cpu，svm为AMD cpu。另外在选择宿主机系统的时候，尽量不要使用Centos6.3和6.4版本，经验证，这两个版本安装kvm后，会出现图像界面闪烁情况，推荐使用Centos 6.5 64bit。对于宿主机的配置，官方建议为64位x86架构且支持虚拟化指令集的CPU，4G内存，以便发挥kvm最大性能。</p><hr><h2 id="KVM安装"><a href="#KVM安装" class="headerlink" title="KVM安装"></a>KVM安装</h2><ol><li>关闭selinux<br>设置selinux=disable。</li><li>使用yum安装命令进行安装相关软件包</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kvm qemu-kvm virt-viewer virt-manager libvirt libvirt-python python-virtinst bridge-utils tunctl</span><br></pre></td></tr></table></figure><blockquote><ul><li>kvm是属于内核模块；</li></ul></blockquote><blockquote><ul><li>qemu-kvm是kvm的一个管理工具的引擎；</li></ul></blockquote><blockquote><ul><li>libvirt和libvirt-client提供访问和控制虚拟客户端的接口；</li></ul></blockquote><blockquote><ul><li>python-virtinst中有很多用于安装虚拟机的程序，如virt-install，virt-clone等；</li></ul></blockquote><blockquote><ul><li>bridge-utils是一个和网桥有关的程序。</li></ul></blockquote><ol start="3"><li>安装完毕后，Reboot机器</li></ol><hr><h2 id="KVM启用"><a href="#KVM启用" class="headerlink" title="KVM启用"></a>KVM启用</h2><ol><li><p>查看虚拟机安装情况，安装正常会出现如下情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep kvm  </span><br><span class="line">kvm_intel    <span class="number">69416</span>  <span class="number">0</span></span><br><span class="line">kvm           <span class="number">226208</span>  <span class="number">1</span> kvm_amd</span><br></pre></td></tr></table></figure></li><li><p>启动 libvirtd </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service libvirtd start</span><br></pre></td></tr></table></figure></li><li><p>查看虚拟机状态命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virsh  list   --all</span><br><span class="line">Id    Name                    status</span><br><span class="line">----------------------------------------------------</span><br></pre></td></tr></table></figure><p>这样就表明kvm安装成功且已经能正常工作了。</p></li></ol><hr><h2 id="虚拟机安装和设置"><a href="#虚拟机安装和设置" class="headerlink" title="虚拟机安装和设置"></a>虚拟机安装和设置</h2><ol><li>virt-manager图形工具<br>安装kvm成功后，会在system tools中有一个virtual machine manager。Kvm虚拟机的安装维护，主要通过此工具。</li></ol><p><img src="/2021/01/02/KVM/1.png" alt></p><ol start="2"><li>新建kvm虚拟机<br>virtual machine manager 在首次登陆后，会自动创建一个本地的kvm连接。右击选择“new”即可新建虚拟机。</li></ol><p><img src="/2021/01/02/KVM/2.png" alt></p><ol start="3"><li>源文件选择<br>Kvm的源文件安装方式有四种，我们主要熟知第一种和第四种。第一种为选择本地的镜像文件安装，第四种为选择从其他虚拟机（vmware）迁移过来的虚拟机文件，选择后点击“Forward”。</li></ol><p><img src="/2021/01/02/KVM/3.png" alt></p><ol start="4"><li><p>选择源文件路径OS type 和Version可以默认，选择路径后点击“Forward”。</p><p><img src="/2021/01/02/KVM/4.png" alt></p></li><li><p>Cpu和内存设置</p><p>设置虚拟机内存大小和cpu个数，选择后点击“Forword”。</p></li></ol><p><img src="/2021/01/02/KVM/5.png" alt></p><ol start="6"><li><p>设置和网络<br>勾选“customize……install”，这样在点击Finish后，我们可以再具体配置虚拟机的其他选项。<br>Advancde options 下可以设置虚拟机的网络连接类型和MAC地址。</p><p><img src="/2021/01/02/KVM/6.png" alt></p></li><li><p>具体设置<br>在安装前可以具体设置kvm的各个参数。</p></li></ol><p><img src="/2021/01/02/KVM/7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2020</title>
      <link href="2020/12/31/%E6%88%91%E7%9A%842020/"/>
      <url>2020/12/31/%E6%88%91%E7%9A%842020/</url>
      
        <content type="html"><![CDATA[<p>2020，一场突如其来的疫情，让它注定成为不平凡的一年。</p><a id="more"></a><p>听说人这一生中有7次改变自己命运的机会，第一次是15岁，第二次是25岁，依此直到75岁。</p><p>恰巧，今年我25岁。在这一年，发生了许多的事。</p><p>日复一日繁杂的工作让我不断思考我的人生路线。可是，陷入泥潭是难以自拔的。好在积蓄的能量终究会爆发，在无人预料，甚至我自己也毫无准备的情况下，我辞职了。</p><p>毫无顾虑的睡上了几天，远在广东的两个大学同学邀我去广东游玩。于是人生中第一次坐飞机，第一次踏上了祖国的南方大地。</p><p>很快，3人租了辆车，开启了海岛之旅。于是我第一次见到真正的大海，第一次走在真正的沙滩上，感受海水袭来时的重心不稳，吹着海风，吃着海鲜大餐，享受着无与伦比的惬意与快乐。</p><p>也认识了很多朋友，他们是一群积极向上的年轻人，没有大城市的勾心斗角，只有淳朴的热情。可惜我是一个无比慢热的人，甚至没来得及跟他们交换微信，在一次晚餐后匆匆离别，或许就是永别了。</p><p>返回南京，开始找工作，我自信最迟半个月肯定能找到心仪的工作。然而，事实狠狠打了我的脸，眼看一个月了，有几份工作，却都不是我特别满意的。慢慢地，我的耐心被消磨殆尽，也疲于奔波，在看清形势后，找了一份勉强满意的工作，准备一边做着一边找机会跳槽。</p><p>可惜，命运总是会跟你开各种各样的玩笑。一次PM找我谈话，我以为是工作上的事，事实也确实是，不过内容是，我因为某种不可抗力需要转岗或者离开，而此时我进入公司才3周。先是震惊，不过几分钟后我就冷静了下来，因为我已经想好了接下来要做的事。</p><p>有了方向，路途就不再迷茫。虽然可能有点晚，不过相比眼下一眼望到底的人生，似乎一切都还来得及，那就奋起努力吧！</p><p>时间很快，2020还有几个小时就要成为过去式了，而我也将踏上新的人生旅途，过往虽有遗憾，却不后悔。</p><p>别了，2020。你好，2021！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESXi上修改虚拟机磁盘扇区大小为32的简易方法</title>
      <link href="2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/"/>
      <url>2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>本文介绍ESXi服务器上修改虚拟机磁盘扇区大小为32的两种方法。</strong></p><a id="more"></a><hr><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>1、登陆ESXi，进入虚拟机所在的datastore目录，每个目录为一个虚拟机</p><p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/3.png" alt></p><p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/4.png" alt></p><p>2、找到对应的vmdk文件</p><p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/5.png" alt></p><p>3、进入修改</p><p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/6.png" alt></p><p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/7.png" alt></p><p>4、保存退出即可</p><hr><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>1、ESXi上创建需要安装版本的虚拟机，暂不安装系统</p><p>2、将虚拟机的vmdk文件下载到本地进行以下修改</p><p><img src="/2020/12/31/ESXi%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%BA32%E7%9A%84%E7%AE%80%E6%98%93%E6%96%B9%E6%B3%95/8.png" alt></p><p>3、将修改后的vmdk文件上传到ESXi后开始系统安装</p><p>4、安装完成后使用winhex工具查看磁盘扇区数是否为32扇区</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESXi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7.x系统中Docker安装及简单使用</title>
      <link href="2020/12/30/Centos7-x%E7%B3%BB%E7%BB%9F%E4%B8%ADDocker%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/12/30/Centos7-x%E7%B3%BB%E7%BB%9F%E4%B8%ADDocker%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><ul><li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器或Windows 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</li><li>一个完整的Docker由四个部分组成：Docker Client（客户端）、Docker Daemon（守护进程）、Docker Image（镜像）和Docker Container（容器）。</li><li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</li></ul><a id="more"></a><hr><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><pre><code>1、只能是64位的系统;2、要求centos7以上系统的内核版本不低于3.10。</code></pre><hr><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>1、移除旧版本的docker</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine</span><br></pre></td></tr></table></figure><p>2、安装依赖包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>3、添加yum软件源<br>非官方源(比如阿里云)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>官方源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>4、更新yum软件源缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>5、安装docker</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y install  docker-ce</span><br></pre></td></tr></table></figure><p>安装时，如果报错出现rpm包无法找到，先手动通过wget下载该rpm包，然后重新执行安装命令即可。 </p><hr><h2 id="Docker镜像和容器的简单使用命令"><a href="#Docker镜像和容器的简单使用命令" class="headerlink" title="Docker镜像和容器的简单使用命令"></a>Docker镜像和容器的简单使用命令</h2><p>1、查看docker版本： docker  version<br>2、查询镜像： docker  search  imageName[镜像名称：如  centos]<br>3、获取镜像：docker  pull  imageName[镜像名称：如  centos]<br>4、列出镜像:  docker  image  ls<br>5、查询镜像体积：docker system df<br>6、删除镜像:docker  image rm  imagesID<br>7、启动容器： docker  run –name ***  -p  port:port  -d  [镜像名] 或者 docker start [containerID/containerName]<br>8、退出容器：exit/docker  stop containerID<br>9、进入容器：docker  attach  containerID 或者 docker   exec  -it   containerID<br>10、删除容器：<br>1）删除处于终止状态的：docker  container  rm  [ID]<br>2）删除处于运行状态的：docker  container  rm  -f  [ID]<br>3）删除所有处于终止状态的：docker container prune </p><hr><h2 id="Docker安装Tomcat实例"><a href="#Docker安装Tomcat实例" class="headerlink" title="Docker安装Tomcat实例"></a>Docker安装Tomcat实例</h2><p>1、获取tomcat镜像: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  pull  tomcat</span><br></pre></td></tr></table></figure><p>2、新建并运行tomcat容器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run  --name  tomcat  -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>:<span class="number">8080</span>    -d  tomcat</span><br><span class="line">docker run  --name  tomcat  -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>:<span class="number">8080</span>    -d  tomcat --restart=always</span><br></pre></td></tr></table></figure><pre><code>--name：容器名 -p：后面接IP地址(可以不设)：接宿主机端口：容器端口  -d：后台运行</code></pre><p>3、进入容器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker   <span class="keyword">exec</span>/attach  -it  tomcat  bash</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span>进入容器后使用exit命令退出容器，只会退出容器，让容器在后台继续运行</span><br><span class="line">attach进入容器后使用exit命令退出容器，会直接关闭容器</span><br><span class="line">-it：交互模式进入容器</span><br></pre></td></tr></table></figure><p>4、退出tomcat容器：exit<br>5、停止tomcat容器：docker   stop   tomcat<br>6、启动tomcat容器：docker   start   tomcat<br>7、删除tomcat容器：docker   container    rm  -f  tomcat</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信仰</title>
      <link href="2020/12/29/%E4%BF%A1%E4%BB%B0/"/>
      <url>2020/12/29/%E4%BF%A1%E4%BB%B0/</url>
      
        <content type="html"><![CDATA[<p>在这个怀疑的时代，我们依然需要信仰。</p><p>无论中国怎样，请记得：</p><p>你所站立的地方，就是你的中国；</p><p>你怎么样，中国便怎么样；</p><p>你是什么，中国便是什么；</p><p>你有光明，中国便不再黑暗。</p><p>——摘自原北京日报评论部主任卢新宁《2012年北京大学中文系毕业典礼上的讲话》</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7.6下corosync+pacemaker+pcs高可用集群环境安装</title>
      <link href="2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p><strong>在容灾备份领域，有多种高可用方案，corosync+pacemaker无疑是开源方案中的佼佼者。</strong></p><h2 id="什么是corosync、pacemaker、pcs？"><a href="#什么是corosync、pacemaker、pcs？" class="headerlink" title="什么是corosync、pacemaker、pcs？"></a>什么是corosync、pacemaker、pcs？</h2><blockquote><ul><li>Corosync是集群管理套件的一部分，通常会与其他资源管理器一起组合，使用它在传递信息的时候可以通过一个简单的配置文件来定义信息传递的方式和协议等。它是一个新兴的软件，2008年推出，但其实它并不是一个真正意义上的新软件，在2002年的时候有一个项目Openais，它由于过大，分裂为两个子项目，其中可以实现HA心跳信息传输的功能就是Corosync ，它的代码60%左右来源于Openais。Corosync可以提供一个完整的HA功能，但是要实现更多，更复杂的功能，那就需要使用Openais了。Corosync是未来的发展方向，在以后的新项目里，一般采用Corosync，而hb_gui可以提供很好的HA管理功能，可以实现图形化的管理。另外相关的图形化有RHCS的套件luci+ricci，当然还有基于java开发的LCMC集群管理工具。</li></ul></blockquote><blockquote><ul><li>Pacemaker是一个集群资源管理器。它利用集群基础构件（OpenAIS、heartbeat或corosync）提供的消息和成员管理能力来探测并从节点或资源级别的故障中恢复，以实现群集服务（亦称资源）的最大可用性。</li></ul></blockquote><blockquote><ul><li>Pcs是一种常用的集群配置及管理指令集，其他类似命令有crmsh。</li></ul></blockquote><a id="more"></a><hr><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h2><p>1、保证两个节点上的/etc/hosts文件均添加了下面的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span> g0001210030<span class="number">-00</span>-server01</span><br><span class="line"><span class="number">10.10</span><span class="number">.4</span><span class="number">.177</span> g0001210030<span class="number">-00</span>-server02</span><br></pre></td></tr></table></figure><p>2、关闭防火墙（每个节点都需执行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setenforce <span class="number">0</span></span><br><span class="line">sed -i.bak <span class="string">"s/SELINUX=enforcing/SELINUX=permissive/g"</span> /etc/selinux/config</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">iptables --flush</span><br></pre></td></tr></table></figure><p>3、查看主备机是否安装ntp服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status ntpd.service</span><br></pre></td></tr></table></figure><p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic1.png" alt></p><p>若未安装ntp服务，先安装，确认安装ntp服务后，主机执行以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/ntp.conf /etc/ntp.conf.bak</span><br><span class="line">rm -f /etc/ntp.conf</span><br><span class="line">vi /etc/ntp.conf</span><br></pre></td></tr></table></figure><p>在/etc/ntp.conf文件输入以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">restrict default kod nomodify notrap nopeer noquery</span><br><span class="line">restrict <span class="number">-6</span> default kod nomodify notrap nopper noquery</span><br><span class="line">restrict <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">restrict <span class="number">-6</span>::<span class="number">1</span></span><br><span class="line">restrict <span class="number">10.10</span><span class="number">.1</span><span class="number">.0</span> mask <span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span> nomodify notrap</span><br><span class="line">server <span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span></span><br><span class="line">server <span class="number">127.127</span><span class="number">.1</span><span class="number">.0</span></span><br><span class="line">fudge <span class="number">127.127</span><span class="number">.1</span><span class="number">.0</span> stratum <span class="number">10</span></span><br></pre></td></tr></table></figure><p>启动主机ntp服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#systemctl start ntpd.service</span></span><br></pre></td></tr></table></figure><p>备机执行以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate <span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span></span><br></pre></td></tr></table></figure><p>如果出现下面提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span> Sep <span class="number">18</span>:<span class="number">01</span>:<span class="number">41</span> ntpdate[<span class="number">2604</span>]: no server suitable <span class="keyword">for</span> synchronization found</span><br></pre></td></tr></table></figure><p>稍等片刻再执行一次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate <span class="number">10.10</span><span class="number">.4</span><span class="number">.176</span></span><br></pre></td></tr></table></figure><hr><h2 id="安装集群软件"><a href="#安装集群软件" class="headerlink" title="安装集群软件"></a><strong>安装集群软件</strong></h2><p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic2.png" alt></p><p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic3.png" alt></p><p>安装完毕，输入pcs status查询集群状态为下图所示，表示集群安装成功</p><p><img src="/2020/12/28/Centos7-6%E4%B8%8Bcorosync-pacemaker-pcs%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/pic4.png" alt></p><hr><h2 id="集群资源配置"><a href="#集群资源配置" class="headerlink" title="集群资源配置"></a><strong>集群资源配置</strong></h2><p>1、注意：配置集群资源时，为防止资源启动的节点不一致，需要暂时将备节点的集群服务停止。在任意节点输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs cluster stop G0001210030<span class="number">-00</span>-SERVER02</span><br></pre></td></tr></table></figure><p>即可关闭备节点集群服务。</p><p>2、配置浮动IP和ha服务高可用（ip需根据实际情况修改、在任意节点配置即可）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pcs resource create vip ocf:heartbeat:IPaddr2 ip=<span class="number">192.168</span><span class="number">.8</span><span class="number">.53</span> cidr_netmask=<span class="number">16</span> op monitor interval=<span class="number">30</span>s</span><br><span class="line">pcs resource create ha systemd:ha op monitor interval=<span class="number">60</span>s timeout=<span class="number">60</span>s on-fail=restart</span><br></pre></td></tr></table></figure><p>配置资源关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs constraint colocation add vip ha INFINITY</span><br></pre></td></tr></table></figure><p>设置启动顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs constraint order vip  then ha</span><br></pre></td></tr></table></figure><p>3、配置其他资源，如mariadb数据库服务（在任意节点配置即可，需要注意的是：配置mariadb服务高可用需要将mariadb服务设置为开机不自启）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs resource create mysql-s systemd:mariadb op monitor interval=<span class="number">60</span>s timeout=<span class="number">60</span>s on-fail=restart</span><br></pre></td></tr></table></figure><p>配置资源关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs constraint colocation add ha mysql-s INFINITY</span><br></pre></td></tr></table></figure><p>设置启动顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcs constraint order ha then mysql-s</span><br></pre></td></tr></table></figure><p><strong>至此整个搭建过程完毕。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 高可用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如猫从世界上消失了</title>
      <link href="2020/07/14/%E5%81%87%E5%A6%82%E7%8C%AB%E4%BB%8E%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B6%88%E5%A4%B1%E4%BA%86/"/>
      <url>2020/07/14/%E5%81%87%E5%A6%82%E7%8C%AB%E4%BB%8E%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B6%88%E5%A4%B1%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>假如猫从世界上消失了<br>那这个世界会有如何的变化呢<br>假如我从世界上消失了<br>那究竟会有谁为我悲伤呢<br>假如我从世界上消失了<br>那些未实现的梦想和思绪<br>那些在我存活时未能完成的事情<br>对此我一定会抱有许多遗憾吧<br>然而，这个世界我在与不在<br>相信一定会有所不同<br>也许真的只是些小小的不同<br>然而正是它们<br>是我存在过的证明<br>是我挣扎着，烦恼着，生活过的证明</p><p><img src="/2020/07/14/%E5%81%87%E5%A6%82%E7%8C%AB%E4%BB%8E%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B6%88%E5%A4%B1%E4%BA%86/%E5%81%87%E5%A6%82%E7%8C%AB%E4%BB%8E%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B6%88%E5%A4%B1%E4%BA%86.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 电影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
